
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model ClienteContatto
 * 
 */
export type ClienteContatto = $Result.DefaultSelection<Prisma.$ClienteContattoPayload>
/**
 * Model ClienteContratto
 * 
 */
export type ClienteContratto = $Result.DefaultSelection<Prisma.$ClienteContrattoPayload>
/**
 * Model ClienteNota
 * 
 */
export type ClienteNota = $Result.DefaultSelection<Prisma.$ClienteNotaPayload>
/**
 * Model ClienteProdotto
 * 
 */
export type ClienteProdotto = $Result.DefaultSelection<Prisma.$ClienteProdottoPayload>
/**
 * Model Operazione
 * 
 */
export type Operazione = $Result.DefaultSelection<Prisma.$OperazionePayload>
/**
 * Model OperazioneFirma
 * 
 */
export type OperazioneFirma = $Result.DefaultSelection<Prisma.$OperazioneFirmaPayload>
/**
 * Model OperazioneDescrizazioni
 * 
 */
export type OperazioneDescrizazioni = $Result.DefaultSelection<Prisma.$OperazioneDescrizazioniPayload>
/**
 * Model OperazionePutazione
 * 
 */
export type OperazionePutazione = $Result.DefaultSelection<Prisma.$OperazionePutazionePayload>
/**
 * Model Prodotto
 * 
 */
export type Prodotto = $Result.DefaultSelection<Prisma.$ProdottoPayload>
/**
 * Model ProdottoVoce
 * 
 */
export type ProdottoVoce = $Result.DefaultSelection<Prisma.$ProdottoVocePayload>
/**
 * Model Contratto
 * 
 */
export type Contratto = $Result.DefaultSelection<Prisma.$ContrattoPayload>
/**
 * Model PianningTipoIntervento
 * 
 */
export type PianningTipoIntervento = $Result.DefaultSelection<Prisma.$PianningTipoInterventoPayload>
/**
 * Model PianningEmail
 * 
 */
export type PianningEmail = $Result.DefaultSelection<Prisma.$PianningEmailPayload>
/**
 * Model VociIntervento
 * 
 */
export type VociIntervento = $Result.DefaultSelection<Prisma.$VociInterventoPayload>
/**
 * Model Straordinario
 * 
 */
export type Straordinario = $Result.DefaultSelection<Prisma.$StraordinarioPayload>
/**
 * Model InserimentoStraordinario
 * 
 */
export type InserimentoStraordinario = $Result.DefaultSelection<Prisma.$InserimentoStraordinarioPayload>
/**
 * Model ImpostazioniUtente
 * 
 */
export type ImpostazioniUtente = $Result.DefaultSelection<Prisma.$ImpostazioniUtentePayload>
/**
 * Model SpeseNotti
 * 
 */
export type SpeseNotti = $Result.DefaultSelection<Prisma.$SpeseNottiPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clienteContatto`: Exposes CRUD operations for the **ClienteContatto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClienteContattos
    * const clienteContattos = await prisma.clienteContatto.findMany()
    * ```
    */
  get clienteContatto(): Prisma.ClienteContattoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clienteContratto`: Exposes CRUD operations for the **ClienteContratto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClienteContrattos
    * const clienteContrattos = await prisma.clienteContratto.findMany()
    * ```
    */
  get clienteContratto(): Prisma.ClienteContrattoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clienteNota`: Exposes CRUD operations for the **ClienteNota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClienteNotas
    * const clienteNotas = await prisma.clienteNota.findMany()
    * ```
    */
  get clienteNota(): Prisma.ClienteNotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clienteProdotto`: Exposes CRUD operations for the **ClienteProdotto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClienteProdottos
    * const clienteProdottos = await prisma.clienteProdotto.findMany()
    * ```
    */
  get clienteProdotto(): Prisma.ClienteProdottoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operazione`: Exposes CRUD operations for the **Operazione** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operaziones
    * const operaziones = await prisma.operazione.findMany()
    * ```
    */
  get operazione(): Prisma.OperazioneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operazioneFirma`: Exposes CRUD operations for the **OperazioneFirma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperazioneFirmas
    * const operazioneFirmas = await prisma.operazioneFirma.findMany()
    * ```
    */
  get operazioneFirma(): Prisma.OperazioneFirmaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operazioneDescrizazioni`: Exposes CRUD operations for the **OperazioneDescrizazioni** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperazioneDescrizazionis
    * const operazioneDescrizazionis = await prisma.operazioneDescrizazioni.findMany()
    * ```
    */
  get operazioneDescrizazioni(): Prisma.OperazioneDescrizazioniDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operazionePutazione`: Exposes CRUD operations for the **OperazionePutazione** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperazionePutaziones
    * const operazionePutaziones = await prisma.operazionePutazione.findMany()
    * ```
    */
  get operazionePutazione(): Prisma.OperazionePutazioneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prodotto`: Exposes CRUD operations for the **Prodotto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prodottos
    * const prodottos = await prisma.prodotto.findMany()
    * ```
    */
  get prodotto(): Prisma.ProdottoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prodottoVoce`: Exposes CRUD operations for the **ProdottoVoce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProdottoVoces
    * const prodottoVoces = await prisma.prodottoVoce.findMany()
    * ```
    */
  get prodottoVoce(): Prisma.ProdottoVoceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contratto`: Exposes CRUD operations for the **Contratto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contrattos
    * const contrattos = await prisma.contratto.findMany()
    * ```
    */
  get contratto(): Prisma.ContrattoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pianningTipoIntervento`: Exposes CRUD operations for the **PianningTipoIntervento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PianningTipoInterventos
    * const pianningTipoInterventos = await prisma.pianningTipoIntervento.findMany()
    * ```
    */
  get pianningTipoIntervento(): Prisma.PianningTipoInterventoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pianningEmail`: Exposes CRUD operations for the **PianningEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PianningEmails
    * const pianningEmails = await prisma.pianningEmail.findMany()
    * ```
    */
  get pianningEmail(): Prisma.PianningEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vociIntervento`: Exposes CRUD operations for the **VociIntervento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VociInterventos
    * const vociInterventos = await prisma.vociIntervento.findMany()
    * ```
    */
  get vociIntervento(): Prisma.VociInterventoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.straordinario`: Exposes CRUD operations for the **Straordinario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Straordinarios
    * const straordinarios = await prisma.straordinario.findMany()
    * ```
    */
  get straordinario(): Prisma.StraordinarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inserimentoStraordinario`: Exposes CRUD operations for the **InserimentoStraordinario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InserimentoStraordinarios
    * const inserimentoStraordinarios = await prisma.inserimentoStraordinario.findMany()
    * ```
    */
  get inserimentoStraordinario(): Prisma.InserimentoStraordinarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.impostazioniUtente`: Exposes CRUD operations for the **ImpostazioniUtente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImpostazioniUtentes
    * const impostazioniUtentes = await prisma.impostazioniUtente.findMany()
    * ```
    */
  get impostazioniUtente(): Prisma.ImpostazioniUtenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speseNotti`: Exposes CRUD operations for the **SpeseNotti** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeseNottis
    * const speseNottis = await prisma.speseNotti.findMany()
    * ```
    */
  get speseNotti(): Prisma.SpeseNottiDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.0
   * Query Engine version: ab56fe763f921d033a6c195e7ddeb3e255bdbb57
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Cliente: 'Cliente',
    ClienteContatto: 'ClienteContatto',
    ClienteContratto: 'ClienteContratto',
    ClienteNota: 'ClienteNota',
    ClienteProdotto: 'ClienteProdotto',
    Operazione: 'Operazione',
    OperazioneFirma: 'OperazioneFirma',
    OperazioneDescrizazioni: 'OperazioneDescrizazioni',
    OperazionePutazione: 'OperazionePutazione',
    Prodotto: 'Prodotto',
    ProdottoVoce: 'ProdottoVoce',
    Contratto: 'Contratto',
    PianningTipoIntervento: 'PianningTipoIntervento',
    PianningEmail: 'PianningEmail',
    VociIntervento: 'VociIntervento',
    Straordinario: 'Straordinario',
    InserimentoStraordinario: 'InserimentoStraordinario',
    ImpostazioniUtente: 'ImpostazioniUtente',
    SpeseNotti: 'SpeseNotti'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "cliente" | "clienteContatto" | "clienteContratto" | "clienteNota" | "clienteProdotto" | "operazione" | "operazioneFirma" | "operazioneDescrizazioni" | "operazionePutazione" | "prodotto" | "prodottoVoce" | "contratto" | "pianningTipoIntervento" | "pianningEmail" | "vociIntervento" | "straordinario" | "inserimentoStraordinario" | "impostazioniUtente" | "speseNotti"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      ClienteContatto: {
        payload: Prisma.$ClienteContattoPayload<ExtArgs>
        fields: Prisma.ClienteContattoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteContattoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteContattoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>
          }
          findFirst: {
            args: Prisma.ClienteContattoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteContattoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>
          }
          findMany: {
            args: Prisma.ClienteContattoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>[]
          }
          create: {
            args: Prisma.ClienteContattoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>
          }
          createMany: {
            args: Prisma.ClienteContattoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteContattoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>[]
          }
          delete: {
            args: Prisma.ClienteContattoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>
          }
          update: {
            args: Prisma.ClienteContattoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>
          }
          deleteMany: {
            args: Prisma.ClienteContattoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteContattoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteContattoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>[]
          }
          upsert: {
            args: Prisma.ClienteContattoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContattoPayload>
          }
          aggregate: {
            args: Prisma.ClienteContattoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClienteContatto>
          }
          groupBy: {
            args: Prisma.ClienteContattoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteContattoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteContattoCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteContattoCountAggregateOutputType> | number
          }
        }
      }
      ClienteContratto: {
        payload: Prisma.$ClienteContrattoPayload<ExtArgs>
        fields: Prisma.ClienteContrattoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteContrattoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteContrattoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>
          }
          findFirst: {
            args: Prisma.ClienteContrattoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteContrattoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>
          }
          findMany: {
            args: Prisma.ClienteContrattoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>[]
          }
          create: {
            args: Prisma.ClienteContrattoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>
          }
          createMany: {
            args: Prisma.ClienteContrattoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteContrattoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>[]
          }
          delete: {
            args: Prisma.ClienteContrattoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>
          }
          update: {
            args: Prisma.ClienteContrattoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>
          }
          deleteMany: {
            args: Prisma.ClienteContrattoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteContrattoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteContrattoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>[]
          }
          upsert: {
            args: Prisma.ClienteContrattoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteContrattoPayload>
          }
          aggregate: {
            args: Prisma.ClienteContrattoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClienteContratto>
          }
          groupBy: {
            args: Prisma.ClienteContrattoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteContrattoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteContrattoCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteContrattoCountAggregateOutputType> | number
          }
        }
      }
      ClienteNota: {
        payload: Prisma.$ClienteNotaPayload<ExtArgs>
        fields: Prisma.ClienteNotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteNotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteNotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>
          }
          findFirst: {
            args: Prisma.ClienteNotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteNotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>
          }
          findMany: {
            args: Prisma.ClienteNotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>[]
          }
          create: {
            args: Prisma.ClienteNotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>
          }
          createMany: {
            args: Prisma.ClienteNotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteNotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>[]
          }
          delete: {
            args: Prisma.ClienteNotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>
          }
          update: {
            args: Prisma.ClienteNotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>
          }
          deleteMany: {
            args: Prisma.ClienteNotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteNotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteNotaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>[]
          }
          upsert: {
            args: Prisma.ClienteNotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteNotaPayload>
          }
          aggregate: {
            args: Prisma.ClienteNotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClienteNota>
          }
          groupBy: {
            args: Prisma.ClienteNotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteNotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteNotaCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteNotaCountAggregateOutputType> | number
          }
        }
      }
      ClienteProdotto: {
        payload: Prisma.$ClienteProdottoPayload<ExtArgs>
        fields: Prisma.ClienteProdottoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteProdottoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteProdottoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>
          }
          findFirst: {
            args: Prisma.ClienteProdottoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteProdottoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>
          }
          findMany: {
            args: Prisma.ClienteProdottoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>[]
          }
          create: {
            args: Prisma.ClienteProdottoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>
          }
          createMany: {
            args: Prisma.ClienteProdottoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteProdottoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>[]
          }
          delete: {
            args: Prisma.ClienteProdottoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>
          }
          update: {
            args: Prisma.ClienteProdottoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>
          }
          deleteMany: {
            args: Prisma.ClienteProdottoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteProdottoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClienteProdottoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>[]
          }
          upsert: {
            args: Prisma.ClienteProdottoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClienteProdottoPayload>
          }
          aggregate: {
            args: Prisma.ClienteProdottoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClienteProdotto>
          }
          groupBy: {
            args: Prisma.ClienteProdottoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteProdottoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteProdottoCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteProdottoCountAggregateOutputType> | number
          }
        }
      }
      Operazione: {
        payload: Prisma.$OperazionePayload<ExtArgs>
        fields: Prisma.OperazioneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperazioneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperazioneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>
          }
          findFirst: {
            args: Prisma.OperazioneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperazioneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>
          }
          findMany: {
            args: Prisma.OperazioneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>[]
          }
          create: {
            args: Prisma.OperazioneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>
          }
          createMany: {
            args: Prisma.OperazioneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperazioneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>[]
          }
          delete: {
            args: Prisma.OperazioneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>
          }
          update: {
            args: Prisma.OperazioneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>
          }
          deleteMany: {
            args: Prisma.OperazioneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperazioneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperazioneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>[]
          }
          upsert: {
            args: Prisma.OperazioneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePayload>
          }
          aggregate: {
            args: Prisma.OperazioneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperazione>
          }
          groupBy: {
            args: Prisma.OperazioneGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperazioneGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperazioneCountArgs<ExtArgs>
            result: $Utils.Optional<OperazioneCountAggregateOutputType> | number
          }
        }
      }
      OperazioneFirma: {
        payload: Prisma.$OperazioneFirmaPayload<ExtArgs>
        fields: Prisma.OperazioneFirmaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperazioneFirmaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperazioneFirmaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>
          }
          findFirst: {
            args: Prisma.OperazioneFirmaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperazioneFirmaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>
          }
          findMany: {
            args: Prisma.OperazioneFirmaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>[]
          }
          create: {
            args: Prisma.OperazioneFirmaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>
          }
          createMany: {
            args: Prisma.OperazioneFirmaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperazioneFirmaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>[]
          }
          delete: {
            args: Prisma.OperazioneFirmaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>
          }
          update: {
            args: Prisma.OperazioneFirmaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>
          }
          deleteMany: {
            args: Prisma.OperazioneFirmaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperazioneFirmaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperazioneFirmaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>[]
          }
          upsert: {
            args: Prisma.OperazioneFirmaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneFirmaPayload>
          }
          aggregate: {
            args: Prisma.OperazioneFirmaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperazioneFirma>
          }
          groupBy: {
            args: Prisma.OperazioneFirmaGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperazioneFirmaGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperazioneFirmaCountArgs<ExtArgs>
            result: $Utils.Optional<OperazioneFirmaCountAggregateOutputType> | number
          }
        }
      }
      OperazioneDescrizazioni: {
        payload: Prisma.$OperazioneDescrizazioniPayload<ExtArgs>
        fields: Prisma.OperazioneDescrizazioniFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperazioneDescrizazioniFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperazioneDescrizazioniFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>
          }
          findFirst: {
            args: Prisma.OperazioneDescrizazioniFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperazioneDescrizazioniFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>
          }
          findMany: {
            args: Prisma.OperazioneDescrizazioniFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>[]
          }
          create: {
            args: Prisma.OperazioneDescrizazioniCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>
          }
          createMany: {
            args: Prisma.OperazioneDescrizazioniCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperazioneDescrizazioniCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>[]
          }
          delete: {
            args: Prisma.OperazioneDescrizazioniDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>
          }
          update: {
            args: Prisma.OperazioneDescrizazioniUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>
          }
          deleteMany: {
            args: Prisma.OperazioneDescrizazioniDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperazioneDescrizazioniUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperazioneDescrizazioniUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>[]
          }
          upsert: {
            args: Prisma.OperazioneDescrizazioniUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazioneDescrizazioniPayload>
          }
          aggregate: {
            args: Prisma.OperazioneDescrizazioniAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperazioneDescrizazioni>
          }
          groupBy: {
            args: Prisma.OperazioneDescrizazioniGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperazioneDescrizazioniGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperazioneDescrizazioniCountArgs<ExtArgs>
            result: $Utils.Optional<OperazioneDescrizazioniCountAggregateOutputType> | number
          }
        }
      }
      OperazionePutazione: {
        payload: Prisma.$OperazionePutazionePayload<ExtArgs>
        fields: Prisma.OperazionePutazioneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperazionePutazioneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperazionePutazioneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>
          }
          findFirst: {
            args: Prisma.OperazionePutazioneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperazionePutazioneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>
          }
          findMany: {
            args: Prisma.OperazionePutazioneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>[]
          }
          create: {
            args: Prisma.OperazionePutazioneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>
          }
          createMany: {
            args: Prisma.OperazionePutazioneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperazionePutazioneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>[]
          }
          delete: {
            args: Prisma.OperazionePutazioneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>
          }
          update: {
            args: Prisma.OperazionePutazioneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>
          }
          deleteMany: {
            args: Prisma.OperazionePutazioneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperazionePutazioneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperazionePutazioneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>[]
          }
          upsert: {
            args: Prisma.OperazionePutazioneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperazionePutazionePayload>
          }
          aggregate: {
            args: Prisma.OperazionePutazioneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperazionePutazione>
          }
          groupBy: {
            args: Prisma.OperazionePutazioneGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperazionePutazioneGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperazionePutazioneCountArgs<ExtArgs>
            result: $Utils.Optional<OperazionePutazioneCountAggregateOutputType> | number
          }
        }
      }
      Prodotto: {
        payload: Prisma.$ProdottoPayload<ExtArgs>
        fields: Prisma.ProdottoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdottoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdottoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>
          }
          findFirst: {
            args: Prisma.ProdottoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdottoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>
          }
          findMany: {
            args: Prisma.ProdottoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>[]
          }
          create: {
            args: Prisma.ProdottoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>
          }
          createMany: {
            args: Prisma.ProdottoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProdottoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>[]
          }
          delete: {
            args: Prisma.ProdottoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>
          }
          update: {
            args: Prisma.ProdottoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>
          }
          deleteMany: {
            args: Prisma.ProdottoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProdottoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProdottoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>[]
          }
          upsert: {
            args: Prisma.ProdottoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoPayload>
          }
          aggregate: {
            args: Prisma.ProdottoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProdotto>
          }
          groupBy: {
            args: Prisma.ProdottoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdottoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdottoCountArgs<ExtArgs>
            result: $Utils.Optional<ProdottoCountAggregateOutputType> | number
          }
        }
      }
      ProdottoVoce: {
        payload: Prisma.$ProdottoVocePayload<ExtArgs>
        fields: Prisma.ProdottoVoceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProdottoVoceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProdottoVoceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>
          }
          findFirst: {
            args: Prisma.ProdottoVoceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProdottoVoceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>
          }
          findMany: {
            args: Prisma.ProdottoVoceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>[]
          }
          create: {
            args: Prisma.ProdottoVoceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>
          }
          createMany: {
            args: Prisma.ProdottoVoceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProdottoVoceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>[]
          }
          delete: {
            args: Prisma.ProdottoVoceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>
          }
          update: {
            args: Prisma.ProdottoVoceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>
          }
          deleteMany: {
            args: Prisma.ProdottoVoceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProdottoVoceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProdottoVoceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>[]
          }
          upsert: {
            args: Prisma.ProdottoVoceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProdottoVocePayload>
          }
          aggregate: {
            args: Prisma.ProdottoVoceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProdottoVoce>
          }
          groupBy: {
            args: Prisma.ProdottoVoceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdottoVoceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProdottoVoceCountArgs<ExtArgs>
            result: $Utils.Optional<ProdottoVoceCountAggregateOutputType> | number
          }
        }
      }
      Contratto: {
        payload: Prisma.$ContrattoPayload<ExtArgs>
        fields: Prisma.ContrattoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContrattoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContrattoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>
          }
          findFirst: {
            args: Prisma.ContrattoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContrattoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>
          }
          findMany: {
            args: Prisma.ContrattoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>[]
          }
          create: {
            args: Prisma.ContrattoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>
          }
          createMany: {
            args: Prisma.ContrattoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContrattoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>[]
          }
          delete: {
            args: Prisma.ContrattoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>
          }
          update: {
            args: Prisma.ContrattoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>
          }
          deleteMany: {
            args: Prisma.ContrattoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContrattoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContrattoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>[]
          }
          upsert: {
            args: Prisma.ContrattoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContrattoPayload>
          }
          aggregate: {
            args: Prisma.ContrattoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContratto>
          }
          groupBy: {
            args: Prisma.ContrattoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContrattoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContrattoCountArgs<ExtArgs>
            result: $Utils.Optional<ContrattoCountAggregateOutputType> | number
          }
        }
      }
      PianningTipoIntervento: {
        payload: Prisma.$PianningTipoInterventoPayload<ExtArgs>
        fields: Prisma.PianningTipoInterventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PianningTipoInterventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PianningTipoInterventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>
          }
          findFirst: {
            args: Prisma.PianningTipoInterventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PianningTipoInterventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>
          }
          findMany: {
            args: Prisma.PianningTipoInterventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>[]
          }
          create: {
            args: Prisma.PianningTipoInterventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>
          }
          createMany: {
            args: Prisma.PianningTipoInterventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PianningTipoInterventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>[]
          }
          delete: {
            args: Prisma.PianningTipoInterventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>
          }
          update: {
            args: Prisma.PianningTipoInterventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>
          }
          deleteMany: {
            args: Prisma.PianningTipoInterventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PianningTipoInterventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PianningTipoInterventoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>[]
          }
          upsert: {
            args: Prisma.PianningTipoInterventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningTipoInterventoPayload>
          }
          aggregate: {
            args: Prisma.PianningTipoInterventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePianningTipoIntervento>
          }
          groupBy: {
            args: Prisma.PianningTipoInterventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PianningTipoInterventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PianningTipoInterventoCountArgs<ExtArgs>
            result: $Utils.Optional<PianningTipoInterventoCountAggregateOutputType> | number
          }
        }
      }
      PianningEmail: {
        payload: Prisma.$PianningEmailPayload<ExtArgs>
        fields: Prisma.PianningEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PianningEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PianningEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>
          }
          findFirst: {
            args: Prisma.PianningEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PianningEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>
          }
          findMany: {
            args: Prisma.PianningEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>[]
          }
          create: {
            args: Prisma.PianningEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>
          }
          createMany: {
            args: Prisma.PianningEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PianningEmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>[]
          }
          delete: {
            args: Prisma.PianningEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>
          }
          update: {
            args: Prisma.PianningEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>
          }
          deleteMany: {
            args: Prisma.PianningEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PianningEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PianningEmailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>[]
          }
          upsert: {
            args: Prisma.PianningEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PianningEmailPayload>
          }
          aggregate: {
            args: Prisma.PianningEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePianningEmail>
          }
          groupBy: {
            args: Prisma.PianningEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<PianningEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.PianningEmailCountArgs<ExtArgs>
            result: $Utils.Optional<PianningEmailCountAggregateOutputType> | number
          }
        }
      }
      VociIntervento: {
        payload: Prisma.$VociInterventoPayload<ExtArgs>
        fields: Prisma.VociInterventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VociInterventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VociInterventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>
          }
          findFirst: {
            args: Prisma.VociInterventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VociInterventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>
          }
          findMany: {
            args: Prisma.VociInterventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>[]
          }
          create: {
            args: Prisma.VociInterventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>
          }
          createMany: {
            args: Prisma.VociInterventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VociInterventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>[]
          }
          delete: {
            args: Prisma.VociInterventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>
          }
          update: {
            args: Prisma.VociInterventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>
          }
          deleteMany: {
            args: Prisma.VociInterventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VociInterventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VociInterventoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>[]
          }
          upsert: {
            args: Prisma.VociInterventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VociInterventoPayload>
          }
          aggregate: {
            args: Prisma.VociInterventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVociIntervento>
          }
          groupBy: {
            args: Prisma.VociInterventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VociInterventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VociInterventoCountArgs<ExtArgs>
            result: $Utils.Optional<VociInterventoCountAggregateOutputType> | number
          }
        }
      }
      Straordinario: {
        payload: Prisma.$StraordinarioPayload<ExtArgs>
        fields: Prisma.StraordinarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StraordinarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StraordinarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>
          }
          findFirst: {
            args: Prisma.StraordinarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StraordinarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>
          }
          findMany: {
            args: Prisma.StraordinarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>[]
          }
          create: {
            args: Prisma.StraordinarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>
          }
          createMany: {
            args: Prisma.StraordinarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StraordinarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>[]
          }
          delete: {
            args: Prisma.StraordinarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>
          }
          update: {
            args: Prisma.StraordinarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>
          }
          deleteMany: {
            args: Prisma.StraordinarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StraordinarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StraordinarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>[]
          }
          upsert: {
            args: Prisma.StraordinarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StraordinarioPayload>
          }
          aggregate: {
            args: Prisma.StraordinarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStraordinario>
          }
          groupBy: {
            args: Prisma.StraordinarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<StraordinarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.StraordinarioCountArgs<ExtArgs>
            result: $Utils.Optional<StraordinarioCountAggregateOutputType> | number
          }
        }
      }
      InserimentoStraordinario: {
        payload: Prisma.$InserimentoStraordinarioPayload<ExtArgs>
        fields: Prisma.InserimentoStraordinarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InserimentoStraordinarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InserimentoStraordinarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>
          }
          findFirst: {
            args: Prisma.InserimentoStraordinarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InserimentoStraordinarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>
          }
          findMany: {
            args: Prisma.InserimentoStraordinarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>[]
          }
          create: {
            args: Prisma.InserimentoStraordinarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>
          }
          createMany: {
            args: Prisma.InserimentoStraordinarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InserimentoStraordinarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>[]
          }
          delete: {
            args: Prisma.InserimentoStraordinarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>
          }
          update: {
            args: Prisma.InserimentoStraordinarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>
          }
          deleteMany: {
            args: Prisma.InserimentoStraordinarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InserimentoStraordinarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InserimentoStraordinarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>[]
          }
          upsert: {
            args: Prisma.InserimentoStraordinarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InserimentoStraordinarioPayload>
          }
          aggregate: {
            args: Prisma.InserimentoStraordinarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInserimentoStraordinario>
          }
          groupBy: {
            args: Prisma.InserimentoStraordinarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<InserimentoStraordinarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.InserimentoStraordinarioCountArgs<ExtArgs>
            result: $Utils.Optional<InserimentoStraordinarioCountAggregateOutputType> | number
          }
        }
      }
      ImpostazioniUtente: {
        payload: Prisma.$ImpostazioniUtentePayload<ExtArgs>
        fields: Prisma.ImpostazioniUtenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImpostazioniUtenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImpostazioniUtenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>
          }
          findFirst: {
            args: Prisma.ImpostazioniUtenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImpostazioniUtenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>
          }
          findMany: {
            args: Prisma.ImpostazioniUtenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>[]
          }
          create: {
            args: Prisma.ImpostazioniUtenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>
          }
          createMany: {
            args: Prisma.ImpostazioniUtenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImpostazioniUtenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>[]
          }
          delete: {
            args: Prisma.ImpostazioniUtenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>
          }
          update: {
            args: Prisma.ImpostazioniUtenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>
          }
          deleteMany: {
            args: Prisma.ImpostazioniUtenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImpostazioniUtenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImpostazioniUtenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>[]
          }
          upsert: {
            args: Prisma.ImpostazioniUtenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpostazioniUtentePayload>
          }
          aggregate: {
            args: Prisma.ImpostazioniUtenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpostazioniUtente>
          }
          groupBy: {
            args: Prisma.ImpostazioniUtenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImpostazioniUtenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImpostazioniUtenteCountArgs<ExtArgs>
            result: $Utils.Optional<ImpostazioniUtenteCountAggregateOutputType> | number
          }
        }
      }
      SpeseNotti: {
        payload: Prisma.$SpeseNottiPayload<ExtArgs>
        fields: Prisma.SpeseNottiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeseNottiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeseNottiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>
          }
          findFirst: {
            args: Prisma.SpeseNottiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeseNottiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>
          }
          findMany: {
            args: Prisma.SpeseNottiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>[]
          }
          create: {
            args: Prisma.SpeseNottiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>
          }
          createMany: {
            args: Prisma.SpeseNottiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeseNottiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>[]
          }
          delete: {
            args: Prisma.SpeseNottiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>
          }
          update: {
            args: Prisma.SpeseNottiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>
          }
          deleteMany: {
            args: Prisma.SpeseNottiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeseNottiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpeseNottiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>[]
          }
          upsert: {
            args: Prisma.SpeseNottiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeseNottiPayload>
          }
          aggregate: {
            args: Prisma.SpeseNottiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeseNotti>
          }
          groupBy: {
            args: Prisma.SpeseNottiGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeseNottiGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeseNottiCountArgs<ExtArgs>
            result: $Utils.Optional<SpeseNottiCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    cliente?: ClienteOmit
    clienteContatto?: ClienteContattoOmit
    clienteContratto?: ClienteContrattoOmit
    clienteNota?: ClienteNotaOmit
    clienteProdotto?: ClienteProdottoOmit
    operazione?: OperazioneOmit
    operazioneFirma?: OperazioneFirmaOmit
    operazioneDescrizazioni?: OperazioneDescrizazioniOmit
    operazionePutazione?: OperazionePutazioneOmit
    prodotto?: ProdottoOmit
    prodottoVoce?: ProdottoVoceOmit
    contratto?: ContrattoOmit
    pianningTipoIntervento?: PianningTipoInterventoOmit
    pianningEmail?: PianningEmailOmit
    vociIntervento?: VociInterventoOmit
    straordinario?: StraordinarioOmit
    inserimentoStraordinario?: InserimentoStraordinarioOmit
    impostazioniUtente?: ImpostazioniUtenteOmit
    speseNotti?: SpeseNottiOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    pianningEmail: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pianningEmail?: boolean | UserCountOutputTypeCountPianningEmailArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPianningEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PianningEmailWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    operazioni: number
    prodotti: number
    contatti: number
    contratti: number
    note: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operazioni?: boolean | ClienteCountOutputTypeCountOperazioniArgs
    prodotti?: boolean | ClienteCountOutputTypeCountProdottiArgs
    contatti?: boolean | ClienteCountOutputTypeCountContattiArgs
    contratti?: boolean | ClienteCountOutputTypeCountContrattiArgs
    note?: boolean | ClienteCountOutputTypeCountNoteArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountOperazioniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperazioneWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountProdottiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteProdottoWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountContattiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteContattoWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountContrattiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteContrattoWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteNotaWhereInput
  }


  /**
   * Count Type ProdottoCountOutputType
   */

  export type ProdottoCountOutputType = {
    voci: number
  }

  export type ProdottoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voci?: boolean | ProdottoCountOutputTypeCountVociArgs
  }

  // Custom InputTypes
  /**
   * ProdottoCountOutputType without action
   */
  export type ProdottoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoCountOutputType
     */
    select?: ProdottoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProdottoCountOutputType without action
   */
  export type ProdottoCountOutputTypeCountVociArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdottoVoceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    idLogin: number | null
  }

  export type UserSumAggregateOutputType = {
    idLogin: number | null
  }

  export type UserMinAggregateOutputType = {
    idLogin: number | null
    nome: string | null
    cognome: string | null
    email: string | null
    password: string | null
    societa: string | null
    tecnicocod: string | null
    attivo: string | null
    typeutente: string | null
    colore: string | null
  }

  export type UserMaxAggregateOutputType = {
    idLogin: number | null
    nome: string | null
    cognome: string | null
    email: string | null
    password: string | null
    societa: string | null
    tecnicocod: string | null
    attivo: string | null
    typeutente: string | null
    colore: string | null
  }

  export type UserCountAggregateOutputType = {
    idLogin: number
    nome: number
    cognome: number
    email: number
    password: number
    societa: number
    tecnicocod: number
    attivo: number
    typeutente: number
    colore: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    idLogin?: true
  }

  export type UserSumAggregateInputType = {
    idLogin?: true
  }

  export type UserMinAggregateInputType = {
    idLogin?: true
    nome?: true
    cognome?: true
    email?: true
    password?: true
    societa?: true
    tecnicocod?: true
    attivo?: true
    typeutente?: true
    colore?: true
  }

  export type UserMaxAggregateInputType = {
    idLogin?: true
    nome?: true
    cognome?: true
    email?: true
    password?: true
    societa?: true
    tecnicocod?: true
    attivo?: true
    typeutente?: true
    colore?: true
  }

  export type UserCountAggregateInputType = {
    idLogin?: true
    nome?: true
    cognome?: true
    email?: true
    password?: true
    societa?: true
    tecnicocod?: true
    attivo?: true
    typeutente?: true
    colore?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    idLogin: number
    nome: string | null
    cognome: string | null
    email: string
    password: string
    societa: string | null
    tecnicocod: string | null
    attivo: string
    typeutente: string
    colore: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idLogin?: boolean
    nome?: boolean
    cognome?: boolean
    email?: boolean
    password?: boolean
    societa?: boolean
    tecnicocod?: boolean
    attivo?: boolean
    typeutente?: boolean
    colore?: boolean
    pianningEmail?: boolean | User$pianningEmailArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idLogin?: boolean
    nome?: boolean
    cognome?: boolean
    email?: boolean
    password?: boolean
    societa?: boolean
    tecnicocod?: boolean
    attivo?: boolean
    typeutente?: boolean
    colore?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idLogin?: boolean
    nome?: boolean
    cognome?: boolean
    email?: boolean
    password?: boolean
    societa?: boolean
    tecnicocod?: boolean
    attivo?: boolean
    typeutente?: boolean
    colore?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    idLogin?: boolean
    nome?: boolean
    cognome?: boolean
    email?: boolean
    password?: boolean
    societa?: boolean
    tecnicocod?: boolean
    attivo?: boolean
    typeutente?: boolean
    colore?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idLogin" | "nome" | "cognome" | "email" | "password" | "societa" | "tecnicocod" | "attivo" | "typeutente" | "colore", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pianningEmail?: boolean | User$pianningEmailArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      pianningEmail: Prisma.$PianningEmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idLogin: number
      nome: string | null
      cognome: string | null
      email: string
      password: string
      societa: string | null
      tecnicocod: string | null
      attivo: string
      typeutente: string
      colore: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `idLogin`
     * const userWithIdLoginOnly = await prisma.user.findMany({ select: { idLogin: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `idLogin`
     * const userWithIdLoginOnly = await prisma.user.createManyAndReturn({
     *   select: { idLogin: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `idLogin`
     * const userWithIdLoginOnly = await prisma.user.updateManyAndReturn({
     *   select: { idLogin: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pianningEmail<T extends User$pianningEmailArgs<ExtArgs> = {}>(args?: Subset<T, User$pianningEmailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly idLogin: FieldRef<"User", 'Int'>
    readonly nome: FieldRef<"User", 'String'>
    readonly cognome: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly societa: FieldRef<"User", 'String'>
    readonly tecnicocod: FieldRef<"User", 'String'>
    readonly attivo: FieldRef<"User", 'String'>
    readonly typeutente: FieldRef<"User", 'String'>
    readonly colore: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.pianningEmail
   */
  export type User$pianningEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    where?: PianningEmailWhereInput
    orderBy?: PianningEmailOrderByWithRelationInput | PianningEmailOrderByWithRelationInput[]
    cursor?: PianningEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PianningEmailScalarFieldEnum | PianningEmailScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
    idazienda: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
    idazienda: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    codicecliente: string | null
    idazienda: number | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    codicecliente: string | null
    idazienda: number | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    codicecliente: number
    idazienda: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
    idazienda?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
    idazienda?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    codicecliente?: true
    idazienda?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    codicecliente?: true
    idazienda?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    codicecliente?: true
    idazienda?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    codicecliente: string | null
    idazienda: number | null
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codicecliente?: boolean
    idazienda?: boolean
    operazioni?: boolean | Cliente$operazioniArgs<ExtArgs>
    prodotti?: boolean | Cliente$prodottiArgs<ExtArgs>
    contatti?: boolean | Cliente$contattiArgs<ExtArgs>
    contratti?: boolean | Cliente$contrattiArgs<ExtArgs>
    note?: boolean | Cliente$noteArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codicecliente?: boolean
    idazienda?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codicecliente?: boolean
    idazienda?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    codicecliente?: boolean
    idazienda?: boolean
  }

  export type ClienteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codicecliente" | "idazienda", ExtArgs["result"]["cliente"]>
  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operazioni?: boolean | Cliente$operazioniArgs<ExtArgs>
    prodotti?: boolean | Cliente$prodottiArgs<ExtArgs>
    contatti?: boolean | Cliente$contattiArgs<ExtArgs>
    contratti?: boolean | Cliente$contrattiArgs<ExtArgs>
    note?: boolean | Cliente$noteArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClienteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      operazioni: Prisma.$OperazionePayload<ExtArgs>[]
      prodotti: Prisma.$ClienteProdottoPayload<ExtArgs>[]
      contatti: Prisma.$ClienteContattoPayload<ExtArgs>[]
      contratti: Prisma.$ClienteContrattoPayload<ExtArgs>[]
      note: Prisma.$ClienteNotaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codicecliente: string | null
      idazienda: number | null
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes and returns the data updated in the database.
     * @param {ClienteUpdateManyAndReturnArgs} args - Arguments to update many Clientes.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operazioni<T extends Cliente$operazioniArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$operazioniArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prodotti<T extends Cliente$prodottiArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$prodottiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contatti<T extends Cliente$contattiArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$contattiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contratti<T extends Cliente$contrattiArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$contrattiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    note<T extends Cliente$noteArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$noteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
    readonly codicecliente: FieldRef<"Cliente", 'String'>
    readonly idazienda: FieldRef<"Cliente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data?: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
  }

  /**
   * Cliente updateManyAndReturn
   */
  export type ClienteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to update.
     */
    limit?: number
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
    /**
     * Limit how many Clientes to delete.
     */
    limit?: number
  }

  /**
   * Cliente.operazioni
   */
  export type Cliente$operazioniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    where?: OperazioneWhereInput
    orderBy?: OperazioneOrderByWithRelationInput | OperazioneOrderByWithRelationInput[]
    cursor?: OperazioneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperazioneScalarFieldEnum | OperazioneScalarFieldEnum[]
  }

  /**
   * Cliente.prodotti
   */
  export type Cliente$prodottiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    where?: ClienteProdottoWhereInput
    orderBy?: ClienteProdottoOrderByWithRelationInput | ClienteProdottoOrderByWithRelationInput[]
    cursor?: ClienteProdottoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteProdottoScalarFieldEnum | ClienteProdottoScalarFieldEnum[]
  }

  /**
   * Cliente.contatti
   */
  export type Cliente$contattiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    where?: ClienteContattoWhereInput
    orderBy?: ClienteContattoOrderByWithRelationInput | ClienteContattoOrderByWithRelationInput[]
    cursor?: ClienteContattoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteContattoScalarFieldEnum | ClienteContattoScalarFieldEnum[]
  }

  /**
   * Cliente.contratti
   */
  export type Cliente$contrattiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    where?: ClienteContrattoWhereInput
    orderBy?: ClienteContrattoOrderByWithRelationInput | ClienteContrattoOrderByWithRelationInput[]
    cursor?: ClienteContrattoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteContrattoScalarFieldEnum | ClienteContrattoScalarFieldEnum[]
  }

  /**
   * Cliente.note
   */
  export type Cliente$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    where?: ClienteNotaWhereInput
    orderBy?: ClienteNotaOrderByWithRelationInput | ClienteNotaOrderByWithRelationInput[]
    cursor?: ClienteNotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteNotaScalarFieldEnum | ClienteNotaScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model ClienteContatto
   */

  export type AggregateClienteContatto = {
    _count: ClienteContattoCountAggregateOutputType | null
    _avg: ClienteContattoAvgAggregateOutputType | null
    _sum: ClienteContattoSumAggregateOutputType | null
    _min: ClienteContattoMinAggregateOutputType | null
    _max: ClienteContattoMaxAggregateOutputType | null
  }

  export type ClienteContattoAvgAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContattoSumAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContattoMinAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContattoMaxAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContattoCountAggregateOutputType = {
    id: number
    idcliente: number
    _all: number
  }


  export type ClienteContattoAvgAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContattoSumAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContattoMinAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContattoMaxAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContattoCountAggregateInputType = {
    id?: true
    idcliente?: true
    _all?: true
  }

  export type ClienteContattoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteContatto to aggregate.
     */
    where?: ClienteContattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContattos to fetch.
     */
    orderBy?: ClienteContattoOrderByWithRelationInput | ClienteContattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteContattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClienteContattos
    **/
    _count?: true | ClienteContattoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteContattoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteContattoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteContattoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteContattoMaxAggregateInputType
  }

  export type GetClienteContattoAggregateType<T extends ClienteContattoAggregateArgs> = {
        [P in keyof T & keyof AggregateClienteContatto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClienteContatto[P]>
      : GetScalarType<T[P], AggregateClienteContatto[P]>
  }




  export type ClienteContattoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteContattoWhereInput
    orderBy?: ClienteContattoOrderByWithAggregationInput | ClienteContattoOrderByWithAggregationInput[]
    by: ClienteContattoScalarFieldEnum[] | ClienteContattoScalarFieldEnum
    having?: ClienteContattoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteContattoCountAggregateInputType | true
    _avg?: ClienteContattoAvgAggregateInputType
    _sum?: ClienteContattoSumAggregateInputType
    _min?: ClienteContattoMinAggregateInputType
    _max?: ClienteContattoMaxAggregateInputType
  }

  export type ClienteContattoGroupByOutputType = {
    id: number
    idcliente: number
    _count: ClienteContattoCountAggregateOutputType | null
    _avg: ClienteContattoAvgAggregateOutputType | null
    _sum: ClienteContattoSumAggregateOutputType | null
    _min: ClienteContattoMinAggregateOutputType | null
    _max: ClienteContattoMaxAggregateOutputType | null
  }

  type GetClienteContattoGroupByPayload<T extends ClienteContattoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteContattoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteContattoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteContattoGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteContattoGroupByOutputType[P]>
        }
      >
    >


  export type ClienteContattoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteContatto"]>

  export type ClienteContattoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteContatto"]>

  export type ClienteContattoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteContatto"]>

  export type ClienteContattoSelectScalar = {
    id?: boolean
    idcliente?: boolean
  }

  export type ClienteContattoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idcliente", ExtArgs["result"]["clienteContatto"]>
  export type ClienteContattoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteContattoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteContattoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $ClienteContattoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClienteContatto"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idcliente: number
    }, ExtArgs["result"]["clienteContatto"]>
    composites: {}
  }

  type ClienteContattoGetPayload<S extends boolean | null | undefined | ClienteContattoDefaultArgs> = $Result.GetResult<Prisma.$ClienteContattoPayload, S>

  type ClienteContattoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteContattoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteContattoCountAggregateInputType | true
    }

  export interface ClienteContattoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClienteContatto'], meta: { name: 'ClienteContatto' } }
    /**
     * Find zero or one ClienteContatto that matches the filter.
     * @param {ClienteContattoFindUniqueArgs} args - Arguments to find a ClienteContatto
     * @example
     * // Get one ClienteContatto
     * const clienteContatto = await prisma.clienteContatto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteContattoFindUniqueArgs>(args: SelectSubset<T, ClienteContattoFindUniqueArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClienteContatto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteContattoFindUniqueOrThrowArgs} args - Arguments to find a ClienteContatto
     * @example
     * // Get one ClienteContatto
     * const clienteContatto = await prisma.clienteContatto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteContattoFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteContattoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteContatto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoFindFirstArgs} args - Arguments to find a ClienteContatto
     * @example
     * // Get one ClienteContatto
     * const clienteContatto = await prisma.clienteContatto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteContattoFindFirstArgs>(args?: SelectSubset<T, ClienteContattoFindFirstArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteContatto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoFindFirstOrThrowArgs} args - Arguments to find a ClienteContatto
     * @example
     * // Get one ClienteContatto
     * const clienteContatto = await prisma.clienteContatto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteContattoFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteContattoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClienteContattos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClienteContattos
     * const clienteContattos = await prisma.clienteContatto.findMany()
     * 
     * // Get first 10 ClienteContattos
     * const clienteContattos = await prisma.clienteContatto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteContattoWithIdOnly = await prisma.clienteContatto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteContattoFindManyArgs>(args?: SelectSubset<T, ClienteContattoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClienteContatto.
     * @param {ClienteContattoCreateArgs} args - Arguments to create a ClienteContatto.
     * @example
     * // Create one ClienteContatto
     * const ClienteContatto = await prisma.clienteContatto.create({
     *   data: {
     *     // ... data to create a ClienteContatto
     *   }
     * })
     * 
     */
    create<T extends ClienteContattoCreateArgs>(args: SelectSubset<T, ClienteContattoCreateArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClienteContattos.
     * @param {ClienteContattoCreateManyArgs} args - Arguments to create many ClienteContattos.
     * @example
     * // Create many ClienteContattos
     * const clienteContatto = await prisma.clienteContatto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteContattoCreateManyArgs>(args?: SelectSubset<T, ClienteContattoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClienteContattos and returns the data saved in the database.
     * @param {ClienteContattoCreateManyAndReturnArgs} args - Arguments to create many ClienteContattos.
     * @example
     * // Create many ClienteContattos
     * const clienteContatto = await prisma.clienteContatto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClienteContattos and only return the `id`
     * const clienteContattoWithIdOnly = await prisma.clienteContatto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteContattoCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteContattoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClienteContatto.
     * @param {ClienteContattoDeleteArgs} args - Arguments to delete one ClienteContatto.
     * @example
     * // Delete one ClienteContatto
     * const ClienteContatto = await prisma.clienteContatto.delete({
     *   where: {
     *     // ... filter to delete one ClienteContatto
     *   }
     * })
     * 
     */
    delete<T extends ClienteContattoDeleteArgs>(args: SelectSubset<T, ClienteContattoDeleteArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClienteContatto.
     * @param {ClienteContattoUpdateArgs} args - Arguments to update one ClienteContatto.
     * @example
     * // Update one ClienteContatto
     * const clienteContatto = await prisma.clienteContatto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteContattoUpdateArgs>(args: SelectSubset<T, ClienteContattoUpdateArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClienteContattos.
     * @param {ClienteContattoDeleteManyArgs} args - Arguments to filter ClienteContattos to delete.
     * @example
     * // Delete a few ClienteContattos
     * const { count } = await prisma.clienteContatto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteContattoDeleteManyArgs>(args?: SelectSubset<T, ClienteContattoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteContattos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClienteContattos
     * const clienteContatto = await prisma.clienteContatto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteContattoUpdateManyArgs>(args: SelectSubset<T, ClienteContattoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteContattos and returns the data updated in the database.
     * @param {ClienteContattoUpdateManyAndReturnArgs} args - Arguments to update many ClienteContattos.
     * @example
     * // Update many ClienteContattos
     * const clienteContatto = await prisma.clienteContatto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClienteContattos and only return the `id`
     * const clienteContattoWithIdOnly = await prisma.clienteContatto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteContattoUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteContattoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClienteContatto.
     * @param {ClienteContattoUpsertArgs} args - Arguments to update or create a ClienteContatto.
     * @example
     * // Update or create a ClienteContatto
     * const clienteContatto = await prisma.clienteContatto.upsert({
     *   create: {
     *     // ... data to create a ClienteContatto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClienteContatto we want to update
     *   }
     * })
     */
    upsert<T extends ClienteContattoUpsertArgs>(args: SelectSubset<T, ClienteContattoUpsertArgs<ExtArgs>>): Prisma__ClienteContattoClient<$Result.GetResult<Prisma.$ClienteContattoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClienteContattos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoCountArgs} args - Arguments to filter ClienteContattos to count.
     * @example
     * // Count the number of ClienteContattos
     * const count = await prisma.clienteContatto.count({
     *   where: {
     *     // ... the filter for the ClienteContattos we want to count
     *   }
     * })
    **/
    count<T extends ClienteContattoCountArgs>(
      args?: Subset<T, ClienteContattoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteContattoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClienteContatto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteContattoAggregateArgs>(args: Subset<T, ClienteContattoAggregateArgs>): Prisma.PrismaPromise<GetClienteContattoAggregateType<T>>

    /**
     * Group by ClienteContatto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContattoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteContattoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteContattoGroupByArgs['orderBy'] }
        : { orderBy?: ClienteContattoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteContattoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteContattoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClienteContatto model
   */
  readonly fields: ClienteContattoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClienteContatto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteContattoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClienteContatto model
   */
  interface ClienteContattoFieldRefs {
    readonly id: FieldRef<"ClienteContatto", 'Int'>
    readonly idcliente: FieldRef<"ClienteContatto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClienteContatto findUnique
   */
  export type ClienteContattoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContatto to fetch.
     */
    where: ClienteContattoWhereUniqueInput
  }

  /**
   * ClienteContatto findUniqueOrThrow
   */
  export type ClienteContattoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContatto to fetch.
     */
    where: ClienteContattoWhereUniqueInput
  }

  /**
   * ClienteContatto findFirst
   */
  export type ClienteContattoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContatto to fetch.
     */
    where?: ClienteContattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContattos to fetch.
     */
    orderBy?: ClienteContattoOrderByWithRelationInput | ClienteContattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteContattos.
     */
    cursor?: ClienteContattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteContattos.
     */
    distinct?: ClienteContattoScalarFieldEnum | ClienteContattoScalarFieldEnum[]
  }

  /**
   * ClienteContatto findFirstOrThrow
   */
  export type ClienteContattoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContatto to fetch.
     */
    where?: ClienteContattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContattos to fetch.
     */
    orderBy?: ClienteContattoOrderByWithRelationInput | ClienteContattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteContattos.
     */
    cursor?: ClienteContattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteContattos.
     */
    distinct?: ClienteContattoScalarFieldEnum | ClienteContattoScalarFieldEnum[]
  }

  /**
   * ClienteContatto findMany
   */
  export type ClienteContattoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContattos to fetch.
     */
    where?: ClienteContattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContattos to fetch.
     */
    orderBy?: ClienteContattoOrderByWithRelationInput | ClienteContattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClienteContattos.
     */
    cursor?: ClienteContattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContattos.
     */
    skip?: number
    distinct?: ClienteContattoScalarFieldEnum | ClienteContattoScalarFieldEnum[]
  }

  /**
   * ClienteContatto create
   */
  export type ClienteContattoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * The data needed to create a ClienteContatto.
     */
    data: XOR<ClienteContattoCreateInput, ClienteContattoUncheckedCreateInput>
  }

  /**
   * ClienteContatto createMany
   */
  export type ClienteContattoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClienteContattos.
     */
    data: ClienteContattoCreateManyInput | ClienteContattoCreateManyInput[]
  }

  /**
   * ClienteContatto createManyAndReturn
   */
  export type ClienteContattoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * The data used to create many ClienteContattos.
     */
    data: ClienteContattoCreateManyInput | ClienteContattoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteContatto update
   */
  export type ClienteContattoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * The data needed to update a ClienteContatto.
     */
    data: XOR<ClienteContattoUpdateInput, ClienteContattoUncheckedUpdateInput>
    /**
     * Choose, which ClienteContatto to update.
     */
    where: ClienteContattoWhereUniqueInput
  }

  /**
   * ClienteContatto updateMany
   */
  export type ClienteContattoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClienteContattos.
     */
    data: XOR<ClienteContattoUpdateManyMutationInput, ClienteContattoUncheckedUpdateManyInput>
    /**
     * Filter which ClienteContattos to update
     */
    where?: ClienteContattoWhereInput
    /**
     * Limit how many ClienteContattos to update.
     */
    limit?: number
  }

  /**
   * ClienteContatto updateManyAndReturn
   */
  export type ClienteContattoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * The data used to update ClienteContattos.
     */
    data: XOR<ClienteContattoUpdateManyMutationInput, ClienteContattoUncheckedUpdateManyInput>
    /**
     * Filter which ClienteContattos to update
     */
    where?: ClienteContattoWhereInput
    /**
     * Limit how many ClienteContattos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteContatto upsert
   */
  export type ClienteContattoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * The filter to search for the ClienteContatto to update in case it exists.
     */
    where: ClienteContattoWhereUniqueInput
    /**
     * In case the ClienteContatto found by the `where` argument doesn't exist, create a new ClienteContatto with this data.
     */
    create: XOR<ClienteContattoCreateInput, ClienteContattoUncheckedCreateInput>
    /**
     * In case the ClienteContatto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteContattoUpdateInput, ClienteContattoUncheckedUpdateInput>
  }

  /**
   * ClienteContatto delete
   */
  export type ClienteContattoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
    /**
     * Filter which ClienteContatto to delete.
     */
    where: ClienteContattoWhereUniqueInput
  }

  /**
   * ClienteContatto deleteMany
   */
  export type ClienteContattoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteContattos to delete
     */
    where?: ClienteContattoWhereInput
    /**
     * Limit how many ClienteContattos to delete.
     */
    limit?: number
  }

  /**
   * ClienteContatto without action
   */
  export type ClienteContattoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContatto
     */
    select?: ClienteContattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContatto
     */
    omit?: ClienteContattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContattoInclude<ExtArgs> | null
  }


  /**
   * Model ClienteContratto
   */

  export type AggregateClienteContratto = {
    _count: ClienteContrattoCountAggregateOutputType | null
    _avg: ClienteContrattoAvgAggregateOutputType | null
    _sum: ClienteContrattoSumAggregateOutputType | null
    _min: ClienteContrattoMinAggregateOutputType | null
    _max: ClienteContrattoMaxAggregateOutputType | null
  }

  export type ClienteContrattoAvgAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContrattoSumAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContrattoMinAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContrattoMaxAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteContrattoCountAggregateOutputType = {
    id: number
    idcliente: number
    _all: number
  }


  export type ClienteContrattoAvgAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContrattoSumAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContrattoMinAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContrattoMaxAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteContrattoCountAggregateInputType = {
    id?: true
    idcliente?: true
    _all?: true
  }

  export type ClienteContrattoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteContratto to aggregate.
     */
    where?: ClienteContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContrattos to fetch.
     */
    orderBy?: ClienteContrattoOrderByWithRelationInput | ClienteContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContrattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClienteContrattos
    **/
    _count?: true | ClienteContrattoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteContrattoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteContrattoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteContrattoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteContrattoMaxAggregateInputType
  }

  export type GetClienteContrattoAggregateType<T extends ClienteContrattoAggregateArgs> = {
        [P in keyof T & keyof AggregateClienteContratto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClienteContratto[P]>
      : GetScalarType<T[P], AggregateClienteContratto[P]>
  }




  export type ClienteContrattoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteContrattoWhereInput
    orderBy?: ClienteContrattoOrderByWithAggregationInput | ClienteContrattoOrderByWithAggregationInput[]
    by: ClienteContrattoScalarFieldEnum[] | ClienteContrattoScalarFieldEnum
    having?: ClienteContrattoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteContrattoCountAggregateInputType | true
    _avg?: ClienteContrattoAvgAggregateInputType
    _sum?: ClienteContrattoSumAggregateInputType
    _min?: ClienteContrattoMinAggregateInputType
    _max?: ClienteContrattoMaxAggregateInputType
  }

  export type ClienteContrattoGroupByOutputType = {
    id: number
    idcliente: number
    _count: ClienteContrattoCountAggregateOutputType | null
    _avg: ClienteContrattoAvgAggregateOutputType | null
    _sum: ClienteContrattoSumAggregateOutputType | null
    _min: ClienteContrattoMinAggregateOutputType | null
    _max: ClienteContrattoMaxAggregateOutputType | null
  }

  type GetClienteContrattoGroupByPayload<T extends ClienteContrattoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteContrattoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteContrattoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteContrattoGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteContrattoGroupByOutputType[P]>
        }
      >
    >


  export type ClienteContrattoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteContratto"]>

  export type ClienteContrattoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteContratto"]>

  export type ClienteContrattoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteContratto"]>

  export type ClienteContrattoSelectScalar = {
    id?: boolean
    idcliente?: boolean
  }

  export type ClienteContrattoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idcliente", ExtArgs["result"]["clienteContratto"]>
  export type ClienteContrattoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteContrattoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteContrattoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $ClienteContrattoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClienteContratto"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idcliente: number
    }, ExtArgs["result"]["clienteContratto"]>
    composites: {}
  }

  type ClienteContrattoGetPayload<S extends boolean | null | undefined | ClienteContrattoDefaultArgs> = $Result.GetResult<Prisma.$ClienteContrattoPayload, S>

  type ClienteContrattoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteContrattoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteContrattoCountAggregateInputType | true
    }

  export interface ClienteContrattoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClienteContratto'], meta: { name: 'ClienteContratto' } }
    /**
     * Find zero or one ClienteContratto that matches the filter.
     * @param {ClienteContrattoFindUniqueArgs} args - Arguments to find a ClienteContratto
     * @example
     * // Get one ClienteContratto
     * const clienteContratto = await prisma.clienteContratto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteContrattoFindUniqueArgs>(args: SelectSubset<T, ClienteContrattoFindUniqueArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClienteContratto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteContrattoFindUniqueOrThrowArgs} args - Arguments to find a ClienteContratto
     * @example
     * // Get one ClienteContratto
     * const clienteContratto = await prisma.clienteContratto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteContrattoFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteContrattoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteContratto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoFindFirstArgs} args - Arguments to find a ClienteContratto
     * @example
     * // Get one ClienteContratto
     * const clienteContratto = await prisma.clienteContratto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteContrattoFindFirstArgs>(args?: SelectSubset<T, ClienteContrattoFindFirstArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteContratto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoFindFirstOrThrowArgs} args - Arguments to find a ClienteContratto
     * @example
     * // Get one ClienteContratto
     * const clienteContratto = await prisma.clienteContratto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteContrattoFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteContrattoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClienteContrattos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClienteContrattos
     * const clienteContrattos = await prisma.clienteContratto.findMany()
     * 
     * // Get first 10 ClienteContrattos
     * const clienteContrattos = await prisma.clienteContratto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteContrattoWithIdOnly = await prisma.clienteContratto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteContrattoFindManyArgs>(args?: SelectSubset<T, ClienteContrattoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClienteContratto.
     * @param {ClienteContrattoCreateArgs} args - Arguments to create a ClienteContratto.
     * @example
     * // Create one ClienteContratto
     * const ClienteContratto = await prisma.clienteContratto.create({
     *   data: {
     *     // ... data to create a ClienteContratto
     *   }
     * })
     * 
     */
    create<T extends ClienteContrattoCreateArgs>(args: SelectSubset<T, ClienteContrattoCreateArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClienteContrattos.
     * @param {ClienteContrattoCreateManyArgs} args - Arguments to create many ClienteContrattos.
     * @example
     * // Create many ClienteContrattos
     * const clienteContratto = await prisma.clienteContratto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteContrattoCreateManyArgs>(args?: SelectSubset<T, ClienteContrattoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClienteContrattos and returns the data saved in the database.
     * @param {ClienteContrattoCreateManyAndReturnArgs} args - Arguments to create many ClienteContrattos.
     * @example
     * // Create many ClienteContrattos
     * const clienteContratto = await prisma.clienteContratto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClienteContrattos and only return the `id`
     * const clienteContrattoWithIdOnly = await prisma.clienteContratto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteContrattoCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteContrattoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClienteContratto.
     * @param {ClienteContrattoDeleteArgs} args - Arguments to delete one ClienteContratto.
     * @example
     * // Delete one ClienteContratto
     * const ClienteContratto = await prisma.clienteContratto.delete({
     *   where: {
     *     // ... filter to delete one ClienteContratto
     *   }
     * })
     * 
     */
    delete<T extends ClienteContrattoDeleteArgs>(args: SelectSubset<T, ClienteContrattoDeleteArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClienteContratto.
     * @param {ClienteContrattoUpdateArgs} args - Arguments to update one ClienteContratto.
     * @example
     * // Update one ClienteContratto
     * const clienteContratto = await prisma.clienteContratto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteContrattoUpdateArgs>(args: SelectSubset<T, ClienteContrattoUpdateArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClienteContrattos.
     * @param {ClienteContrattoDeleteManyArgs} args - Arguments to filter ClienteContrattos to delete.
     * @example
     * // Delete a few ClienteContrattos
     * const { count } = await prisma.clienteContratto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteContrattoDeleteManyArgs>(args?: SelectSubset<T, ClienteContrattoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteContrattos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClienteContrattos
     * const clienteContratto = await prisma.clienteContratto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteContrattoUpdateManyArgs>(args: SelectSubset<T, ClienteContrattoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteContrattos and returns the data updated in the database.
     * @param {ClienteContrattoUpdateManyAndReturnArgs} args - Arguments to update many ClienteContrattos.
     * @example
     * // Update many ClienteContrattos
     * const clienteContratto = await prisma.clienteContratto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClienteContrattos and only return the `id`
     * const clienteContrattoWithIdOnly = await prisma.clienteContratto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteContrattoUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteContrattoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClienteContratto.
     * @param {ClienteContrattoUpsertArgs} args - Arguments to update or create a ClienteContratto.
     * @example
     * // Update or create a ClienteContratto
     * const clienteContratto = await prisma.clienteContratto.upsert({
     *   create: {
     *     // ... data to create a ClienteContratto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClienteContratto we want to update
     *   }
     * })
     */
    upsert<T extends ClienteContrattoUpsertArgs>(args: SelectSubset<T, ClienteContrattoUpsertArgs<ExtArgs>>): Prisma__ClienteContrattoClient<$Result.GetResult<Prisma.$ClienteContrattoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClienteContrattos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoCountArgs} args - Arguments to filter ClienteContrattos to count.
     * @example
     * // Count the number of ClienteContrattos
     * const count = await prisma.clienteContratto.count({
     *   where: {
     *     // ... the filter for the ClienteContrattos we want to count
     *   }
     * })
    **/
    count<T extends ClienteContrattoCountArgs>(
      args?: Subset<T, ClienteContrattoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteContrattoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClienteContratto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteContrattoAggregateArgs>(args: Subset<T, ClienteContrattoAggregateArgs>): Prisma.PrismaPromise<GetClienteContrattoAggregateType<T>>

    /**
     * Group by ClienteContratto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteContrattoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteContrattoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteContrattoGroupByArgs['orderBy'] }
        : { orderBy?: ClienteContrattoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteContrattoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteContrattoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClienteContratto model
   */
  readonly fields: ClienteContrattoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClienteContratto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteContrattoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClienteContratto model
   */
  interface ClienteContrattoFieldRefs {
    readonly id: FieldRef<"ClienteContratto", 'Int'>
    readonly idcliente: FieldRef<"ClienteContratto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClienteContratto findUnique
   */
  export type ClienteContrattoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContratto to fetch.
     */
    where: ClienteContrattoWhereUniqueInput
  }

  /**
   * ClienteContratto findUniqueOrThrow
   */
  export type ClienteContrattoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContratto to fetch.
     */
    where: ClienteContrattoWhereUniqueInput
  }

  /**
   * ClienteContratto findFirst
   */
  export type ClienteContrattoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContratto to fetch.
     */
    where?: ClienteContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContrattos to fetch.
     */
    orderBy?: ClienteContrattoOrderByWithRelationInput | ClienteContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteContrattos.
     */
    cursor?: ClienteContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContrattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteContrattos.
     */
    distinct?: ClienteContrattoScalarFieldEnum | ClienteContrattoScalarFieldEnum[]
  }

  /**
   * ClienteContratto findFirstOrThrow
   */
  export type ClienteContrattoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContratto to fetch.
     */
    where?: ClienteContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContrattos to fetch.
     */
    orderBy?: ClienteContrattoOrderByWithRelationInput | ClienteContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteContrattos.
     */
    cursor?: ClienteContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContrattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteContrattos.
     */
    distinct?: ClienteContrattoScalarFieldEnum | ClienteContrattoScalarFieldEnum[]
  }

  /**
   * ClienteContratto findMany
   */
  export type ClienteContrattoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteContrattos to fetch.
     */
    where?: ClienteContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteContrattos to fetch.
     */
    orderBy?: ClienteContrattoOrderByWithRelationInput | ClienteContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClienteContrattos.
     */
    cursor?: ClienteContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteContrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteContrattos.
     */
    skip?: number
    distinct?: ClienteContrattoScalarFieldEnum | ClienteContrattoScalarFieldEnum[]
  }

  /**
   * ClienteContratto create
   */
  export type ClienteContrattoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * The data needed to create a ClienteContratto.
     */
    data: XOR<ClienteContrattoCreateInput, ClienteContrattoUncheckedCreateInput>
  }

  /**
   * ClienteContratto createMany
   */
  export type ClienteContrattoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClienteContrattos.
     */
    data: ClienteContrattoCreateManyInput | ClienteContrattoCreateManyInput[]
  }

  /**
   * ClienteContratto createManyAndReturn
   */
  export type ClienteContrattoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * The data used to create many ClienteContrattos.
     */
    data: ClienteContrattoCreateManyInput | ClienteContrattoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteContratto update
   */
  export type ClienteContrattoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * The data needed to update a ClienteContratto.
     */
    data: XOR<ClienteContrattoUpdateInput, ClienteContrattoUncheckedUpdateInput>
    /**
     * Choose, which ClienteContratto to update.
     */
    where: ClienteContrattoWhereUniqueInput
  }

  /**
   * ClienteContratto updateMany
   */
  export type ClienteContrattoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClienteContrattos.
     */
    data: XOR<ClienteContrattoUpdateManyMutationInput, ClienteContrattoUncheckedUpdateManyInput>
    /**
     * Filter which ClienteContrattos to update
     */
    where?: ClienteContrattoWhereInput
    /**
     * Limit how many ClienteContrattos to update.
     */
    limit?: number
  }

  /**
   * ClienteContratto updateManyAndReturn
   */
  export type ClienteContrattoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * The data used to update ClienteContrattos.
     */
    data: XOR<ClienteContrattoUpdateManyMutationInput, ClienteContrattoUncheckedUpdateManyInput>
    /**
     * Filter which ClienteContrattos to update
     */
    where?: ClienteContrattoWhereInput
    /**
     * Limit how many ClienteContrattos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteContratto upsert
   */
  export type ClienteContrattoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * The filter to search for the ClienteContratto to update in case it exists.
     */
    where: ClienteContrattoWhereUniqueInput
    /**
     * In case the ClienteContratto found by the `where` argument doesn't exist, create a new ClienteContratto with this data.
     */
    create: XOR<ClienteContrattoCreateInput, ClienteContrattoUncheckedCreateInput>
    /**
     * In case the ClienteContratto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteContrattoUpdateInput, ClienteContrattoUncheckedUpdateInput>
  }

  /**
   * ClienteContratto delete
   */
  export type ClienteContrattoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
    /**
     * Filter which ClienteContratto to delete.
     */
    where: ClienteContrattoWhereUniqueInput
  }

  /**
   * ClienteContratto deleteMany
   */
  export type ClienteContrattoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteContrattos to delete
     */
    where?: ClienteContrattoWhereInput
    /**
     * Limit how many ClienteContrattos to delete.
     */
    limit?: number
  }

  /**
   * ClienteContratto without action
   */
  export type ClienteContrattoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteContratto
     */
    select?: ClienteContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteContratto
     */
    omit?: ClienteContrattoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteContrattoInclude<ExtArgs> | null
  }


  /**
   * Model ClienteNota
   */

  export type AggregateClienteNota = {
    _count: ClienteNotaCountAggregateOutputType | null
    _avg: ClienteNotaAvgAggregateOutputType | null
    _sum: ClienteNotaSumAggregateOutputType | null
    _min: ClienteNotaMinAggregateOutputType | null
    _max: ClienteNotaMaxAggregateOutputType | null
  }

  export type ClienteNotaAvgAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteNotaSumAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteNotaMinAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteNotaMaxAggregateOutputType = {
    id: number | null
    idcliente: number | null
  }

  export type ClienteNotaCountAggregateOutputType = {
    id: number
    idcliente: number
    _all: number
  }


  export type ClienteNotaAvgAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteNotaSumAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteNotaMinAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteNotaMaxAggregateInputType = {
    id?: true
    idcliente?: true
  }

  export type ClienteNotaCountAggregateInputType = {
    id?: true
    idcliente?: true
    _all?: true
  }

  export type ClienteNotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteNota to aggregate.
     */
    where?: ClienteNotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteNotas to fetch.
     */
    orderBy?: ClienteNotaOrderByWithRelationInput | ClienteNotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteNotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteNotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteNotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClienteNotas
    **/
    _count?: true | ClienteNotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteNotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteNotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteNotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteNotaMaxAggregateInputType
  }

  export type GetClienteNotaAggregateType<T extends ClienteNotaAggregateArgs> = {
        [P in keyof T & keyof AggregateClienteNota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClienteNota[P]>
      : GetScalarType<T[P], AggregateClienteNota[P]>
  }




  export type ClienteNotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteNotaWhereInput
    orderBy?: ClienteNotaOrderByWithAggregationInput | ClienteNotaOrderByWithAggregationInput[]
    by: ClienteNotaScalarFieldEnum[] | ClienteNotaScalarFieldEnum
    having?: ClienteNotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteNotaCountAggregateInputType | true
    _avg?: ClienteNotaAvgAggregateInputType
    _sum?: ClienteNotaSumAggregateInputType
    _min?: ClienteNotaMinAggregateInputType
    _max?: ClienteNotaMaxAggregateInputType
  }

  export type ClienteNotaGroupByOutputType = {
    id: number
    idcliente: number
    _count: ClienteNotaCountAggregateOutputType | null
    _avg: ClienteNotaAvgAggregateOutputType | null
    _sum: ClienteNotaSumAggregateOutputType | null
    _min: ClienteNotaMinAggregateOutputType | null
    _max: ClienteNotaMaxAggregateOutputType | null
  }

  type GetClienteNotaGroupByPayload<T extends ClienteNotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteNotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteNotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteNotaGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteNotaGroupByOutputType[P]>
        }
      >
    >


  export type ClienteNotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteNota"]>

  export type ClienteNotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteNota"]>

  export type ClienteNotaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteNota"]>

  export type ClienteNotaSelectScalar = {
    id?: boolean
    idcliente?: boolean
  }

  export type ClienteNotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idcliente", ExtArgs["result"]["clienteNota"]>
  export type ClienteNotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteNotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteNotaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $ClienteNotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClienteNota"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idcliente: number
    }, ExtArgs["result"]["clienteNota"]>
    composites: {}
  }

  type ClienteNotaGetPayload<S extends boolean | null | undefined | ClienteNotaDefaultArgs> = $Result.GetResult<Prisma.$ClienteNotaPayload, S>

  type ClienteNotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteNotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteNotaCountAggregateInputType | true
    }

  export interface ClienteNotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClienteNota'], meta: { name: 'ClienteNota' } }
    /**
     * Find zero or one ClienteNota that matches the filter.
     * @param {ClienteNotaFindUniqueArgs} args - Arguments to find a ClienteNota
     * @example
     * // Get one ClienteNota
     * const clienteNota = await prisma.clienteNota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteNotaFindUniqueArgs>(args: SelectSubset<T, ClienteNotaFindUniqueArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClienteNota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteNotaFindUniqueOrThrowArgs} args - Arguments to find a ClienteNota
     * @example
     * // Get one ClienteNota
     * const clienteNota = await prisma.clienteNota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteNotaFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteNotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteNota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaFindFirstArgs} args - Arguments to find a ClienteNota
     * @example
     * // Get one ClienteNota
     * const clienteNota = await prisma.clienteNota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteNotaFindFirstArgs>(args?: SelectSubset<T, ClienteNotaFindFirstArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteNota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaFindFirstOrThrowArgs} args - Arguments to find a ClienteNota
     * @example
     * // Get one ClienteNota
     * const clienteNota = await prisma.clienteNota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteNotaFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteNotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClienteNotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClienteNotas
     * const clienteNotas = await prisma.clienteNota.findMany()
     * 
     * // Get first 10 ClienteNotas
     * const clienteNotas = await prisma.clienteNota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteNotaWithIdOnly = await prisma.clienteNota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteNotaFindManyArgs>(args?: SelectSubset<T, ClienteNotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClienteNota.
     * @param {ClienteNotaCreateArgs} args - Arguments to create a ClienteNota.
     * @example
     * // Create one ClienteNota
     * const ClienteNota = await prisma.clienteNota.create({
     *   data: {
     *     // ... data to create a ClienteNota
     *   }
     * })
     * 
     */
    create<T extends ClienteNotaCreateArgs>(args: SelectSubset<T, ClienteNotaCreateArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClienteNotas.
     * @param {ClienteNotaCreateManyArgs} args - Arguments to create many ClienteNotas.
     * @example
     * // Create many ClienteNotas
     * const clienteNota = await prisma.clienteNota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteNotaCreateManyArgs>(args?: SelectSubset<T, ClienteNotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClienteNotas and returns the data saved in the database.
     * @param {ClienteNotaCreateManyAndReturnArgs} args - Arguments to create many ClienteNotas.
     * @example
     * // Create many ClienteNotas
     * const clienteNota = await prisma.clienteNota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClienteNotas and only return the `id`
     * const clienteNotaWithIdOnly = await prisma.clienteNota.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteNotaCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteNotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClienteNota.
     * @param {ClienteNotaDeleteArgs} args - Arguments to delete one ClienteNota.
     * @example
     * // Delete one ClienteNota
     * const ClienteNota = await prisma.clienteNota.delete({
     *   where: {
     *     // ... filter to delete one ClienteNota
     *   }
     * })
     * 
     */
    delete<T extends ClienteNotaDeleteArgs>(args: SelectSubset<T, ClienteNotaDeleteArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClienteNota.
     * @param {ClienteNotaUpdateArgs} args - Arguments to update one ClienteNota.
     * @example
     * // Update one ClienteNota
     * const clienteNota = await prisma.clienteNota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteNotaUpdateArgs>(args: SelectSubset<T, ClienteNotaUpdateArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClienteNotas.
     * @param {ClienteNotaDeleteManyArgs} args - Arguments to filter ClienteNotas to delete.
     * @example
     * // Delete a few ClienteNotas
     * const { count } = await prisma.clienteNota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteNotaDeleteManyArgs>(args?: SelectSubset<T, ClienteNotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteNotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClienteNotas
     * const clienteNota = await prisma.clienteNota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteNotaUpdateManyArgs>(args: SelectSubset<T, ClienteNotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteNotas and returns the data updated in the database.
     * @param {ClienteNotaUpdateManyAndReturnArgs} args - Arguments to update many ClienteNotas.
     * @example
     * // Update many ClienteNotas
     * const clienteNota = await prisma.clienteNota.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClienteNotas and only return the `id`
     * const clienteNotaWithIdOnly = await prisma.clienteNota.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteNotaUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteNotaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClienteNota.
     * @param {ClienteNotaUpsertArgs} args - Arguments to update or create a ClienteNota.
     * @example
     * // Update or create a ClienteNota
     * const clienteNota = await prisma.clienteNota.upsert({
     *   create: {
     *     // ... data to create a ClienteNota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClienteNota we want to update
     *   }
     * })
     */
    upsert<T extends ClienteNotaUpsertArgs>(args: SelectSubset<T, ClienteNotaUpsertArgs<ExtArgs>>): Prisma__ClienteNotaClient<$Result.GetResult<Prisma.$ClienteNotaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClienteNotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaCountArgs} args - Arguments to filter ClienteNotas to count.
     * @example
     * // Count the number of ClienteNotas
     * const count = await prisma.clienteNota.count({
     *   where: {
     *     // ... the filter for the ClienteNotas we want to count
     *   }
     * })
    **/
    count<T extends ClienteNotaCountArgs>(
      args?: Subset<T, ClienteNotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteNotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClienteNota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteNotaAggregateArgs>(args: Subset<T, ClienteNotaAggregateArgs>): Prisma.PrismaPromise<GetClienteNotaAggregateType<T>>

    /**
     * Group by ClienteNota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteNotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteNotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteNotaGroupByArgs['orderBy'] }
        : { orderBy?: ClienteNotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteNotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteNotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClienteNota model
   */
  readonly fields: ClienteNotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClienteNota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteNotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClienteNota model
   */
  interface ClienteNotaFieldRefs {
    readonly id: FieldRef<"ClienteNota", 'Int'>
    readonly idcliente: FieldRef<"ClienteNota", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClienteNota findUnique
   */
  export type ClienteNotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * Filter, which ClienteNota to fetch.
     */
    where: ClienteNotaWhereUniqueInput
  }

  /**
   * ClienteNota findUniqueOrThrow
   */
  export type ClienteNotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * Filter, which ClienteNota to fetch.
     */
    where: ClienteNotaWhereUniqueInput
  }

  /**
   * ClienteNota findFirst
   */
  export type ClienteNotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * Filter, which ClienteNota to fetch.
     */
    where?: ClienteNotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteNotas to fetch.
     */
    orderBy?: ClienteNotaOrderByWithRelationInput | ClienteNotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteNotas.
     */
    cursor?: ClienteNotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteNotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteNotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteNotas.
     */
    distinct?: ClienteNotaScalarFieldEnum | ClienteNotaScalarFieldEnum[]
  }

  /**
   * ClienteNota findFirstOrThrow
   */
  export type ClienteNotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * Filter, which ClienteNota to fetch.
     */
    where?: ClienteNotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteNotas to fetch.
     */
    orderBy?: ClienteNotaOrderByWithRelationInput | ClienteNotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteNotas.
     */
    cursor?: ClienteNotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteNotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteNotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteNotas.
     */
    distinct?: ClienteNotaScalarFieldEnum | ClienteNotaScalarFieldEnum[]
  }

  /**
   * ClienteNota findMany
   */
  export type ClienteNotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * Filter, which ClienteNotas to fetch.
     */
    where?: ClienteNotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteNotas to fetch.
     */
    orderBy?: ClienteNotaOrderByWithRelationInput | ClienteNotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClienteNotas.
     */
    cursor?: ClienteNotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteNotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteNotas.
     */
    skip?: number
    distinct?: ClienteNotaScalarFieldEnum | ClienteNotaScalarFieldEnum[]
  }

  /**
   * ClienteNota create
   */
  export type ClienteNotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * The data needed to create a ClienteNota.
     */
    data: XOR<ClienteNotaCreateInput, ClienteNotaUncheckedCreateInput>
  }

  /**
   * ClienteNota createMany
   */
  export type ClienteNotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClienteNotas.
     */
    data: ClienteNotaCreateManyInput | ClienteNotaCreateManyInput[]
  }

  /**
   * ClienteNota createManyAndReturn
   */
  export type ClienteNotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * The data used to create many ClienteNotas.
     */
    data: ClienteNotaCreateManyInput | ClienteNotaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteNota update
   */
  export type ClienteNotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * The data needed to update a ClienteNota.
     */
    data: XOR<ClienteNotaUpdateInput, ClienteNotaUncheckedUpdateInput>
    /**
     * Choose, which ClienteNota to update.
     */
    where: ClienteNotaWhereUniqueInput
  }

  /**
   * ClienteNota updateMany
   */
  export type ClienteNotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClienteNotas.
     */
    data: XOR<ClienteNotaUpdateManyMutationInput, ClienteNotaUncheckedUpdateManyInput>
    /**
     * Filter which ClienteNotas to update
     */
    where?: ClienteNotaWhereInput
    /**
     * Limit how many ClienteNotas to update.
     */
    limit?: number
  }

  /**
   * ClienteNota updateManyAndReturn
   */
  export type ClienteNotaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * The data used to update ClienteNotas.
     */
    data: XOR<ClienteNotaUpdateManyMutationInput, ClienteNotaUncheckedUpdateManyInput>
    /**
     * Filter which ClienteNotas to update
     */
    where?: ClienteNotaWhereInput
    /**
     * Limit how many ClienteNotas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteNota upsert
   */
  export type ClienteNotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * The filter to search for the ClienteNota to update in case it exists.
     */
    where: ClienteNotaWhereUniqueInput
    /**
     * In case the ClienteNota found by the `where` argument doesn't exist, create a new ClienteNota with this data.
     */
    create: XOR<ClienteNotaCreateInput, ClienteNotaUncheckedCreateInput>
    /**
     * In case the ClienteNota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteNotaUpdateInput, ClienteNotaUncheckedUpdateInput>
  }

  /**
   * ClienteNota delete
   */
  export type ClienteNotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
    /**
     * Filter which ClienteNota to delete.
     */
    where: ClienteNotaWhereUniqueInput
  }

  /**
   * ClienteNota deleteMany
   */
  export type ClienteNotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteNotas to delete
     */
    where?: ClienteNotaWhereInput
    /**
     * Limit how many ClienteNotas to delete.
     */
    limit?: number
  }

  /**
   * ClienteNota without action
   */
  export type ClienteNotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteNota
     */
    select?: ClienteNotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteNota
     */
    omit?: ClienteNotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteNotaInclude<ExtArgs> | null
  }


  /**
   * Model ClienteProdotto
   */

  export type AggregateClienteProdotto = {
    _count: ClienteProdottoCountAggregateOutputType | null
    _avg: ClienteProdottoAvgAggregateOutputType | null
    _sum: ClienteProdottoSumAggregateOutputType | null
    _min: ClienteProdottoMinAggregateOutputType | null
    _max: ClienteProdottoMaxAggregateOutputType | null
  }

  export type ClienteProdottoAvgAggregateOutputType = {
    id: number | null
    idcliente: number | null
    idprodotto: number | null
  }

  export type ClienteProdottoSumAggregateOutputType = {
    id: number | null
    idcliente: number | null
    idprodotto: number | null
  }

  export type ClienteProdottoMinAggregateOutputType = {
    id: number | null
    idcliente: number | null
    idprodotto: number | null
  }

  export type ClienteProdottoMaxAggregateOutputType = {
    id: number | null
    idcliente: number | null
    idprodotto: number | null
  }

  export type ClienteProdottoCountAggregateOutputType = {
    id: number
    idcliente: number
    idprodotto: number
    _all: number
  }


  export type ClienteProdottoAvgAggregateInputType = {
    id?: true
    idcliente?: true
    idprodotto?: true
  }

  export type ClienteProdottoSumAggregateInputType = {
    id?: true
    idcliente?: true
    idprodotto?: true
  }

  export type ClienteProdottoMinAggregateInputType = {
    id?: true
    idcliente?: true
    idprodotto?: true
  }

  export type ClienteProdottoMaxAggregateInputType = {
    id?: true
    idcliente?: true
    idprodotto?: true
  }

  export type ClienteProdottoCountAggregateInputType = {
    id?: true
    idcliente?: true
    idprodotto?: true
    _all?: true
  }

  export type ClienteProdottoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteProdotto to aggregate.
     */
    where?: ClienteProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteProdottos to fetch.
     */
    orderBy?: ClienteProdottoOrderByWithRelationInput | ClienteProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteProdottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteProdottos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClienteProdottos
    **/
    _count?: true | ClienteProdottoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteProdottoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteProdottoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteProdottoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteProdottoMaxAggregateInputType
  }

  export type GetClienteProdottoAggregateType<T extends ClienteProdottoAggregateArgs> = {
        [P in keyof T & keyof AggregateClienteProdotto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClienteProdotto[P]>
      : GetScalarType<T[P], AggregateClienteProdotto[P]>
  }




  export type ClienteProdottoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteProdottoWhereInput
    orderBy?: ClienteProdottoOrderByWithAggregationInput | ClienteProdottoOrderByWithAggregationInput[]
    by: ClienteProdottoScalarFieldEnum[] | ClienteProdottoScalarFieldEnum
    having?: ClienteProdottoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteProdottoCountAggregateInputType | true
    _avg?: ClienteProdottoAvgAggregateInputType
    _sum?: ClienteProdottoSumAggregateInputType
    _min?: ClienteProdottoMinAggregateInputType
    _max?: ClienteProdottoMaxAggregateInputType
  }

  export type ClienteProdottoGroupByOutputType = {
    id: number
    idcliente: number
    idprodotto: number | null
    _count: ClienteProdottoCountAggregateOutputType | null
    _avg: ClienteProdottoAvgAggregateOutputType | null
    _sum: ClienteProdottoSumAggregateOutputType | null
    _min: ClienteProdottoMinAggregateOutputType | null
    _max: ClienteProdottoMaxAggregateOutputType | null
  }

  type GetClienteProdottoGroupByPayload<T extends ClienteProdottoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteProdottoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteProdottoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteProdottoGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteProdottoGroupByOutputType[P]>
        }
      >
    >


  export type ClienteProdottoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    idprodotto?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteProdotto"]>

  export type ClienteProdottoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    idprodotto?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteProdotto"]>

  export type ClienteProdottoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idcliente?: boolean
    idprodotto?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clienteProdotto"]>

  export type ClienteProdottoSelectScalar = {
    id?: boolean
    idcliente?: boolean
    idprodotto?: boolean
  }

  export type ClienteProdottoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idcliente" | "idprodotto", ExtArgs["result"]["clienteProdotto"]>
  export type ClienteProdottoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteProdottoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }
  export type ClienteProdottoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $ClienteProdottoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClienteProdotto"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idcliente: number
      idprodotto: number | null
    }, ExtArgs["result"]["clienteProdotto"]>
    composites: {}
  }

  type ClienteProdottoGetPayload<S extends boolean | null | undefined | ClienteProdottoDefaultArgs> = $Result.GetResult<Prisma.$ClienteProdottoPayload, S>

  type ClienteProdottoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClienteProdottoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClienteProdottoCountAggregateInputType | true
    }

  export interface ClienteProdottoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClienteProdotto'], meta: { name: 'ClienteProdotto' } }
    /**
     * Find zero or one ClienteProdotto that matches the filter.
     * @param {ClienteProdottoFindUniqueArgs} args - Arguments to find a ClienteProdotto
     * @example
     * // Get one ClienteProdotto
     * const clienteProdotto = await prisma.clienteProdotto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteProdottoFindUniqueArgs>(args: SelectSubset<T, ClienteProdottoFindUniqueArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClienteProdotto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClienteProdottoFindUniqueOrThrowArgs} args - Arguments to find a ClienteProdotto
     * @example
     * // Get one ClienteProdotto
     * const clienteProdotto = await prisma.clienteProdotto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteProdottoFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteProdottoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteProdotto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoFindFirstArgs} args - Arguments to find a ClienteProdotto
     * @example
     * // Get one ClienteProdotto
     * const clienteProdotto = await prisma.clienteProdotto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteProdottoFindFirstArgs>(args?: SelectSubset<T, ClienteProdottoFindFirstArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClienteProdotto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoFindFirstOrThrowArgs} args - Arguments to find a ClienteProdotto
     * @example
     * // Get one ClienteProdotto
     * const clienteProdotto = await prisma.clienteProdotto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteProdottoFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteProdottoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClienteProdottos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClienteProdottos
     * const clienteProdottos = await prisma.clienteProdotto.findMany()
     * 
     * // Get first 10 ClienteProdottos
     * const clienteProdottos = await prisma.clienteProdotto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteProdottoWithIdOnly = await prisma.clienteProdotto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteProdottoFindManyArgs>(args?: SelectSubset<T, ClienteProdottoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClienteProdotto.
     * @param {ClienteProdottoCreateArgs} args - Arguments to create a ClienteProdotto.
     * @example
     * // Create one ClienteProdotto
     * const ClienteProdotto = await prisma.clienteProdotto.create({
     *   data: {
     *     // ... data to create a ClienteProdotto
     *   }
     * })
     * 
     */
    create<T extends ClienteProdottoCreateArgs>(args: SelectSubset<T, ClienteProdottoCreateArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClienteProdottos.
     * @param {ClienteProdottoCreateManyArgs} args - Arguments to create many ClienteProdottos.
     * @example
     * // Create many ClienteProdottos
     * const clienteProdotto = await prisma.clienteProdotto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteProdottoCreateManyArgs>(args?: SelectSubset<T, ClienteProdottoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClienteProdottos and returns the data saved in the database.
     * @param {ClienteProdottoCreateManyAndReturnArgs} args - Arguments to create many ClienteProdottos.
     * @example
     * // Create many ClienteProdottos
     * const clienteProdotto = await prisma.clienteProdotto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClienteProdottos and only return the `id`
     * const clienteProdottoWithIdOnly = await prisma.clienteProdotto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteProdottoCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteProdottoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClienteProdotto.
     * @param {ClienteProdottoDeleteArgs} args - Arguments to delete one ClienteProdotto.
     * @example
     * // Delete one ClienteProdotto
     * const ClienteProdotto = await prisma.clienteProdotto.delete({
     *   where: {
     *     // ... filter to delete one ClienteProdotto
     *   }
     * })
     * 
     */
    delete<T extends ClienteProdottoDeleteArgs>(args: SelectSubset<T, ClienteProdottoDeleteArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClienteProdotto.
     * @param {ClienteProdottoUpdateArgs} args - Arguments to update one ClienteProdotto.
     * @example
     * // Update one ClienteProdotto
     * const clienteProdotto = await prisma.clienteProdotto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteProdottoUpdateArgs>(args: SelectSubset<T, ClienteProdottoUpdateArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClienteProdottos.
     * @param {ClienteProdottoDeleteManyArgs} args - Arguments to filter ClienteProdottos to delete.
     * @example
     * // Delete a few ClienteProdottos
     * const { count } = await prisma.clienteProdotto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteProdottoDeleteManyArgs>(args?: SelectSubset<T, ClienteProdottoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteProdottos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClienteProdottos
     * const clienteProdotto = await prisma.clienteProdotto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteProdottoUpdateManyArgs>(args: SelectSubset<T, ClienteProdottoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClienteProdottos and returns the data updated in the database.
     * @param {ClienteProdottoUpdateManyAndReturnArgs} args - Arguments to update many ClienteProdottos.
     * @example
     * // Update many ClienteProdottos
     * const clienteProdotto = await prisma.clienteProdotto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClienteProdottos and only return the `id`
     * const clienteProdottoWithIdOnly = await prisma.clienteProdotto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClienteProdottoUpdateManyAndReturnArgs>(args: SelectSubset<T, ClienteProdottoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClienteProdotto.
     * @param {ClienteProdottoUpsertArgs} args - Arguments to update or create a ClienteProdotto.
     * @example
     * // Update or create a ClienteProdotto
     * const clienteProdotto = await prisma.clienteProdotto.upsert({
     *   create: {
     *     // ... data to create a ClienteProdotto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClienteProdotto we want to update
     *   }
     * })
     */
    upsert<T extends ClienteProdottoUpsertArgs>(args: SelectSubset<T, ClienteProdottoUpsertArgs<ExtArgs>>): Prisma__ClienteProdottoClient<$Result.GetResult<Prisma.$ClienteProdottoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClienteProdottos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoCountArgs} args - Arguments to filter ClienteProdottos to count.
     * @example
     * // Count the number of ClienteProdottos
     * const count = await prisma.clienteProdotto.count({
     *   where: {
     *     // ... the filter for the ClienteProdottos we want to count
     *   }
     * })
    **/
    count<T extends ClienteProdottoCountArgs>(
      args?: Subset<T, ClienteProdottoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteProdottoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClienteProdotto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteProdottoAggregateArgs>(args: Subset<T, ClienteProdottoAggregateArgs>): Prisma.PrismaPromise<GetClienteProdottoAggregateType<T>>

    /**
     * Group by ClienteProdotto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteProdottoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteProdottoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteProdottoGroupByArgs['orderBy'] }
        : { orderBy?: ClienteProdottoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteProdottoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteProdottoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClienteProdotto model
   */
  readonly fields: ClienteProdottoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClienteProdotto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteProdottoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClienteProdotto model
   */
  interface ClienteProdottoFieldRefs {
    readonly id: FieldRef<"ClienteProdotto", 'Int'>
    readonly idcliente: FieldRef<"ClienteProdotto", 'Int'>
    readonly idprodotto: FieldRef<"ClienteProdotto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClienteProdotto findUnique
   */
  export type ClienteProdottoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteProdotto to fetch.
     */
    where: ClienteProdottoWhereUniqueInput
  }

  /**
   * ClienteProdotto findUniqueOrThrow
   */
  export type ClienteProdottoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteProdotto to fetch.
     */
    where: ClienteProdottoWhereUniqueInput
  }

  /**
   * ClienteProdotto findFirst
   */
  export type ClienteProdottoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteProdotto to fetch.
     */
    where?: ClienteProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteProdottos to fetch.
     */
    orderBy?: ClienteProdottoOrderByWithRelationInput | ClienteProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteProdottos.
     */
    cursor?: ClienteProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteProdottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteProdottos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteProdottos.
     */
    distinct?: ClienteProdottoScalarFieldEnum | ClienteProdottoScalarFieldEnum[]
  }

  /**
   * ClienteProdotto findFirstOrThrow
   */
  export type ClienteProdottoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteProdotto to fetch.
     */
    where?: ClienteProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteProdottos to fetch.
     */
    orderBy?: ClienteProdottoOrderByWithRelationInput | ClienteProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClienteProdottos.
     */
    cursor?: ClienteProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteProdottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteProdottos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClienteProdottos.
     */
    distinct?: ClienteProdottoScalarFieldEnum | ClienteProdottoScalarFieldEnum[]
  }

  /**
   * ClienteProdotto findMany
   */
  export type ClienteProdottoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * Filter, which ClienteProdottos to fetch.
     */
    where?: ClienteProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClienteProdottos to fetch.
     */
    orderBy?: ClienteProdottoOrderByWithRelationInput | ClienteProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClienteProdottos.
     */
    cursor?: ClienteProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClienteProdottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClienteProdottos.
     */
    skip?: number
    distinct?: ClienteProdottoScalarFieldEnum | ClienteProdottoScalarFieldEnum[]
  }

  /**
   * ClienteProdotto create
   */
  export type ClienteProdottoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * The data needed to create a ClienteProdotto.
     */
    data: XOR<ClienteProdottoCreateInput, ClienteProdottoUncheckedCreateInput>
  }

  /**
   * ClienteProdotto createMany
   */
  export type ClienteProdottoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClienteProdottos.
     */
    data: ClienteProdottoCreateManyInput | ClienteProdottoCreateManyInput[]
  }

  /**
   * ClienteProdotto createManyAndReturn
   */
  export type ClienteProdottoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * The data used to create many ClienteProdottos.
     */
    data: ClienteProdottoCreateManyInput | ClienteProdottoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteProdotto update
   */
  export type ClienteProdottoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * The data needed to update a ClienteProdotto.
     */
    data: XOR<ClienteProdottoUpdateInput, ClienteProdottoUncheckedUpdateInput>
    /**
     * Choose, which ClienteProdotto to update.
     */
    where: ClienteProdottoWhereUniqueInput
  }

  /**
   * ClienteProdotto updateMany
   */
  export type ClienteProdottoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClienteProdottos.
     */
    data: XOR<ClienteProdottoUpdateManyMutationInput, ClienteProdottoUncheckedUpdateManyInput>
    /**
     * Filter which ClienteProdottos to update
     */
    where?: ClienteProdottoWhereInput
    /**
     * Limit how many ClienteProdottos to update.
     */
    limit?: number
  }

  /**
   * ClienteProdotto updateManyAndReturn
   */
  export type ClienteProdottoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * The data used to update ClienteProdottos.
     */
    data: XOR<ClienteProdottoUpdateManyMutationInput, ClienteProdottoUncheckedUpdateManyInput>
    /**
     * Filter which ClienteProdottos to update
     */
    where?: ClienteProdottoWhereInput
    /**
     * Limit how many ClienteProdottos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClienteProdotto upsert
   */
  export type ClienteProdottoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * The filter to search for the ClienteProdotto to update in case it exists.
     */
    where: ClienteProdottoWhereUniqueInput
    /**
     * In case the ClienteProdotto found by the `where` argument doesn't exist, create a new ClienteProdotto with this data.
     */
    create: XOR<ClienteProdottoCreateInput, ClienteProdottoUncheckedCreateInput>
    /**
     * In case the ClienteProdotto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteProdottoUpdateInput, ClienteProdottoUncheckedUpdateInput>
  }

  /**
   * ClienteProdotto delete
   */
  export type ClienteProdottoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
    /**
     * Filter which ClienteProdotto to delete.
     */
    where: ClienteProdottoWhereUniqueInput
  }

  /**
   * ClienteProdotto deleteMany
   */
  export type ClienteProdottoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClienteProdottos to delete
     */
    where?: ClienteProdottoWhereInput
    /**
     * Limit how many ClienteProdottos to delete.
     */
    limit?: number
  }

  /**
   * ClienteProdotto without action
   */
  export type ClienteProdottoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteProdotto
     */
    select?: ClienteProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClienteProdotto
     */
    omit?: ClienteProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteProdottoInclude<ExtArgs> | null
  }


  /**
   * Model Operazione
   */

  export type AggregateOperazione = {
    _count: OperazioneCountAggregateOutputType | null
    _avg: OperazioneAvgAggregateOutputType | null
    _sum: OperazioneSumAggregateOutputType | null
    _min: OperazioneMinAggregateOutputType | null
    _max: OperazioneMaxAggregateOutputType | null
  }

  export type OperazioneAvgAggregateOutputType = {
    id: number | null
    anno: number | null
    idazienda: number | null
    idcliente: number | null
    idintervento: number | null
    idprodotto: number | null
    orainizio: number | null
    orafine: number | null
    totaleore: number | null
    stato: number | null
    idprodottocliente: number | null
    faseoperazione: number | null
  }

  export type OperazioneSumAggregateOutputType = {
    id: number | null
    anno: number | null
    idazienda: number | null
    idcliente: number | null
    idintervento: number | null
    idprodotto: number | null
    orainizio: number | null
    orafine: number | null
    totaleore: number | null
    stato: number | null
    idprodottocliente: number | null
    faseoperazione: number | null
  }

  export type OperazioneMinAggregateOutputType = {
    id: number | null
    datacreazione: Date | null
    tipo: string | null
    codice: string | null
    anno: number | null
    idazienda: number | null
    idcliente: number | null
    idintervento: number | null
    operatore: string | null
    idprodotto: number | null
    dataesecuzione: Date | null
    orainizio: number | null
    orafine: number | null
    totaleore: number | null
    osservazioni: string | null
    codicecliente: string | null
    stato: number | null
    eliminato: string | null
    idprodottocliente: number | null
    faseoperazione: number | null
  }

  export type OperazioneMaxAggregateOutputType = {
    id: number | null
    datacreazione: Date | null
    tipo: string | null
    codice: string | null
    anno: number | null
    idazienda: number | null
    idcliente: number | null
    idintervento: number | null
    operatore: string | null
    idprodotto: number | null
    dataesecuzione: Date | null
    orainizio: number | null
    orafine: number | null
    totaleore: number | null
    osservazioni: string | null
    codicecliente: string | null
    stato: number | null
    eliminato: string | null
    idprodottocliente: number | null
    faseoperazione: number | null
  }

  export type OperazioneCountAggregateOutputType = {
    id: number
    datacreazione: number
    tipo: number
    codice: number
    anno: number
    idazienda: number
    idcliente: number
    idintervento: number
    operatore: number
    idprodotto: number
    dataesecuzione: number
    orainizio: number
    orafine: number
    totaleore: number
    osservazioni: number
    codicecliente: number
    stato: number
    eliminato: number
    idprodottocliente: number
    faseoperazione: number
    _all: number
  }


  export type OperazioneAvgAggregateInputType = {
    id?: true
    anno?: true
    idazienda?: true
    idcliente?: true
    idintervento?: true
    idprodotto?: true
    orainizio?: true
    orafine?: true
    totaleore?: true
    stato?: true
    idprodottocliente?: true
    faseoperazione?: true
  }

  export type OperazioneSumAggregateInputType = {
    id?: true
    anno?: true
    idazienda?: true
    idcliente?: true
    idintervento?: true
    idprodotto?: true
    orainizio?: true
    orafine?: true
    totaleore?: true
    stato?: true
    idprodottocliente?: true
    faseoperazione?: true
  }

  export type OperazioneMinAggregateInputType = {
    id?: true
    datacreazione?: true
    tipo?: true
    codice?: true
    anno?: true
    idazienda?: true
    idcliente?: true
    idintervento?: true
    operatore?: true
    idprodotto?: true
    dataesecuzione?: true
    orainizio?: true
    orafine?: true
    totaleore?: true
    osservazioni?: true
    codicecliente?: true
    stato?: true
    eliminato?: true
    idprodottocliente?: true
    faseoperazione?: true
  }

  export type OperazioneMaxAggregateInputType = {
    id?: true
    datacreazione?: true
    tipo?: true
    codice?: true
    anno?: true
    idazienda?: true
    idcliente?: true
    idintervento?: true
    operatore?: true
    idprodotto?: true
    dataesecuzione?: true
    orainizio?: true
    orafine?: true
    totaleore?: true
    osservazioni?: true
    codicecliente?: true
    stato?: true
    eliminato?: true
    idprodottocliente?: true
    faseoperazione?: true
  }

  export type OperazioneCountAggregateInputType = {
    id?: true
    datacreazione?: true
    tipo?: true
    codice?: true
    anno?: true
    idazienda?: true
    idcliente?: true
    idintervento?: true
    operatore?: true
    idprodotto?: true
    dataesecuzione?: true
    orainizio?: true
    orafine?: true
    totaleore?: true
    osservazioni?: true
    codicecliente?: true
    stato?: true
    eliminato?: true
    idprodottocliente?: true
    faseoperazione?: true
    _all?: true
  }

  export type OperazioneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operazione to aggregate.
     */
    where?: OperazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operaziones to fetch.
     */
    orderBy?: OperazioneOrderByWithRelationInput | OperazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operaziones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operaziones
    **/
    _count?: true | OperazioneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperazioneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperazioneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperazioneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperazioneMaxAggregateInputType
  }

  export type GetOperazioneAggregateType<T extends OperazioneAggregateArgs> = {
        [P in keyof T & keyof AggregateOperazione]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperazione[P]>
      : GetScalarType<T[P], AggregateOperazione[P]>
  }




  export type OperazioneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperazioneWhereInput
    orderBy?: OperazioneOrderByWithAggregationInput | OperazioneOrderByWithAggregationInput[]
    by: OperazioneScalarFieldEnum[] | OperazioneScalarFieldEnum
    having?: OperazioneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperazioneCountAggregateInputType | true
    _avg?: OperazioneAvgAggregateInputType
    _sum?: OperazioneSumAggregateInputType
    _min?: OperazioneMinAggregateInputType
    _max?: OperazioneMaxAggregateInputType
  }

  export type OperazioneGroupByOutputType = {
    id: number
    datacreazione: Date | null
    tipo: string | null
    codice: string | null
    anno: number | null
    idazienda: number | null
    idcliente: number | null
    idintervento: number | null
    operatore: string | null
    idprodotto: number | null
    dataesecuzione: Date | null
    orainizio: number | null
    orafine: number | null
    totaleore: number | null
    osservazioni: string | null
    codicecliente: string | null
    stato: number | null
    eliminato: string | null
    idprodottocliente: number | null
    faseoperazione: number | null
    _count: OperazioneCountAggregateOutputType | null
    _avg: OperazioneAvgAggregateOutputType | null
    _sum: OperazioneSumAggregateOutputType | null
    _min: OperazioneMinAggregateOutputType | null
    _max: OperazioneMaxAggregateOutputType | null
  }

  type GetOperazioneGroupByPayload<T extends OperazioneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperazioneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperazioneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperazioneGroupByOutputType[P]>
            : GetScalarType<T[P], OperazioneGroupByOutputType[P]>
        }
      >
    >


  export type OperazioneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datacreazione?: boolean
    tipo?: boolean
    codice?: boolean
    anno?: boolean
    idazienda?: boolean
    idcliente?: boolean
    idintervento?: boolean
    operatore?: boolean
    idprodotto?: boolean
    dataesecuzione?: boolean
    orainizio?: boolean
    orafine?: boolean
    totaleore?: boolean
    osservazioni?: boolean
    codicecliente?: boolean
    stato?: boolean
    eliminato?: boolean
    idprodottocliente?: boolean
    faseoperazione?: boolean
    cliente?: boolean | Operazione$clienteArgs<ExtArgs>
  }, ExtArgs["result"]["operazione"]>

  export type OperazioneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datacreazione?: boolean
    tipo?: boolean
    codice?: boolean
    anno?: boolean
    idazienda?: boolean
    idcliente?: boolean
    idintervento?: boolean
    operatore?: boolean
    idprodotto?: boolean
    dataesecuzione?: boolean
    orainizio?: boolean
    orafine?: boolean
    totaleore?: boolean
    osservazioni?: boolean
    codicecliente?: boolean
    stato?: boolean
    eliminato?: boolean
    idprodottocliente?: boolean
    faseoperazione?: boolean
    cliente?: boolean | Operazione$clienteArgs<ExtArgs>
  }, ExtArgs["result"]["operazione"]>

  export type OperazioneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datacreazione?: boolean
    tipo?: boolean
    codice?: boolean
    anno?: boolean
    idazienda?: boolean
    idcliente?: boolean
    idintervento?: boolean
    operatore?: boolean
    idprodotto?: boolean
    dataesecuzione?: boolean
    orainizio?: boolean
    orafine?: boolean
    totaleore?: boolean
    osservazioni?: boolean
    codicecliente?: boolean
    stato?: boolean
    eliminato?: boolean
    idprodottocliente?: boolean
    faseoperazione?: boolean
    cliente?: boolean | Operazione$clienteArgs<ExtArgs>
  }, ExtArgs["result"]["operazione"]>

  export type OperazioneSelectScalar = {
    id?: boolean
    datacreazione?: boolean
    tipo?: boolean
    codice?: boolean
    anno?: boolean
    idazienda?: boolean
    idcliente?: boolean
    idintervento?: boolean
    operatore?: boolean
    idprodotto?: boolean
    dataesecuzione?: boolean
    orainizio?: boolean
    orafine?: boolean
    totaleore?: boolean
    osservazioni?: boolean
    codicecliente?: boolean
    stato?: boolean
    eliminato?: boolean
    idprodottocliente?: boolean
    faseoperazione?: boolean
  }

  export type OperazioneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datacreazione" | "tipo" | "codice" | "anno" | "idazienda" | "idcliente" | "idintervento" | "operatore" | "idprodotto" | "dataesecuzione" | "orainizio" | "orafine" | "totaleore" | "osservazioni" | "codicecliente" | "stato" | "eliminato" | "idprodottocliente" | "faseoperazione", ExtArgs["result"]["operazione"]>
  export type OperazioneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Operazione$clienteArgs<ExtArgs>
  }
  export type OperazioneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Operazione$clienteArgs<ExtArgs>
  }
  export type OperazioneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Operazione$clienteArgs<ExtArgs>
  }

  export type $OperazionePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operazione"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      datacreazione: Date | null
      tipo: string | null
      codice: string | null
      anno: number | null
      idazienda: number | null
      idcliente: number | null
      idintervento: number | null
      operatore: string | null
      idprodotto: number | null
      dataesecuzione: Date | null
      orainizio: number | null
      orafine: number | null
      totaleore: number | null
      osservazioni: string | null
      codicecliente: string | null
      stato: number | null
      eliminato: string | null
      idprodottocliente: number | null
      faseoperazione: number | null
    }, ExtArgs["result"]["operazione"]>
    composites: {}
  }

  type OperazioneGetPayload<S extends boolean | null | undefined | OperazioneDefaultArgs> = $Result.GetResult<Prisma.$OperazionePayload, S>

  type OperazioneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperazioneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperazioneCountAggregateInputType | true
    }

  export interface OperazioneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operazione'], meta: { name: 'Operazione' } }
    /**
     * Find zero or one Operazione that matches the filter.
     * @param {OperazioneFindUniqueArgs} args - Arguments to find a Operazione
     * @example
     * // Get one Operazione
     * const operazione = await prisma.operazione.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperazioneFindUniqueArgs>(args: SelectSubset<T, OperazioneFindUniqueArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operazione that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperazioneFindUniqueOrThrowArgs} args - Arguments to find a Operazione
     * @example
     * // Get one Operazione
     * const operazione = await prisma.operazione.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperazioneFindUniqueOrThrowArgs>(args: SelectSubset<T, OperazioneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operazione that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFindFirstArgs} args - Arguments to find a Operazione
     * @example
     * // Get one Operazione
     * const operazione = await prisma.operazione.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperazioneFindFirstArgs>(args?: SelectSubset<T, OperazioneFindFirstArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operazione that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFindFirstOrThrowArgs} args - Arguments to find a Operazione
     * @example
     * // Get one Operazione
     * const operazione = await prisma.operazione.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperazioneFindFirstOrThrowArgs>(args?: SelectSubset<T, OperazioneFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operaziones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operaziones
     * const operaziones = await prisma.operazione.findMany()
     * 
     * // Get first 10 Operaziones
     * const operaziones = await prisma.operazione.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operazioneWithIdOnly = await prisma.operazione.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperazioneFindManyArgs>(args?: SelectSubset<T, OperazioneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operazione.
     * @param {OperazioneCreateArgs} args - Arguments to create a Operazione.
     * @example
     * // Create one Operazione
     * const Operazione = await prisma.operazione.create({
     *   data: {
     *     // ... data to create a Operazione
     *   }
     * })
     * 
     */
    create<T extends OperazioneCreateArgs>(args: SelectSubset<T, OperazioneCreateArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operaziones.
     * @param {OperazioneCreateManyArgs} args - Arguments to create many Operaziones.
     * @example
     * // Create many Operaziones
     * const operazione = await prisma.operazione.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperazioneCreateManyArgs>(args?: SelectSubset<T, OperazioneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operaziones and returns the data saved in the database.
     * @param {OperazioneCreateManyAndReturnArgs} args - Arguments to create many Operaziones.
     * @example
     * // Create many Operaziones
     * const operazione = await prisma.operazione.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operaziones and only return the `id`
     * const operazioneWithIdOnly = await prisma.operazione.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperazioneCreateManyAndReturnArgs>(args?: SelectSubset<T, OperazioneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operazione.
     * @param {OperazioneDeleteArgs} args - Arguments to delete one Operazione.
     * @example
     * // Delete one Operazione
     * const Operazione = await prisma.operazione.delete({
     *   where: {
     *     // ... filter to delete one Operazione
     *   }
     * })
     * 
     */
    delete<T extends OperazioneDeleteArgs>(args: SelectSubset<T, OperazioneDeleteArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operazione.
     * @param {OperazioneUpdateArgs} args - Arguments to update one Operazione.
     * @example
     * // Update one Operazione
     * const operazione = await prisma.operazione.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperazioneUpdateArgs>(args: SelectSubset<T, OperazioneUpdateArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operaziones.
     * @param {OperazioneDeleteManyArgs} args - Arguments to filter Operaziones to delete.
     * @example
     * // Delete a few Operaziones
     * const { count } = await prisma.operazione.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperazioneDeleteManyArgs>(args?: SelectSubset<T, OperazioneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operaziones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operaziones
     * const operazione = await prisma.operazione.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperazioneUpdateManyArgs>(args: SelectSubset<T, OperazioneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operaziones and returns the data updated in the database.
     * @param {OperazioneUpdateManyAndReturnArgs} args - Arguments to update many Operaziones.
     * @example
     * // Update many Operaziones
     * const operazione = await prisma.operazione.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operaziones and only return the `id`
     * const operazioneWithIdOnly = await prisma.operazione.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperazioneUpdateManyAndReturnArgs>(args: SelectSubset<T, OperazioneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operazione.
     * @param {OperazioneUpsertArgs} args - Arguments to update or create a Operazione.
     * @example
     * // Update or create a Operazione
     * const operazione = await prisma.operazione.upsert({
     *   create: {
     *     // ... data to create a Operazione
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operazione we want to update
     *   }
     * })
     */
    upsert<T extends OperazioneUpsertArgs>(args: SelectSubset<T, OperazioneUpsertArgs<ExtArgs>>): Prisma__OperazioneClient<$Result.GetResult<Prisma.$OperazionePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operaziones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneCountArgs} args - Arguments to filter Operaziones to count.
     * @example
     * // Count the number of Operaziones
     * const count = await prisma.operazione.count({
     *   where: {
     *     // ... the filter for the Operaziones we want to count
     *   }
     * })
    **/
    count<T extends OperazioneCountArgs>(
      args?: Subset<T, OperazioneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperazioneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operazione.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperazioneAggregateArgs>(args: Subset<T, OperazioneAggregateArgs>): Prisma.PrismaPromise<GetOperazioneAggregateType<T>>

    /**
     * Group by Operazione.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperazioneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperazioneGroupByArgs['orderBy'] }
        : { orderBy?: OperazioneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperazioneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperazioneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operazione model
   */
  readonly fields: OperazioneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operazione.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperazioneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends Operazione$clienteArgs<ExtArgs> = {}>(args?: Subset<T, Operazione$clienteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operazione model
   */
  interface OperazioneFieldRefs {
    readonly id: FieldRef<"Operazione", 'Int'>
    readonly datacreazione: FieldRef<"Operazione", 'DateTime'>
    readonly tipo: FieldRef<"Operazione", 'String'>
    readonly codice: FieldRef<"Operazione", 'String'>
    readonly anno: FieldRef<"Operazione", 'Int'>
    readonly idazienda: FieldRef<"Operazione", 'Int'>
    readonly idcliente: FieldRef<"Operazione", 'Int'>
    readonly idintervento: FieldRef<"Operazione", 'Int'>
    readonly operatore: FieldRef<"Operazione", 'String'>
    readonly idprodotto: FieldRef<"Operazione", 'Int'>
    readonly dataesecuzione: FieldRef<"Operazione", 'DateTime'>
    readonly orainizio: FieldRef<"Operazione", 'Int'>
    readonly orafine: FieldRef<"Operazione", 'Int'>
    readonly totaleore: FieldRef<"Operazione", 'Int'>
    readonly osservazioni: FieldRef<"Operazione", 'String'>
    readonly codicecliente: FieldRef<"Operazione", 'String'>
    readonly stato: FieldRef<"Operazione", 'Int'>
    readonly eliminato: FieldRef<"Operazione", 'String'>
    readonly idprodottocliente: FieldRef<"Operazione", 'Int'>
    readonly faseoperazione: FieldRef<"Operazione", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Operazione findUnique
   */
  export type OperazioneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * Filter, which Operazione to fetch.
     */
    where: OperazioneWhereUniqueInput
  }

  /**
   * Operazione findUniqueOrThrow
   */
  export type OperazioneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * Filter, which Operazione to fetch.
     */
    where: OperazioneWhereUniqueInput
  }

  /**
   * Operazione findFirst
   */
  export type OperazioneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * Filter, which Operazione to fetch.
     */
    where?: OperazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operaziones to fetch.
     */
    orderBy?: OperazioneOrderByWithRelationInput | OperazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operaziones.
     */
    cursor?: OperazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operaziones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operaziones.
     */
    distinct?: OperazioneScalarFieldEnum | OperazioneScalarFieldEnum[]
  }

  /**
   * Operazione findFirstOrThrow
   */
  export type OperazioneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * Filter, which Operazione to fetch.
     */
    where?: OperazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operaziones to fetch.
     */
    orderBy?: OperazioneOrderByWithRelationInput | OperazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operaziones.
     */
    cursor?: OperazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operaziones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operaziones.
     */
    distinct?: OperazioneScalarFieldEnum | OperazioneScalarFieldEnum[]
  }

  /**
   * Operazione findMany
   */
  export type OperazioneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * Filter, which Operaziones to fetch.
     */
    where?: OperazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operaziones to fetch.
     */
    orderBy?: OperazioneOrderByWithRelationInput | OperazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operaziones.
     */
    cursor?: OperazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operaziones.
     */
    skip?: number
    distinct?: OperazioneScalarFieldEnum | OperazioneScalarFieldEnum[]
  }

  /**
   * Operazione create
   */
  export type OperazioneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * The data needed to create a Operazione.
     */
    data?: XOR<OperazioneCreateInput, OperazioneUncheckedCreateInput>
  }

  /**
   * Operazione createMany
   */
  export type OperazioneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operaziones.
     */
    data: OperazioneCreateManyInput | OperazioneCreateManyInput[]
  }

  /**
   * Operazione createManyAndReturn
   */
  export type OperazioneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * The data used to create many Operaziones.
     */
    data: OperazioneCreateManyInput | OperazioneCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operazione update
   */
  export type OperazioneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * The data needed to update a Operazione.
     */
    data: XOR<OperazioneUpdateInput, OperazioneUncheckedUpdateInput>
    /**
     * Choose, which Operazione to update.
     */
    where: OperazioneWhereUniqueInput
  }

  /**
   * Operazione updateMany
   */
  export type OperazioneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operaziones.
     */
    data: XOR<OperazioneUpdateManyMutationInput, OperazioneUncheckedUpdateManyInput>
    /**
     * Filter which Operaziones to update
     */
    where?: OperazioneWhereInput
    /**
     * Limit how many Operaziones to update.
     */
    limit?: number
  }

  /**
   * Operazione updateManyAndReturn
   */
  export type OperazioneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * The data used to update Operaziones.
     */
    data: XOR<OperazioneUpdateManyMutationInput, OperazioneUncheckedUpdateManyInput>
    /**
     * Filter which Operaziones to update
     */
    where?: OperazioneWhereInput
    /**
     * Limit how many Operaziones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operazione upsert
   */
  export type OperazioneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * The filter to search for the Operazione to update in case it exists.
     */
    where: OperazioneWhereUniqueInput
    /**
     * In case the Operazione found by the `where` argument doesn't exist, create a new Operazione with this data.
     */
    create: XOR<OperazioneCreateInput, OperazioneUncheckedCreateInput>
    /**
     * In case the Operazione was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperazioneUpdateInput, OperazioneUncheckedUpdateInput>
  }

  /**
   * Operazione delete
   */
  export type OperazioneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
    /**
     * Filter which Operazione to delete.
     */
    where: OperazioneWhereUniqueInput
  }

  /**
   * Operazione deleteMany
   */
  export type OperazioneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operaziones to delete
     */
    where?: OperazioneWhereInput
    /**
     * Limit how many Operaziones to delete.
     */
    limit?: number
  }

  /**
   * Operazione.cliente
   */
  export type Operazione$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cliente
     */
    omit?: ClienteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
  }

  /**
   * Operazione without action
   */
  export type OperazioneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operazione
     */
    select?: OperazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operazione
     */
    omit?: OperazioneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperazioneInclude<ExtArgs> | null
  }


  /**
   * Model OperazioneFirma
   */

  export type AggregateOperazioneFirma = {
    _count: OperazioneFirmaCountAggregateOutputType | null
    _avg: OperazioneFirmaAvgAggregateOutputType | null
    _sum: OperazioneFirmaSumAggregateOutputType | null
    _min: OperazioneFirmaMinAggregateOutputType | null
    _max: OperazioneFirmaMaxAggregateOutputType | null
  }

  export type OperazioneFirmaAvgAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneFirmaSumAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneFirmaMinAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneFirmaMaxAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneFirmaCountAggregateOutputType = {
    id: number
    idoperazione: number
    _all: number
  }


  export type OperazioneFirmaAvgAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneFirmaSumAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneFirmaMinAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneFirmaMaxAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneFirmaCountAggregateInputType = {
    id?: true
    idoperazione?: true
    _all?: true
  }

  export type OperazioneFirmaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperazioneFirma to aggregate.
     */
    where?: OperazioneFirmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneFirmas to fetch.
     */
    orderBy?: OperazioneFirmaOrderByWithRelationInput | OperazioneFirmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperazioneFirmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneFirmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneFirmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperazioneFirmas
    **/
    _count?: true | OperazioneFirmaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperazioneFirmaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperazioneFirmaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperazioneFirmaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperazioneFirmaMaxAggregateInputType
  }

  export type GetOperazioneFirmaAggregateType<T extends OperazioneFirmaAggregateArgs> = {
        [P in keyof T & keyof AggregateOperazioneFirma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperazioneFirma[P]>
      : GetScalarType<T[P], AggregateOperazioneFirma[P]>
  }




  export type OperazioneFirmaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperazioneFirmaWhereInput
    orderBy?: OperazioneFirmaOrderByWithAggregationInput | OperazioneFirmaOrderByWithAggregationInput[]
    by: OperazioneFirmaScalarFieldEnum[] | OperazioneFirmaScalarFieldEnum
    having?: OperazioneFirmaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperazioneFirmaCountAggregateInputType | true
    _avg?: OperazioneFirmaAvgAggregateInputType
    _sum?: OperazioneFirmaSumAggregateInputType
    _min?: OperazioneFirmaMinAggregateInputType
    _max?: OperazioneFirmaMaxAggregateInputType
  }

  export type OperazioneFirmaGroupByOutputType = {
    id: number
    idoperazione: number | null
    _count: OperazioneFirmaCountAggregateOutputType | null
    _avg: OperazioneFirmaAvgAggregateOutputType | null
    _sum: OperazioneFirmaSumAggregateOutputType | null
    _min: OperazioneFirmaMinAggregateOutputType | null
    _max: OperazioneFirmaMaxAggregateOutputType | null
  }

  type GetOperazioneFirmaGroupByPayload<T extends OperazioneFirmaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperazioneFirmaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperazioneFirmaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperazioneFirmaGroupByOutputType[P]>
            : GetScalarType<T[P], OperazioneFirmaGroupByOutputType[P]>
        }
      >
    >


  export type OperazioneFirmaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazioneFirma"]>

  export type OperazioneFirmaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazioneFirma"]>

  export type OperazioneFirmaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazioneFirma"]>

  export type OperazioneFirmaSelectScalar = {
    id?: boolean
    idoperazione?: boolean
  }

  export type OperazioneFirmaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idoperazione", ExtArgs["result"]["operazioneFirma"]>

  export type $OperazioneFirmaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperazioneFirma"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idoperazione: number | null
    }, ExtArgs["result"]["operazioneFirma"]>
    composites: {}
  }

  type OperazioneFirmaGetPayload<S extends boolean | null | undefined | OperazioneFirmaDefaultArgs> = $Result.GetResult<Prisma.$OperazioneFirmaPayload, S>

  type OperazioneFirmaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperazioneFirmaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperazioneFirmaCountAggregateInputType | true
    }

  export interface OperazioneFirmaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperazioneFirma'], meta: { name: 'OperazioneFirma' } }
    /**
     * Find zero or one OperazioneFirma that matches the filter.
     * @param {OperazioneFirmaFindUniqueArgs} args - Arguments to find a OperazioneFirma
     * @example
     * // Get one OperazioneFirma
     * const operazioneFirma = await prisma.operazioneFirma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperazioneFirmaFindUniqueArgs>(args: SelectSubset<T, OperazioneFirmaFindUniqueArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperazioneFirma that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperazioneFirmaFindUniqueOrThrowArgs} args - Arguments to find a OperazioneFirma
     * @example
     * // Get one OperazioneFirma
     * const operazioneFirma = await prisma.operazioneFirma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperazioneFirmaFindUniqueOrThrowArgs>(args: SelectSubset<T, OperazioneFirmaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperazioneFirma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaFindFirstArgs} args - Arguments to find a OperazioneFirma
     * @example
     * // Get one OperazioneFirma
     * const operazioneFirma = await prisma.operazioneFirma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperazioneFirmaFindFirstArgs>(args?: SelectSubset<T, OperazioneFirmaFindFirstArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperazioneFirma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaFindFirstOrThrowArgs} args - Arguments to find a OperazioneFirma
     * @example
     * // Get one OperazioneFirma
     * const operazioneFirma = await prisma.operazioneFirma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperazioneFirmaFindFirstOrThrowArgs>(args?: SelectSubset<T, OperazioneFirmaFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperazioneFirmas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperazioneFirmas
     * const operazioneFirmas = await prisma.operazioneFirma.findMany()
     * 
     * // Get first 10 OperazioneFirmas
     * const operazioneFirmas = await prisma.operazioneFirma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operazioneFirmaWithIdOnly = await prisma.operazioneFirma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperazioneFirmaFindManyArgs>(args?: SelectSubset<T, OperazioneFirmaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperazioneFirma.
     * @param {OperazioneFirmaCreateArgs} args - Arguments to create a OperazioneFirma.
     * @example
     * // Create one OperazioneFirma
     * const OperazioneFirma = await prisma.operazioneFirma.create({
     *   data: {
     *     // ... data to create a OperazioneFirma
     *   }
     * })
     * 
     */
    create<T extends OperazioneFirmaCreateArgs>(args: SelectSubset<T, OperazioneFirmaCreateArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperazioneFirmas.
     * @param {OperazioneFirmaCreateManyArgs} args - Arguments to create many OperazioneFirmas.
     * @example
     * // Create many OperazioneFirmas
     * const operazioneFirma = await prisma.operazioneFirma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperazioneFirmaCreateManyArgs>(args?: SelectSubset<T, OperazioneFirmaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperazioneFirmas and returns the data saved in the database.
     * @param {OperazioneFirmaCreateManyAndReturnArgs} args - Arguments to create many OperazioneFirmas.
     * @example
     * // Create many OperazioneFirmas
     * const operazioneFirma = await prisma.operazioneFirma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperazioneFirmas and only return the `id`
     * const operazioneFirmaWithIdOnly = await prisma.operazioneFirma.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperazioneFirmaCreateManyAndReturnArgs>(args?: SelectSubset<T, OperazioneFirmaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperazioneFirma.
     * @param {OperazioneFirmaDeleteArgs} args - Arguments to delete one OperazioneFirma.
     * @example
     * // Delete one OperazioneFirma
     * const OperazioneFirma = await prisma.operazioneFirma.delete({
     *   where: {
     *     // ... filter to delete one OperazioneFirma
     *   }
     * })
     * 
     */
    delete<T extends OperazioneFirmaDeleteArgs>(args: SelectSubset<T, OperazioneFirmaDeleteArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperazioneFirma.
     * @param {OperazioneFirmaUpdateArgs} args - Arguments to update one OperazioneFirma.
     * @example
     * // Update one OperazioneFirma
     * const operazioneFirma = await prisma.operazioneFirma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperazioneFirmaUpdateArgs>(args: SelectSubset<T, OperazioneFirmaUpdateArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperazioneFirmas.
     * @param {OperazioneFirmaDeleteManyArgs} args - Arguments to filter OperazioneFirmas to delete.
     * @example
     * // Delete a few OperazioneFirmas
     * const { count } = await prisma.operazioneFirma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperazioneFirmaDeleteManyArgs>(args?: SelectSubset<T, OperazioneFirmaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperazioneFirmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperazioneFirmas
     * const operazioneFirma = await prisma.operazioneFirma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperazioneFirmaUpdateManyArgs>(args: SelectSubset<T, OperazioneFirmaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperazioneFirmas and returns the data updated in the database.
     * @param {OperazioneFirmaUpdateManyAndReturnArgs} args - Arguments to update many OperazioneFirmas.
     * @example
     * // Update many OperazioneFirmas
     * const operazioneFirma = await prisma.operazioneFirma.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperazioneFirmas and only return the `id`
     * const operazioneFirmaWithIdOnly = await prisma.operazioneFirma.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperazioneFirmaUpdateManyAndReturnArgs>(args: SelectSubset<T, OperazioneFirmaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperazioneFirma.
     * @param {OperazioneFirmaUpsertArgs} args - Arguments to update or create a OperazioneFirma.
     * @example
     * // Update or create a OperazioneFirma
     * const operazioneFirma = await prisma.operazioneFirma.upsert({
     *   create: {
     *     // ... data to create a OperazioneFirma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperazioneFirma we want to update
     *   }
     * })
     */
    upsert<T extends OperazioneFirmaUpsertArgs>(args: SelectSubset<T, OperazioneFirmaUpsertArgs<ExtArgs>>): Prisma__OperazioneFirmaClient<$Result.GetResult<Prisma.$OperazioneFirmaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperazioneFirmas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaCountArgs} args - Arguments to filter OperazioneFirmas to count.
     * @example
     * // Count the number of OperazioneFirmas
     * const count = await prisma.operazioneFirma.count({
     *   where: {
     *     // ... the filter for the OperazioneFirmas we want to count
     *   }
     * })
    **/
    count<T extends OperazioneFirmaCountArgs>(
      args?: Subset<T, OperazioneFirmaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperazioneFirmaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperazioneFirma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperazioneFirmaAggregateArgs>(args: Subset<T, OperazioneFirmaAggregateArgs>): Prisma.PrismaPromise<GetOperazioneFirmaAggregateType<T>>

    /**
     * Group by OperazioneFirma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneFirmaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperazioneFirmaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperazioneFirmaGroupByArgs['orderBy'] }
        : { orderBy?: OperazioneFirmaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperazioneFirmaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperazioneFirmaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperazioneFirma model
   */
  readonly fields: OperazioneFirmaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperazioneFirma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperazioneFirmaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperazioneFirma model
   */
  interface OperazioneFirmaFieldRefs {
    readonly id: FieldRef<"OperazioneFirma", 'Int'>
    readonly idoperazione: FieldRef<"OperazioneFirma", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OperazioneFirma findUnique
   */
  export type OperazioneFirmaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneFirma to fetch.
     */
    where: OperazioneFirmaWhereUniqueInput
  }

  /**
   * OperazioneFirma findUniqueOrThrow
   */
  export type OperazioneFirmaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneFirma to fetch.
     */
    where: OperazioneFirmaWhereUniqueInput
  }

  /**
   * OperazioneFirma findFirst
   */
  export type OperazioneFirmaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneFirma to fetch.
     */
    where?: OperazioneFirmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneFirmas to fetch.
     */
    orderBy?: OperazioneFirmaOrderByWithRelationInput | OperazioneFirmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperazioneFirmas.
     */
    cursor?: OperazioneFirmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneFirmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneFirmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperazioneFirmas.
     */
    distinct?: OperazioneFirmaScalarFieldEnum | OperazioneFirmaScalarFieldEnum[]
  }

  /**
   * OperazioneFirma findFirstOrThrow
   */
  export type OperazioneFirmaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneFirma to fetch.
     */
    where?: OperazioneFirmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneFirmas to fetch.
     */
    orderBy?: OperazioneFirmaOrderByWithRelationInput | OperazioneFirmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperazioneFirmas.
     */
    cursor?: OperazioneFirmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneFirmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneFirmas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperazioneFirmas.
     */
    distinct?: OperazioneFirmaScalarFieldEnum | OperazioneFirmaScalarFieldEnum[]
  }

  /**
   * OperazioneFirma findMany
   */
  export type OperazioneFirmaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneFirmas to fetch.
     */
    where?: OperazioneFirmaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneFirmas to fetch.
     */
    orderBy?: OperazioneFirmaOrderByWithRelationInput | OperazioneFirmaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperazioneFirmas.
     */
    cursor?: OperazioneFirmaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneFirmas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneFirmas.
     */
    skip?: number
    distinct?: OperazioneFirmaScalarFieldEnum | OperazioneFirmaScalarFieldEnum[]
  }

  /**
   * OperazioneFirma create
   */
  export type OperazioneFirmaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * The data needed to create a OperazioneFirma.
     */
    data?: XOR<OperazioneFirmaCreateInput, OperazioneFirmaUncheckedCreateInput>
  }

  /**
   * OperazioneFirma createMany
   */
  export type OperazioneFirmaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperazioneFirmas.
     */
    data: OperazioneFirmaCreateManyInput | OperazioneFirmaCreateManyInput[]
  }

  /**
   * OperazioneFirma createManyAndReturn
   */
  export type OperazioneFirmaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * The data used to create many OperazioneFirmas.
     */
    data: OperazioneFirmaCreateManyInput | OperazioneFirmaCreateManyInput[]
  }

  /**
   * OperazioneFirma update
   */
  export type OperazioneFirmaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * The data needed to update a OperazioneFirma.
     */
    data: XOR<OperazioneFirmaUpdateInput, OperazioneFirmaUncheckedUpdateInput>
    /**
     * Choose, which OperazioneFirma to update.
     */
    where: OperazioneFirmaWhereUniqueInput
  }

  /**
   * OperazioneFirma updateMany
   */
  export type OperazioneFirmaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperazioneFirmas.
     */
    data: XOR<OperazioneFirmaUpdateManyMutationInput, OperazioneFirmaUncheckedUpdateManyInput>
    /**
     * Filter which OperazioneFirmas to update
     */
    where?: OperazioneFirmaWhereInput
    /**
     * Limit how many OperazioneFirmas to update.
     */
    limit?: number
  }

  /**
   * OperazioneFirma updateManyAndReturn
   */
  export type OperazioneFirmaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * The data used to update OperazioneFirmas.
     */
    data: XOR<OperazioneFirmaUpdateManyMutationInput, OperazioneFirmaUncheckedUpdateManyInput>
    /**
     * Filter which OperazioneFirmas to update
     */
    where?: OperazioneFirmaWhereInput
    /**
     * Limit how many OperazioneFirmas to update.
     */
    limit?: number
  }

  /**
   * OperazioneFirma upsert
   */
  export type OperazioneFirmaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * The filter to search for the OperazioneFirma to update in case it exists.
     */
    where: OperazioneFirmaWhereUniqueInput
    /**
     * In case the OperazioneFirma found by the `where` argument doesn't exist, create a new OperazioneFirma with this data.
     */
    create: XOR<OperazioneFirmaCreateInput, OperazioneFirmaUncheckedCreateInput>
    /**
     * In case the OperazioneFirma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperazioneFirmaUpdateInput, OperazioneFirmaUncheckedUpdateInput>
  }

  /**
   * OperazioneFirma delete
   */
  export type OperazioneFirmaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
    /**
     * Filter which OperazioneFirma to delete.
     */
    where: OperazioneFirmaWhereUniqueInput
  }

  /**
   * OperazioneFirma deleteMany
   */
  export type OperazioneFirmaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperazioneFirmas to delete
     */
    where?: OperazioneFirmaWhereInput
    /**
     * Limit how many OperazioneFirmas to delete.
     */
    limit?: number
  }

  /**
   * OperazioneFirma without action
   */
  export type OperazioneFirmaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneFirma
     */
    select?: OperazioneFirmaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneFirma
     */
    omit?: OperazioneFirmaOmit<ExtArgs> | null
  }


  /**
   * Model OperazioneDescrizazioni
   */

  export type AggregateOperazioneDescrizazioni = {
    _count: OperazioneDescrizazioniCountAggregateOutputType | null
    _avg: OperazioneDescrizazioniAvgAggregateOutputType | null
    _sum: OperazioneDescrizazioniSumAggregateOutputType | null
    _min: OperazioneDescrizazioniMinAggregateOutputType | null
    _max: OperazioneDescrizazioniMaxAggregateOutputType | null
  }

  export type OperazioneDescrizazioniAvgAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneDescrizazioniSumAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneDescrizazioniMinAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneDescrizazioniMaxAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazioneDescrizazioniCountAggregateOutputType = {
    id: number
    idoperazione: number
    _all: number
  }


  export type OperazioneDescrizazioniAvgAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneDescrizazioniSumAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneDescrizazioniMinAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneDescrizazioniMaxAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazioneDescrizazioniCountAggregateInputType = {
    id?: true
    idoperazione?: true
    _all?: true
  }

  export type OperazioneDescrizazioniAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperazioneDescrizazioni to aggregate.
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneDescrizazionis to fetch.
     */
    orderBy?: OperazioneDescrizazioniOrderByWithRelationInput | OperazioneDescrizazioniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperazioneDescrizazioniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneDescrizazionis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneDescrizazionis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperazioneDescrizazionis
    **/
    _count?: true | OperazioneDescrizazioniCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperazioneDescrizazioniAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperazioneDescrizazioniSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperazioneDescrizazioniMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperazioneDescrizazioniMaxAggregateInputType
  }

  export type GetOperazioneDescrizazioniAggregateType<T extends OperazioneDescrizazioniAggregateArgs> = {
        [P in keyof T & keyof AggregateOperazioneDescrizazioni]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperazioneDescrizazioni[P]>
      : GetScalarType<T[P], AggregateOperazioneDescrizazioni[P]>
  }




  export type OperazioneDescrizazioniGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperazioneDescrizazioniWhereInput
    orderBy?: OperazioneDescrizazioniOrderByWithAggregationInput | OperazioneDescrizazioniOrderByWithAggregationInput[]
    by: OperazioneDescrizazioniScalarFieldEnum[] | OperazioneDescrizazioniScalarFieldEnum
    having?: OperazioneDescrizazioniScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperazioneDescrizazioniCountAggregateInputType | true
    _avg?: OperazioneDescrizazioniAvgAggregateInputType
    _sum?: OperazioneDescrizazioniSumAggregateInputType
    _min?: OperazioneDescrizazioniMinAggregateInputType
    _max?: OperazioneDescrizazioniMaxAggregateInputType
  }

  export type OperazioneDescrizazioniGroupByOutputType = {
    id: number
    idoperazione: number | null
    _count: OperazioneDescrizazioniCountAggregateOutputType | null
    _avg: OperazioneDescrizazioniAvgAggregateOutputType | null
    _sum: OperazioneDescrizazioniSumAggregateOutputType | null
    _min: OperazioneDescrizazioniMinAggregateOutputType | null
    _max: OperazioneDescrizazioniMaxAggregateOutputType | null
  }

  type GetOperazioneDescrizazioniGroupByPayload<T extends OperazioneDescrizazioniGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperazioneDescrizazioniGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperazioneDescrizazioniGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperazioneDescrizazioniGroupByOutputType[P]>
            : GetScalarType<T[P], OperazioneDescrizazioniGroupByOutputType[P]>
        }
      >
    >


  export type OperazioneDescrizazioniSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazioneDescrizazioni"]>

  export type OperazioneDescrizazioniSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazioneDescrizazioni"]>

  export type OperazioneDescrizazioniSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazioneDescrizazioni"]>

  export type OperazioneDescrizazioniSelectScalar = {
    id?: boolean
    idoperazione?: boolean
  }

  export type OperazioneDescrizazioniOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idoperazione", ExtArgs["result"]["operazioneDescrizazioni"]>

  export type $OperazioneDescrizazioniPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperazioneDescrizazioni"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idoperazione: number | null
    }, ExtArgs["result"]["operazioneDescrizazioni"]>
    composites: {}
  }

  type OperazioneDescrizazioniGetPayload<S extends boolean | null | undefined | OperazioneDescrizazioniDefaultArgs> = $Result.GetResult<Prisma.$OperazioneDescrizazioniPayload, S>

  type OperazioneDescrizazioniCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperazioneDescrizazioniFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperazioneDescrizazioniCountAggregateInputType | true
    }

  export interface OperazioneDescrizazioniDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperazioneDescrizazioni'], meta: { name: 'OperazioneDescrizazioni' } }
    /**
     * Find zero or one OperazioneDescrizazioni that matches the filter.
     * @param {OperazioneDescrizazioniFindUniqueArgs} args - Arguments to find a OperazioneDescrizazioni
     * @example
     * // Get one OperazioneDescrizazioni
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperazioneDescrizazioniFindUniqueArgs>(args: SelectSubset<T, OperazioneDescrizazioniFindUniqueArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperazioneDescrizazioni that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperazioneDescrizazioniFindUniqueOrThrowArgs} args - Arguments to find a OperazioneDescrizazioni
     * @example
     * // Get one OperazioneDescrizazioni
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperazioneDescrizazioniFindUniqueOrThrowArgs>(args: SelectSubset<T, OperazioneDescrizazioniFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperazioneDescrizazioni that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniFindFirstArgs} args - Arguments to find a OperazioneDescrizazioni
     * @example
     * // Get one OperazioneDescrizazioni
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperazioneDescrizazioniFindFirstArgs>(args?: SelectSubset<T, OperazioneDescrizazioniFindFirstArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperazioneDescrizazioni that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniFindFirstOrThrowArgs} args - Arguments to find a OperazioneDescrizazioni
     * @example
     * // Get one OperazioneDescrizazioni
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperazioneDescrizazioniFindFirstOrThrowArgs>(args?: SelectSubset<T, OperazioneDescrizazioniFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperazioneDescrizazionis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperazioneDescrizazionis
     * const operazioneDescrizazionis = await prisma.operazioneDescrizazioni.findMany()
     * 
     * // Get first 10 OperazioneDescrizazionis
     * const operazioneDescrizazionis = await prisma.operazioneDescrizazioni.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operazioneDescrizazioniWithIdOnly = await prisma.operazioneDescrizazioni.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperazioneDescrizazioniFindManyArgs>(args?: SelectSubset<T, OperazioneDescrizazioniFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperazioneDescrizazioni.
     * @param {OperazioneDescrizazioniCreateArgs} args - Arguments to create a OperazioneDescrizazioni.
     * @example
     * // Create one OperazioneDescrizazioni
     * const OperazioneDescrizazioni = await prisma.operazioneDescrizazioni.create({
     *   data: {
     *     // ... data to create a OperazioneDescrizazioni
     *   }
     * })
     * 
     */
    create<T extends OperazioneDescrizazioniCreateArgs>(args: SelectSubset<T, OperazioneDescrizazioniCreateArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperazioneDescrizazionis.
     * @param {OperazioneDescrizazioniCreateManyArgs} args - Arguments to create many OperazioneDescrizazionis.
     * @example
     * // Create many OperazioneDescrizazionis
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperazioneDescrizazioniCreateManyArgs>(args?: SelectSubset<T, OperazioneDescrizazioniCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperazioneDescrizazionis and returns the data saved in the database.
     * @param {OperazioneDescrizazioniCreateManyAndReturnArgs} args - Arguments to create many OperazioneDescrizazionis.
     * @example
     * // Create many OperazioneDescrizazionis
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperazioneDescrizazionis and only return the `id`
     * const operazioneDescrizazioniWithIdOnly = await prisma.operazioneDescrizazioni.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperazioneDescrizazioniCreateManyAndReturnArgs>(args?: SelectSubset<T, OperazioneDescrizazioniCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperazioneDescrizazioni.
     * @param {OperazioneDescrizazioniDeleteArgs} args - Arguments to delete one OperazioneDescrizazioni.
     * @example
     * // Delete one OperazioneDescrizazioni
     * const OperazioneDescrizazioni = await prisma.operazioneDescrizazioni.delete({
     *   where: {
     *     // ... filter to delete one OperazioneDescrizazioni
     *   }
     * })
     * 
     */
    delete<T extends OperazioneDescrizazioniDeleteArgs>(args: SelectSubset<T, OperazioneDescrizazioniDeleteArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperazioneDescrizazioni.
     * @param {OperazioneDescrizazioniUpdateArgs} args - Arguments to update one OperazioneDescrizazioni.
     * @example
     * // Update one OperazioneDescrizazioni
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperazioneDescrizazioniUpdateArgs>(args: SelectSubset<T, OperazioneDescrizazioniUpdateArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperazioneDescrizazionis.
     * @param {OperazioneDescrizazioniDeleteManyArgs} args - Arguments to filter OperazioneDescrizazionis to delete.
     * @example
     * // Delete a few OperazioneDescrizazionis
     * const { count } = await prisma.operazioneDescrizazioni.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperazioneDescrizazioniDeleteManyArgs>(args?: SelectSubset<T, OperazioneDescrizazioniDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperazioneDescrizazionis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperazioneDescrizazionis
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperazioneDescrizazioniUpdateManyArgs>(args: SelectSubset<T, OperazioneDescrizazioniUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperazioneDescrizazionis and returns the data updated in the database.
     * @param {OperazioneDescrizazioniUpdateManyAndReturnArgs} args - Arguments to update many OperazioneDescrizazionis.
     * @example
     * // Update many OperazioneDescrizazionis
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperazioneDescrizazionis and only return the `id`
     * const operazioneDescrizazioniWithIdOnly = await prisma.operazioneDescrizazioni.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperazioneDescrizazioniUpdateManyAndReturnArgs>(args: SelectSubset<T, OperazioneDescrizazioniUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperazioneDescrizazioni.
     * @param {OperazioneDescrizazioniUpsertArgs} args - Arguments to update or create a OperazioneDescrizazioni.
     * @example
     * // Update or create a OperazioneDescrizazioni
     * const operazioneDescrizazioni = await prisma.operazioneDescrizazioni.upsert({
     *   create: {
     *     // ... data to create a OperazioneDescrizazioni
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperazioneDescrizazioni we want to update
     *   }
     * })
     */
    upsert<T extends OperazioneDescrizazioniUpsertArgs>(args: SelectSubset<T, OperazioneDescrizazioniUpsertArgs<ExtArgs>>): Prisma__OperazioneDescrizazioniClient<$Result.GetResult<Prisma.$OperazioneDescrizazioniPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperazioneDescrizazionis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniCountArgs} args - Arguments to filter OperazioneDescrizazionis to count.
     * @example
     * // Count the number of OperazioneDescrizazionis
     * const count = await prisma.operazioneDescrizazioni.count({
     *   where: {
     *     // ... the filter for the OperazioneDescrizazionis we want to count
     *   }
     * })
    **/
    count<T extends OperazioneDescrizazioniCountArgs>(
      args?: Subset<T, OperazioneDescrizazioniCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperazioneDescrizazioniCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperazioneDescrizazioni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperazioneDescrizazioniAggregateArgs>(args: Subset<T, OperazioneDescrizazioniAggregateArgs>): Prisma.PrismaPromise<GetOperazioneDescrizazioniAggregateType<T>>

    /**
     * Group by OperazioneDescrizazioni.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazioneDescrizazioniGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperazioneDescrizazioniGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperazioneDescrizazioniGroupByArgs['orderBy'] }
        : { orderBy?: OperazioneDescrizazioniGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperazioneDescrizazioniGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperazioneDescrizazioniGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperazioneDescrizazioni model
   */
  readonly fields: OperazioneDescrizazioniFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperazioneDescrizazioni.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperazioneDescrizazioniClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperazioneDescrizazioni model
   */
  interface OperazioneDescrizazioniFieldRefs {
    readonly id: FieldRef<"OperazioneDescrizazioni", 'Int'>
    readonly idoperazione: FieldRef<"OperazioneDescrizazioni", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OperazioneDescrizazioni findUnique
   */
  export type OperazioneDescrizazioniFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneDescrizazioni to fetch.
     */
    where: OperazioneDescrizazioniWhereUniqueInput
  }

  /**
   * OperazioneDescrizazioni findUniqueOrThrow
   */
  export type OperazioneDescrizazioniFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneDescrizazioni to fetch.
     */
    where: OperazioneDescrizazioniWhereUniqueInput
  }

  /**
   * OperazioneDescrizazioni findFirst
   */
  export type OperazioneDescrizazioniFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneDescrizazioni to fetch.
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneDescrizazionis to fetch.
     */
    orderBy?: OperazioneDescrizazioniOrderByWithRelationInput | OperazioneDescrizazioniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperazioneDescrizazionis.
     */
    cursor?: OperazioneDescrizazioniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneDescrizazionis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneDescrizazionis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperazioneDescrizazionis.
     */
    distinct?: OperazioneDescrizazioniScalarFieldEnum | OperazioneDescrizazioniScalarFieldEnum[]
  }

  /**
   * OperazioneDescrizazioni findFirstOrThrow
   */
  export type OperazioneDescrizazioniFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneDescrizazioni to fetch.
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneDescrizazionis to fetch.
     */
    orderBy?: OperazioneDescrizazioniOrderByWithRelationInput | OperazioneDescrizazioniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperazioneDescrizazionis.
     */
    cursor?: OperazioneDescrizazioniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneDescrizazionis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneDescrizazionis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperazioneDescrizazionis.
     */
    distinct?: OperazioneDescrizazioniScalarFieldEnum | OperazioneDescrizazioniScalarFieldEnum[]
  }

  /**
   * OperazioneDescrizazioni findMany
   */
  export type OperazioneDescrizazioniFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * Filter, which OperazioneDescrizazionis to fetch.
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazioneDescrizazionis to fetch.
     */
    orderBy?: OperazioneDescrizazioniOrderByWithRelationInput | OperazioneDescrizazioniOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperazioneDescrizazionis.
     */
    cursor?: OperazioneDescrizazioniWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazioneDescrizazionis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazioneDescrizazionis.
     */
    skip?: number
    distinct?: OperazioneDescrizazioniScalarFieldEnum | OperazioneDescrizazioniScalarFieldEnum[]
  }

  /**
   * OperazioneDescrizazioni create
   */
  export type OperazioneDescrizazioniCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * The data needed to create a OperazioneDescrizazioni.
     */
    data?: XOR<OperazioneDescrizazioniCreateInput, OperazioneDescrizazioniUncheckedCreateInput>
  }

  /**
   * OperazioneDescrizazioni createMany
   */
  export type OperazioneDescrizazioniCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperazioneDescrizazionis.
     */
    data: OperazioneDescrizazioniCreateManyInput | OperazioneDescrizazioniCreateManyInput[]
  }

  /**
   * OperazioneDescrizazioni createManyAndReturn
   */
  export type OperazioneDescrizazioniCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * The data used to create many OperazioneDescrizazionis.
     */
    data: OperazioneDescrizazioniCreateManyInput | OperazioneDescrizazioniCreateManyInput[]
  }

  /**
   * OperazioneDescrizazioni update
   */
  export type OperazioneDescrizazioniUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * The data needed to update a OperazioneDescrizazioni.
     */
    data: XOR<OperazioneDescrizazioniUpdateInput, OperazioneDescrizazioniUncheckedUpdateInput>
    /**
     * Choose, which OperazioneDescrizazioni to update.
     */
    where: OperazioneDescrizazioniWhereUniqueInput
  }

  /**
   * OperazioneDescrizazioni updateMany
   */
  export type OperazioneDescrizazioniUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperazioneDescrizazionis.
     */
    data: XOR<OperazioneDescrizazioniUpdateManyMutationInput, OperazioneDescrizazioniUncheckedUpdateManyInput>
    /**
     * Filter which OperazioneDescrizazionis to update
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * Limit how many OperazioneDescrizazionis to update.
     */
    limit?: number
  }

  /**
   * OperazioneDescrizazioni updateManyAndReturn
   */
  export type OperazioneDescrizazioniUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * The data used to update OperazioneDescrizazionis.
     */
    data: XOR<OperazioneDescrizazioniUpdateManyMutationInput, OperazioneDescrizazioniUncheckedUpdateManyInput>
    /**
     * Filter which OperazioneDescrizazionis to update
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * Limit how many OperazioneDescrizazionis to update.
     */
    limit?: number
  }

  /**
   * OperazioneDescrizazioni upsert
   */
  export type OperazioneDescrizazioniUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * The filter to search for the OperazioneDescrizazioni to update in case it exists.
     */
    where: OperazioneDescrizazioniWhereUniqueInput
    /**
     * In case the OperazioneDescrizazioni found by the `where` argument doesn't exist, create a new OperazioneDescrizazioni with this data.
     */
    create: XOR<OperazioneDescrizazioniCreateInput, OperazioneDescrizazioniUncheckedCreateInput>
    /**
     * In case the OperazioneDescrizazioni was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperazioneDescrizazioniUpdateInput, OperazioneDescrizazioniUncheckedUpdateInput>
  }

  /**
   * OperazioneDescrizazioni delete
   */
  export type OperazioneDescrizazioniDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
    /**
     * Filter which OperazioneDescrizazioni to delete.
     */
    where: OperazioneDescrizazioniWhereUniqueInput
  }

  /**
   * OperazioneDescrizazioni deleteMany
   */
  export type OperazioneDescrizazioniDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperazioneDescrizazionis to delete
     */
    where?: OperazioneDescrizazioniWhereInput
    /**
     * Limit how many OperazioneDescrizazionis to delete.
     */
    limit?: number
  }

  /**
   * OperazioneDescrizazioni without action
   */
  export type OperazioneDescrizazioniDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazioneDescrizazioni
     */
    select?: OperazioneDescrizazioniSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazioneDescrizazioni
     */
    omit?: OperazioneDescrizazioniOmit<ExtArgs> | null
  }


  /**
   * Model OperazionePutazione
   */

  export type AggregateOperazionePutazione = {
    _count: OperazionePutazioneCountAggregateOutputType | null
    _avg: OperazionePutazioneAvgAggregateOutputType | null
    _sum: OperazionePutazioneSumAggregateOutputType | null
    _min: OperazionePutazioneMinAggregateOutputType | null
    _max: OperazionePutazioneMaxAggregateOutputType | null
  }

  export type OperazionePutazioneAvgAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazionePutazioneSumAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazionePutazioneMinAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazionePutazioneMaxAggregateOutputType = {
    id: number | null
    idoperazione: number | null
  }

  export type OperazionePutazioneCountAggregateOutputType = {
    id: number
    idoperazione: number
    _all: number
  }


  export type OperazionePutazioneAvgAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazionePutazioneSumAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazionePutazioneMinAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazionePutazioneMaxAggregateInputType = {
    id?: true
    idoperazione?: true
  }

  export type OperazionePutazioneCountAggregateInputType = {
    id?: true
    idoperazione?: true
    _all?: true
  }

  export type OperazionePutazioneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperazionePutazione to aggregate.
     */
    where?: OperazionePutazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazionePutaziones to fetch.
     */
    orderBy?: OperazionePutazioneOrderByWithRelationInput | OperazionePutazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperazionePutazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazionePutaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazionePutaziones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperazionePutaziones
    **/
    _count?: true | OperazionePutazioneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperazionePutazioneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperazionePutazioneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperazionePutazioneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperazionePutazioneMaxAggregateInputType
  }

  export type GetOperazionePutazioneAggregateType<T extends OperazionePutazioneAggregateArgs> = {
        [P in keyof T & keyof AggregateOperazionePutazione]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperazionePutazione[P]>
      : GetScalarType<T[P], AggregateOperazionePutazione[P]>
  }




  export type OperazionePutazioneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperazionePutazioneWhereInput
    orderBy?: OperazionePutazioneOrderByWithAggregationInput | OperazionePutazioneOrderByWithAggregationInput[]
    by: OperazionePutazioneScalarFieldEnum[] | OperazionePutazioneScalarFieldEnum
    having?: OperazionePutazioneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperazionePutazioneCountAggregateInputType | true
    _avg?: OperazionePutazioneAvgAggregateInputType
    _sum?: OperazionePutazioneSumAggregateInputType
    _min?: OperazionePutazioneMinAggregateInputType
    _max?: OperazionePutazioneMaxAggregateInputType
  }

  export type OperazionePutazioneGroupByOutputType = {
    id: number
    idoperazione: number | null
    _count: OperazionePutazioneCountAggregateOutputType | null
    _avg: OperazionePutazioneAvgAggregateOutputType | null
    _sum: OperazionePutazioneSumAggregateOutputType | null
    _min: OperazionePutazioneMinAggregateOutputType | null
    _max: OperazionePutazioneMaxAggregateOutputType | null
  }

  type GetOperazionePutazioneGroupByPayload<T extends OperazionePutazioneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperazionePutazioneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperazionePutazioneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperazionePutazioneGroupByOutputType[P]>
            : GetScalarType<T[P], OperazionePutazioneGroupByOutputType[P]>
        }
      >
    >


  export type OperazionePutazioneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazionePutazione"]>

  export type OperazionePutazioneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazionePutazione"]>

  export type OperazionePutazioneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idoperazione?: boolean
  }, ExtArgs["result"]["operazionePutazione"]>

  export type OperazionePutazioneSelectScalar = {
    id?: boolean
    idoperazione?: boolean
  }

  export type OperazionePutazioneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idoperazione", ExtArgs["result"]["operazionePutazione"]>

  export type $OperazionePutazionePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperazionePutazione"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idoperazione: number | null
    }, ExtArgs["result"]["operazionePutazione"]>
    composites: {}
  }

  type OperazionePutazioneGetPayload<S extends boolean | null | undefined | OperazionePutazioneDefaultArgs> = $Result.GetResult<Prisma.$OperazionePutazionePayload, S>

  type OperazionePutazioneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperazionePutazioneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperazionePutazioneCountAggregateInputType | true
    }

  export interface OperazionePutazioneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperazionePutazione'], meta: { name: 'OperazionePutazione' } }
    /**
     * Find zero or one OperazionePutazione that matches the filter.
     * @param {OperazionePutazioneFindUniqueArgs} args - Arguments to find a OperazionePutazione
     * @example
     * // Get one OperazionePutazione
     * const operazionePutazione = await prisma.operazionePutazione.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperazionePutazioneFindUniqueArgs>(args: SelectSubset<T, OperazionePutazioneFindUniqueArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperazionePutazione that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperazionePutazioneFindUniqueOrThrowArgs} args - Arguments to find a OperazionePutazione
     * @example
     * // Get one OperazionePutazione
     * const operazionePutazione = await prisma.operazionePutazione.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperazionePutazioneFindUniqueOrThrowArgs>(args: SelectSubset<T, OperazionePutazioneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperazionePutazione that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneFindFirstArgs} args - Arguments to find a OperazionePutazione
     * @example
     * // Get one OperazionePutazione
     * const operazionePutazione = await prisma.operazionePutazione.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperazionePutazioneFindFirstArgs>(args?: SelectSubset<T, OperazionePutazioneFindFirstArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperazionePutazione that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneFindFirstOrThrowArgs} args - Arguments to find a OperazionePutazione
     * @example
     * // Get one OperazionePutazione
     * const operazionePutazione = await prisma.operazionePutazione.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperazionePutazioneFindFirstOrThrowArgs>(args?: SelectSubset<T, OperazionePutazioneFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperazionePutaziones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperazionePutaziones
     * const operazionePutaziones = await prisma.operazionePutazione.findMany()
     * 
     * // Get first 10 OperazionePutaziones
     * const operazionePutaziones = await prisma.operazionePutazione.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operazionePutazioneWithIdOnly = await prisma.operazionePutazione.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperazionePutazioneFindManyArgs>(args?: SelectSubset<T, OperazionePutazioneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperazionePutazione.
     * @param {OperazionePutazioneCreateArgs} args - Arguments to create a OperazionePutazione.
     * @example
     * // Create one OperazionePutazione
     * const OperazionePutazione = await prisma.operazionePutazione.create({
     *   data: {
     *     // ... data to create a OperazionePutazione
     *   }
     * })
     * 
     */
    create<T extends OperazionePutazioneCreateArgs>(args: SelectSubset<T, OperazionePutazioneCreateArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperazionePutaziones.
     * @param {OperazionePutazioneCreateManyArgs} args - Arguments to create many OperazionePutaziones.
     * @example
     * // Create many OperazionePutaziones
     * const operazionePutazione = await prisma.operazionePutazione.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperazionePutazioneCreateManyArgs>(args?: SelectSubset<T, OperazionePutazioneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperazionePutaziones and returns the data saved in the database.
     * @param {OperazionePutazioneCreateManyAndReturnArgs} args - Arguments to create many OperazionePutaziones.
     * @example
     * // Create many OperazionePutaziones
     * const operazionePutazione = await prisma.operazionePutazione.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperazionePutaziones and only return the `id`
     * const operazionePutazioneWithIdOnly = await prisma.operazionePutazione.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperazionePutazioneCreateManyAndReturnArgs>(args?: SelectSubset<T, OperazionePutazioneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperazionePutazione.
     * @param {OperazionePutazioneDeleteArgs} args - Arguments to delete one OperazionePutazione.
     * @example
     * // Delete one OperazionePutazione
     * const OperazionePutazione = await prisma.operazionePutazione.delete({
     *   where: {
     *     // ... filter to delete one OperazionePutazione
     *   }
     * })
     * 
     */
    delete<T extends OperazionePutazioneDeleteArgs>(args: SelectSubset<T, OperazionePutazioneDeleteArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperazionePutazione.
     * @param {OperazionePutazioneUpdateArgs} args - Arguments to update one OperazionePutazione.
     * @example
     * // Update one OperazionePutazione
     * const operazionePutazione = await prisma.operazionePutazione.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperazionePutazioneUpdateArgs>(args: SelectSubset<T, OperazionePutazioneUpdateArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperazionePutaziones.
     * @param {OperazionePutazioneDeleteManyArgs} args - Arguments to filter OperazionePutaziones to delete.
     * @example
     * // Delete a few OperazionePutaziones
     * const { count } = await prisma.operazionePutazione.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperazionePutazioneDeleteManyArgs>(args?: SelectSubset<T, OperazionePutazioneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperazionePutaziones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperazionePutaziones
     * const operazionePutazione = await prisma.operazionePutazione.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperazionePutazioneUpdateManyArgs>(args: SelectSubset<T, OperazionePutazioneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperazionePutaziones and returns the data updated in the database.
     * @param {OperazionePutazioneUpdateManyAndReturnArgs} args - Arguments to update many OperazionePutaziones.
     * @example
     * // Update many OperazionePutaziones
     * const operazionePutazione = await prisma.operazionePutazione.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperazionePutaziones and only return the `id`
     * const operazionePutazioneWithIdOnly = await prisma.operazionePutazione.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperazionePutazioneUpdateManyAndReturnArgs>(args: SelectSubset<T, OperazionePutazioneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperazionePutazione.
     * @param {OperazionePutazioneUpsertArgs} args - Arguments to update or create a OperazionePutazione.
     * @example
     * // Update or create a OperazionePutazione
     * const operazionePutazione = await prisma.operazionePutazione.upsert({
     *   create: {
     *     // ... data to create a OperazionePutazione
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperazionePutazione we want to update
     *   }
     * })
     */
    upsert<T extends OperazionePutazioneUpsertArgs>(args: SelectSubset<T, OperazionePutazioneUpsertArgs<ExtArgs>>): Prisma__OperazionePutazioneClient<$Result.GetResult<Prisma.$OperazionePutazionePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperazionePutaziones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneCountArgs} args - Arguments to filter OperazionePutaziones to count.
     * @example
     * // Count the number of OperazionePutaziones
     * const count = await prisma.operazionePutazione.count({
     *   where: {
     *     // ... the filter for the OperazionePutaziones we want to count
     *   }
     * })
    **/
    count<T extends OperazionePutazioneCountArgs>(
      args?: Subset<T, OperazionePutazioneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperazionePutazioneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperazionePutazione.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperazionePutazioneAggregateArgs>(args: Subset<T, OperazionePutazioneAggregateArgs>): Prisma.PrismaPromise<GetOperazionePutazioneAggregateType<T>>

    /**
     * Group by OperazionePutazione.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperazionePutazioneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperazionePutazioneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperazionePutazioneGroupByArgs['orderBy'] }
        : { orderBy?: OperazionePutazioneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperazionePutazioneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperazionePutazioneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperazionePutazione model
   */
  readonly fields: OperazionePutazioneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperazionePutazione.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperazionePutazioneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperazionePutazione model
   */
  interface OperazionePutazioneFieldRefs {
    readonly id: FieldRef<"OperazionePutazione", 'Int'>
    readonly idoperazione: FieldRef<"OperazionePutazione", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OperazionePutazione findUnique
   */
  export type OperazionePutazioneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * Filter, which OperazionePutazione to fetch.
     */
    where: OperazionePutazioneWhereUniqueInput
  }

  /**
   * OperazionePutazione findUniqueOrThrow
   */
  export type OperazionePutazioneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * Filter, which OperazionePutazione to fetch.
     */
    where: OperazionePutazioneWhereUniqueInput
  }

  /**
   * OperazionePutazione findFirst
   */
  export type OperazionePutazioneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * Filter, which OperazionePutazione to fetch.
     */
    where?: OperazionePutazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazionePutaziones to fetch.
     */
    orderBy?: OperazionePutazioneOrderByWithRelationInput | OperazionePutazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperazionePutaziones.
     */
    cursor?: OperazionePutazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazionePutaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazionePutaziones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperazionePutaziones.
     */
    distinct?: OperazionePutazioneScalarFieldEnum | OperazionePutazioneScalarFieldEnum[]
  }

  /**
   * OperazionePutazione findFirstOrThrow
   */
  export type OperazionePutazioneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * Filter, which OperazionePutazione to fetch.
     */
    where?: OperazionePutazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazionePutaziones to fetch.
     */
    orderBy?: OperazionePutazioneOrderByWithRelationInput | OperazionePutazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperazionePutaziones.
     */
    cursor?: OperazionePutazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazionePutaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazionePutaziones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperazionePutaziones.
     */
    distinct?: OperazionePutazioneScalarFieldEnum | OperazionePutazioneScalarFieldEnum[]
  }

  /**
   * OperazionePutazione findMany
   */
  export type OperazionePutazioneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * Filter, which OperazionePutaziones to fetch.
     */
    where?: OperazionePutazioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperazionePutaziones to fetch.
     */
    orderBy?: OperazionePutazioneOrderByWithRelationInput | OperazionePutazioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperazionePutaziones.
     */
    cursor?: OperazionePutazioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperazionePutaziones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperazionePutaziones.
     */
    skip?: number
    distinct?: OperazionePutazioneScalarFieldEnum | OperazionePutazioneScalarFieldEnum[]
  }

  /**
   * OperazionePutazione create
   */
  export type OperazionePutazioneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * The data needed to create a OperazionePutazione.
     */
    data?: XOR<OperazionePutazioneCreateInput, OperazionePutazioneUncheckedCreateInput>
  }

  /**
   * OperazionePutazione createMany
   */
  export type OperazionePutazioneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperazionePutaziones.
     */
    data: OperazionePutazioneCreateManyInput | OperazionePutazioneCreateManyInput[]
  }

  /**
   * OperazionePutazione createManyAndReturn
   */
  export type OperazionePutazioneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * The data used to create many OperazionePutaziones.
     */
    data: OperazionePutazioneCreateManyInput | OperazionePutazioneCreateManyInput[]
  }

  /**
   * OperazionePutazione update
   */
  export type OperazionePutazioneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * The data needed to update a OperazionePutazione.
     */
    data: XOR<OperazionePutazioneUpdateInput, OperazionePutazioneUncheckedUpdateInput>
    /**
     * Choose, which OperazionePutazione to update.
     */
    where: OperazionePutazioneWhereUniqueInput
  }

  /**
   * OperazionePutazione updateMany
   */
  export type OperazionePutazioneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperazionePutaziones.
     */
    data: XOR<OperazionePutazioneUpdateManyMutationInput, OperazionePutazioneUncheckedUpdateManyInput>
    /**
     * Filter which OperazionePutaziones to update
     */
    where?: OperazionePutazioneWhereInput
    /**
     * Limit how many OperazionePutaziones to update.
     */
    limit?: number
  }

  /**
   * OperazionePutazione updateManyAndReturn
   */
  export type OperazionePutazioneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * The data used to update OperazionePutaziones.
     */
    data: XOR<OperazionePutazioneUpdateManyMutationInput, OperazionePutazioneUncheckedUpdateManyInput>
    /**
     * Filter which OperazionePutaziones to update
     */
    where?: OperazionePutazioneWhereInput
    /**
     * Limit how many OperazionePutaziones to update.
     */
    limit?: number
  }

  /**
   * OperazionePutazione upsert
   */
  export type OperazionePutazioneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * The filter to search for the OperazionePutazione to update in case it exists.
     */
    where: OperazionePutazioneWhereUniqueInput
    /**
     * In case the OperazionePutazione found by the `where` argument doesn't exist, create a new OperazionePutazione with this data.
     */
    create: XOR<OperazionePutazioneCreateInput, OperazionePutazioneUncheckedCreateInput>
    /**
     * In case the OperazionePutazione was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperazionePutazioneUpdateInput, OperazionePutazioneUncheckedUpdateInput>
  }

  /**
   * OperazionePutazione delete
   */
  export type OperazionePutazioneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
    /**
     * Filter which OperazionePutazione to delete.
     */
    where: OperazionePutazioneWhereUniqueInput
  }

  /**
   * OperazionePutazione deleteMany
   */
  export type OperazionePutazioneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperazionePutaziones to delete
     */
    where?: OperazionePutazioneWhereInput
    /**
     * Limit how many OperazionePutaziones to delete.
     */
    limit?: number
  }

  /**
   * OperazionePutazione without action
   */
  export type OperazionePutazioneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperazionePutazione
     */
    select?: OperazionePutazioneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperazionePutazione
     */
    omit?: OperazionePutazioneOmit<ExtArgs> | null
  }


  /**
   * Model Prodotto
   */

  export type AggregateProdotto = {
    _count: ProdottoCountAggregateOutputType | null
    _avg: ProdottoAvgAggregateOutputType | null
    _sum: ProdottoSumAggregateOutputType | null
    _min: ProdottoMinAggregateOutputType | null
    _max: ProdottoMaxAggregateOutputType | null
  }

  export type ProdottoAvgAggregateOutputType = {
    id: number | null
  }

  export type ProdottoSumAggregateOutputType = {
    id: number | null
  }

  export type ProdottoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type ProdottoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type ProdottoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type ProdottoAvgAggregateInputType = {
    id?: true
  }

  export type ProdottoSumAggregateInputType = {
    id?: true
  }

  export type ProdottoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type ProdottoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type ProdottoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type ProdottoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prodotto to aggregate.
     */
    where?: ProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prodottos to fetch.
     */
    orderBy?: ProdottoOrderByWithRelationInput | ProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prodottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prodottos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prodottos
    **/
    _count?: true | ProdottoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdottoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdottoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdottoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdottoMaxAggregateInputType
  }

  export type GetProdottoAggregateType<T extends ProdottoAggregateArgs> = {
        [P in keyof T & keyof AggregateProdotto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProdotto[P]>
      : GetScalarType<T[P], AggregateProdotto[P]>
  }




  export type ProdottoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdottoWhereInput
    orderBy?: ProdottoOrderByWithAggregationInput | ProdottoOrderByWithAggregationInput[]
    by: ProdottoScalarFieldEnum[] | ProdottoScalarFieldEnum
    having?: ProdottoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdottoCountAggregateInputType | true
    _avg?: ProdottoAvgAggregateInputType
    _sum?: ProdottoSumAggregateInputType
    _min?: ProdottoMinAggregateInputType
    _max?: ProdottoMaxAggregateInputType
  }

  export type ProdottoGroupByOutputType = {
    id: number
    nome: string | null
    _count: ProdottoCountAggregateOutputType | null
    _avg: ProdottoAvgAggregateOutputType | null
    _sum: ProdottoSumAggregateOutputType | null
    _min: ProdottoMinAggregateOutputType | null
    _max: ProdottoMaxAggregateOutputType | null
  }

  type GetProdottoGroupByPayload<T extends ProdottoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdottoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdottoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdottoGroupByOutputType[P]>
            : GetScalarType<T[P], ProdottoGroupByOutputType[P]>
        }
      >
    >


  export type ProdottoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    voci?: boolean | Prodotto$vociArgs<ExtArgs>
    _count?: boolean | ProdottoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prodotto"]>

  export type ProdottoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["prodotto"]>

  export type ProdottoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["prodotto"]>

  export type ProdottoSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type ProdottoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome", ExtArgs["result"]["prodotto"]>
  export type ProdottoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voci?: boolean | Prodotto$vociArgs<ExtArgs>
    _count?: boolean | ProdottoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProdottoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProdottoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProdottoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prodotto"
    objects: {
      voci: Prisma.$ProdottoVocePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string | null
    }, ExtArgs["result"]["prodotto"]>
    composites: {}
  }

  type ProdottoGetPayload<S extends boolean | null | undefined | ProdottoDefaultArgs> = $Result.GetResult<Prisma.$ProdottoPayload, S>

  type ProdottoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProdottoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProdottoCountAggregateInputType | true
    }

  export interface ProdottoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prodotto'], meta: { name: 'Prodotto' } }
    /**
     * Find zero or one Prodotto that matches the filter.
     * @param {ProdottoFindUniqueArgs} args - Arguments to find a Prodotto
     * @example
     * // Get one Prodotto
     * const prodotto = await prisma.prodotto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProdottoFindUniqueArgs>(args: SelectSubset<T, ProdottoFindUniqueArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prodotto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProdottoFindUniqueOrThrowArgs} args - Arguments to find a Prodotto
     * @example
     * // Get one Prodotto
     * const prodotto = await prisma.prodotto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProdottoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProdottoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prodotto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoFindFirstArgs} args - Arguments to find a Prodotto
     * @example
     * // Get one Prodotto
     * const prodotto = await prisma.prodotto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProdottoFindFirstArgs>(args?: SelectSubset<T, ProdottoFindFirstArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prodotto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoFindFirstOrThrowArgs} args - Arguments to find a Prodotto
     * @example
     * // Get one Prodotto
     * const prodotto = await prisma.prodotto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProdottoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProdottoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prodottos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prodottos
     * const prodottos = await prisma.prodotto.findMany()
     * 
     * // Get first 10 Prodottos
     * const prodottos = await prisma.prodotto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prodottoWithIdOnly = await prisma.prodotto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProdottoFindManyArgs>(args?: SelectSubset<T, ProdottoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prodotto.
     * @param {ProdottoCreateArgs} args - Arguments to create a Prodotto.
     * @example
     * // Create one Prodotto
     * const Prodotto = await prisma.prodotto.create({
     *   data: {
     *     // ... data to create a Prodotto
     *   }
     * })
     * 
     */
    create<T extends ProdottoCreateArgs>(args: SelectSubset<T, ProdottoCreateArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prodottos.
     * @param {ProdottoCreateManyArgs} args - Arguments to create many Prodottos.
     * @example
     * // Create many Prodottos
     * const prodotto = await prisma.prodotto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProdottoCreateManyArgs>(args?: SelectSubset<T, ProdottoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prodottos and returns the data saved in the database.
     * @param {ProdottoCreateManyAndReturnArgs} args - Arguments to create many Prodottos.
     * @example
     * // Create many Prodottos
     * const prodotto = await prisma.prodotto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prodottos and only return the `id`
     * const prodottoWithIdOnly = await prisma.prodotto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProdottoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProdottoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prodotto.
     * @param {ProdottoDeleteArgs} args - Arguments to delete one Prodotto.
     * @example
     * // Delete one Prodotto
     * const Prodotto = await prisma.prodotto.delete({
     *   where: {
     *     // ... filter to delete one Prodotto
     *   }
     * })
     * 
     */
    delete<T extends ProdottoDeleteArgs>(args: SelectSubset<T, ProdottoDeleteArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prodotto.
     * @param {ProdottoUpdateArgs} args - Arguments to update one Prodotto.
     * @example
     * // Update one Prodotto
     * const prodotto = await prisma.prodotto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProdottoUpdateArgs>(args: SelectSubset<T, ProdottoUpdateArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prodottos.
     * @param {ProdottoDeleteManyArgs} args - Arguments to filter Prodottos to delete.
     * @example
     * // Delete a few Prodottos
     * const { count } = await prisma.prodotto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProdottoDeleteManyArgs>(args?: SelectSubset<T, ProdottoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prodottos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prodottos
     * const prodotto = await prisma.prodotto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProdottoUpdateManyArgs>(args: SelectSubset<T, ProdottoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prodottos and returns the data updated in the database.
     * @param {ProdottoUpdateManyAndReturnArgs} args - Arguments to update many Prodottos.
     * @example
     * // Update many Prodottos
     * const prodotto = await prisma.prodotto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prodottos and only return the `id`
     * const prodottoWithIdOnly = await prisma.prodotto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProdottoUpdateManyAndReturnArgs>(args: SelectSubset<T, ProdottoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prodotto.
     * @param {ProdottoUpsertArgs} args - Arguments to update or create a Prodotto.
     * @example
     * // Update or create a Prodotto
     * const prodotto = await prisma.prodotto.upsert({
     *   create: {
     *     // ... data to create a Prodotto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prodotto we want to update
     *   }
     * })
     */
    upsert<T extends ProdottoUpsertArgs>(args: SelectSubset<T, ProdottoUpsertArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prodottos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoCountArgs} args - Arguments to filter Prodottos to count.
     * @example
     * // Count the number of Prodottos
     * const count = await prisma.prodotto.count({
     *   where: {
     *     // ... the filter for the Prodottos we want to count
     *   }
     * })
    **/
    count<T extends ProdottoCountArgs>(
      args?: Subset<T, ProdottoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdottoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prodotto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdottoAggregateArgs>(args: Subset<T, ProdottoAggregateArgs>): Prisma.PrismaPromise<GetProdottoAggregateType<T>>

    /**
     * Group by Prodotto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdottoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdottoGroupByArgs['orderBy'] }
        : { orderBy?: ProdottoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdottoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdottoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prodotto model
   */
  readonly fields: ProdottoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prodotto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdottoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voci<T extends Prodotto$vociArgs<ExtArgs> = {}>(args?: Subset<T, Prodotto$vociArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prodotto model
   */
  interface ProdottoFieldRefs {
    readonly id: FieldRef<"Prodotto", 'Int'>
    readonly nome: FieldRef<"Prodotto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prodotto findUnique
   */
  export type ProdottoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * Filter, which Prodotto to fetch.
     */
    where: ProdottoWhereUniqueInput
  }

  /**
   * Prodotto findUniqueOrThrow
   */
  export type ProdottoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * Filter, which Prodotto to fetch.
     */
    where: ProdottoWhereUniqueInput
  }

  /**
   * Prodotto findFirst
   */
  export type ProdottoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * Filter, which Prodotto to fetch.
     */
    where?: ProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prodottos to fetch.
     */
    orderBy?: ProdottoOrderByWithRelationInput | ProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prodottos.
     */
    cursor?: ProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prodottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prodottos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prodottos.
     */
    distinct?: ProdottoScalarFieldEnum | ProdottoScalarFieldEnum[]
  }

  /**
   * Prodotto findFirstOrThrow
   */
  export type ProdottoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * Filter, which Prodotto to fetch.
     */
    where?: ProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prodottos to fetch.
     */
    orderBy?: ProdottoOrderByWithRelationInput | ProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prodottos.
     */
    cursor?: ProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prodottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prodottos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prodottos.
     */
    distinct?: ProdottoScalarFieldEnum | ProdottoScalarFieldEnum[]
  }

  /**
   * Prodotto findMany
   */
  export type ProdottoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * Filter, which Prodottos to fetch.
     */
    where?: ProdottoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prodottos to fetch.
     */
    orderBy?: ProdottoOrderByWithRelationInput | ProdottoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prodottos.
     */
    cursor?: ProdottoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prodottos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prodottos.
     */
    skip?: number
    distinct?: ProdottoScalarFieldEnum | ProdottoScalarFieldEnum[]
  }

  /**
   * Prodotto create
   */
  export type ProdottoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * The data needed to create a Prodotto.
     */
    data?: XOR<ProdottoCreateInput, ProdottoUncheckedCreateInput>
  }

  /**
   * Prodotto createMany
   */
  export type ProdottoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prodottos.
     */
    data: ProdottoCreateManyInput | ProdottoCreateManyInput[]
  }

  /**
   * Prodotto createManyAndReturn
   */
  export type ProdottoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * The data used to create many Prodottos.
     */
    data: ProdottoCreateManyInput | ProdottoCreateManyInput[]
  }

  /**
   * Prodotto update
   */
  export type ProdottoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * The data needed to update a Prodotto.
     */
    data: XOR<ProdottoUpdateInput, ProdottoUncheckedUpdateInput>
    /**
     * Choose, which Prodotto to update.
     */
    where: ProdottoWhereUniqueInput
  }

  /**
   * Prodotto updateMany
   */
  export type ProdottoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prodottos.
     */
    data: XOR<ProdottoUpdateManyMutationInput, ProdottoUncheckedUpdateManyInput>
    /**
     * Filter which Prodottos to update
     */
    where?: ProdottoWhereInput
    /**
     * Limit how many Prodottos to update.
     */
    limit?: number
  }

  /**
   * Prodotto updateManyAndReturn
   */
  export type ProdottoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * The data used to update Prodottos.
     */
    data: XOR<ProdottoUpdateManyMutationInput, ProdottoUncheckedUpdateManyInput>
    /**
     * Filter which Prodottos to update
     */
    where?: ProdottoWhereInput
    /**
     * Limit how many Prodottos to update.
     */
    limit?: number
  }

  /**
   * Prodotto upsert
   */
  export type ProdottoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * The filter to search for the Prodotto to update in case it exists.
     */
    where: ProdottoWhereUniqueInput
    /**
     * In case the Prodotto found by the `where` argument doesn't exist, create a new Prodotto with this data.
     */
    create: XOR<ProdottoCreateInput, ProdottoUncheckedCreateInput>
    /**
     * In case the Prodotto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdottoUpdateInput, ProdottoUncheckedUpdateInput>
  }

  /**
   * Prodotto delete
   */
  export type ProdottoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    /**
     * Filter which Prodotto to delete.
     */
    where: ProdottoWhereUniqueInput
  }

  /**
   * Prodotto deleteMany
   */
  export type ProdottoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prodottos to delete
     */
    where?: ProdottoWhereInput
    /**
     * Limit how many Prodottos to delete.
     */
    limit?: number
  }

  /**
   * Prodotto.voci
   */
  export type Prodotto$vociArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    where?: ProdottoVoceWhereInput
    orderBy?: ProdottoVoceOrderByWithRelationInput | ProdottoVoceOrderByWithRelationInput[]
    cursor?: ProdottoVoceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProdottoVoceScalarFieldEnum | ProdottoVoceScalarFieldEnum[]
  }

  /**
   * Prodotto without action
   */
  export type ProdottoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
  }


  /**
   * Model ProdottoVoce
   */

  export type AggregateProdottoVoce = {
    _count: ProdottoVoceCountAggregateOutputType | null
    _avg: ProdottoVoceAvgAggregateOutputType | null
    _sum: ProdottoVoceSumAggregateOutputType | null
    _min: ProdottoVoceMinAggregateOutputType | null
    _max: ProdottoVoceMaxAggregateOutputType | null
  }

  export type ProdottoVoceAvgAggregateOutputType = {
    id: number | null
    idprodotto: number | null
  }

  export type ProdottoVoceSumAggregateOutputType = {
    id: number | null
    idprodotto: number | null
  }

  export type ProdottoVoceMinAggregateOutputType = {
    id: number | null
    idprodotto: number | null
  }

  export type ProdottoVoceMaxAggregateOutputType = {
    id: number | null
    idprodotto: number | null
  }

  export type ProdottoVoceCountAggregateOutputType = {
    id: number
    idprodotto: number
    _all: number
  }


  export type ProdottoVoceAvgAggregateInputType = {
    id?: true
    idprodotto?: true
  }

  export type ProdottoVoceSumAggregateInputType = {
    id?: true
    idprodotto?: true
  }

  export type ProdottoVoceMinAggregateInputType = {
    id?: true
    idprodotto?: true
  }

  export type ProdottoVoceMaxAggregateInputType = {
    id?: true
    idprodotto?: true
  }

  export type ProdottoVoceCountAggregateInputType = {
    id?: true
    idprodotto?: true
    _all?: true
  }

  export type ProdottoVoceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProdottoVoce to aggregate.
     */
    where?: ProdottoVoceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdottoVoces to fetch.
     */
    orderBy?: ProdottoVoceOrderByWithRelationInput | ProdottoVoceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProdottoVoceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdottoVoces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdottoVoces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProdottoVoces
    **/
    _count?: true | ProdottoVoceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdottoVoceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdottoVoceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdottoVoceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdottoVoceMaxAggregateInputType
  }

  export type GetProdottoVoceAggregateType<T extends ProdottoVoceAggregateArgs> = {
        [P in keyof T & keyof AggregateProdottoVoce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProdottoVoce[P]>
      : GetScalarType<T[P], AggregateProdottoVoce[P]>
  }




  export type ProdottoVoceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProdottoVoceWhereInput
    orderBy?: ProdottoVoceOrderByWithAggregationInput | ProdottoVoceOrderByWithAggregationInput[]
    by: ProdottoVoceScalarFieldEnum[] | ProdottoVoceScalarFieldEnum
    having?: ProdottoVoceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdottoVoceCountAggregateInputType | true
    _avg?: ProdottoVoceAvgAggregateInputType
    _sum?: ProdottoVoceSumAggregateInputType
    _min?: ProdottoVoceMinAggregateInputType
    _max?: ProdottoVoceMaxAggregateInputType
  }

  export type ProdottoVoceGroupByOutputType = {
    id: number
    idprodotto: number | null
    _count: ProdottoVoceCountAggregateOutputType | null
    _avg: ProdottoVoceAvgAggregateOutputType | null
    _sum: ProdottoVoceSumAggregateOutputType | null
    _min: ProdottoVoceMinAggregateOutputType | null
    _max: ProdottoVoceMaxAggregateOutputType | null
  }

  type GetProdottoVoceGroupByPayload<T extends ProdottoVoceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdottoVoceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdottoVoceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdottoVoceGroupByOutputType[P]>
            : GetScalarType<T[P], ProdottoVoceGroupByOutputType[P]>
        }
      >
    >


  export type ProdottoVoceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idprodotto?: boolean
    prodotto?: boolean | ProdottoVoce$prodottoArgs<ExtArgs>
  }, ExtArgs["result"]["prodottoVoce"]>

  export type ProdottoVoceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idprodotto?: boolean
    prodotto?: boolean | ProdottoVoce$prodottoArgs<ExtArgs>
  }, ExtArgs["result"]["prodottoVoce"]>

  export type ProdottoVoceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idprodotto?: boolean
    prodotto?: boolean | ProdottoVoce$prodottoArgs<ExtArgs>
  }, ExtArgs["result"]["prodottoVoce"]>

  export type ProdottoVoceSelectScalar = {
    id?: boolean
    idprodotto?: boolean
  }

  export type ProdottoVoceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idprodotto", ExtArgs["result"]["prodottoVoce"]>
  export type ProdottoVoceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prodotto?: boolean | ProdottoVoce$prodottoArgs<ExtArgs>
  }
  export type ProdottoVoceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prodotto?: boolean | ProdottoVoce$prodottoArgs<ExtArgs>
  }
  export type ProdottoVoceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prodotto?: boolean | ProdottoVoce$prodottoArgs<ExtArgs>
  }

  export type $ProdottoVocePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProdottoVoce"
    objects: {
      prodotto: Prisma.$ProdottoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idprodotto: number | null
    }, ExtArgs["result"]["prodottoVoce"]>
    composites: {}
  }

  type ProdottoVoceGetPayload<S extends boolean | null | undefined | ProdottoVoceDefaultArgs> = $Result.GetResult<Prisma.$ProdottoVocePayload, S>

  type ProdottoVoceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProdottoVoceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProdottoVoceCountAggregateInputType | true
    }

  export interface ProdottoVoceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProdottoVoce'], meta: { name: 'ProdottoVoce' } }
    /**
     * Find zero or one ProdottoVoce that matches the filter.
     * @param {ProdottoVoceFindUniqueArgs} args - Arguments to find a ProdottoVoce
     * @example
     * // Get one ProdottoVoce
     * const prodottoVoce = await prisma.prodottoVoce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProdottoVoceFindUniqueArgs>(args: SelectSubset<T, ProdottoVoceFindUniqueArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProdottoVoce that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProdottoVoceFindUniqueOrThrowArgs} args - Arguments to find a ProdottoVoce
     * @example
     * // Get one ProdottoVoce
     * const prodottoVoce = await prisma.prodottoVoce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProdottoVoceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProdottoVoceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProdottoVoce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceFindFirstArgs} args - Arguments to find a ProdottoVoce
     * @example
     * // Get one ProdottoVoce
     * const prodottoVoce = await prisma.prodottoVoce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProdottoVoceFindFirstArgs>(args?: SelectSubset<T, ProdottoVoceFindFirstArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProdottoVoce that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceFindFirstOrThrowArgs} args - Arguments to find a ProdottoVoce
     * @example
     * // Get one ProdottoVoce
     * const prodottoVoce = await prisma.prodottoVoce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProdottoVoceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProdottoVoceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProdottoVoces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProdottoVoces
     * const prodottoVoces = await prisma.prodottoVoce.findMany()
     * 
     * // Get first 10 ProdottoVoces
     * const prodottoVoces = await prisma.prodottoVoce.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prodottoVoceWithIdOnly = await prisma.prodottoVoce.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProdottoVoceFindManyArgs>(args?: SelectSubset<T, ProdottoVoceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProdottoVoce.
     * @param {ProdottoVoceCreateArgs} args - Arguments to create a ProdottoVoce.
     * @example
     * // Create one ProdottoVoce
     * const ProdottoVoce = await prisma.prodottoVoce.create({
     *   data: {
     *     // ... data to create a ProdottoVoce
     *   }
     * })
     * 
     */
    create<T extends ProdottoVoceCreateArgs>(args: SelectSubset<T, ProdottoVoceCreateArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProdottoVoces.
     * @param {ProdottoVoceCreateManyArgs} args - Arguments to create many ProdottoVoces.
     * @example
     * // Create many ProdottoVoces
     * const prodottoVoce = await prisma.prodottoVoce.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProdottoVoceCreateManyArgs>(args?: SelectSubset<T, ProdottoVoceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProdottoVoces and returns the data saved in the database.
     * @param {ProdottoVoceCreateManyAndReturnArgs} args - Arguments to create many ProdottoVoces.
     * @example
     * // Create many ProdottoVoces
     * const prodottoVoce = await prisma.prodottoVoce.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProdottoVoces and only return the `id`
     * const prodottoVoceWithIdOnly = await prisma.prodottoVoce.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProdottoVoceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProdottoVoceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProdottoVoce.
     * @param {ProdottoVoceDeleteArgs} args - Arguments to delete one ProdottoVoce.
     * @example
     * // Delete one ProdottoVoce
     * const ProdottoVoce = await prisma.prodottoVoce.delete({
     *   where: {
     *     // ... filter to delete one ProdottoVoce
     *   }
     * })
     * 
     */
    delete<T extends ProdottoVoceDeleteArgs>(args: SelectSubset<T, ProdottoVoceDeleteArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProdottoVoce.
     * @param {ProdottoVoceUpdateArgs} args - Arguments to update one ProdottoVoce.
     * @example
     * // Update one ProdottoVoce
     * const prodottoVoce = await prisma.prodottoVoce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProdottoVoceUpdateArgs>(args: SelectSubset<T, ProdottoVoceUpdateArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProdottoVoces.
     * @param {ProdottoVoceDeleteManyArgs} args - Arguments to filter ProdottoVoces to delete.
     * @example
     * // Delete a few ProdottoVoces
     * const { count } = await prisma.prodottoVoce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProdottoVoceDeleteManyArgs>(args?: SelectSubset<T, ProdottoVoceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProdottoVoces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProdottoVoces
     * const prodottoVoce = await prisma.prodottoVoce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProdottoVoceUpdateManyArgs>(args: SelectSubset<T, ProdottoVoceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProdottoVoces and returns the data updated in the database.
     * @param {ProdottoVoceUpdateManyAndReturnArgs} args - Arguments to update many ProdottoVoces.
     * @example
     * // Update many ProdottoVoces
     * const prodottoVoce = await prisma.prodottoVoce.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProdottoVoces and only return the `id`
     * const prodottoVoceWithIdOnly = await prisma.prodottoVoce.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProdottoVoceUpdateManyAndReturnArgs>(args: SelectSubset<T, ProdottoVoceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProdottoVoce.
     * @param {ProdottoVoceUpsertArgs} args - Arguments to update or create a ProdottoVoce.
     * @example
     * // Update or create a ProdottoVoce
     * const prodottoVoce = await prisma.prodottoVoce.upsert({
     *   create: {
     *     // ... data to create a ProdottoVoce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProdottoVoce we want to update
     *   }
     * })
     */
    upsert<T extends ProdottoVoceUpsertArgs>(args: SelectSubset<T, ProdottoVoceUpsertArgs<ExtArgs>>): Prisma__ProdottoVoceClient<$Result.GetResult<Prisma.$ProdottoVocePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProdottoVoces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceCountArgs} args - Arguments to filter ProdottoVoces to count.
     * @example
     * // Count the number of ProdottoVoces
     * const count = await prisma.prodottoVoce.count({
     *   where: {
     *     // ... the filter for the ProdottoVoces we want to count
     *   }
     * })
    **/
    count<T extends ProdottoVoceCountArgs>(
      args?: Subset<T, ProdottoVoceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdottoVoceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProdottoVoce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdottoVoceAggregateArgs>(args: Subset<T, ProdottoVoceAggregateArgs>): Prisma.PrismaPromise<GetProdottoVoceAggregateType<T>>

    /**
     * Group by ProdottoVoce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdottoVoceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdottoVoceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdottoVoceGroupByArgs['orderBy'] }
        : { orderBy?: ProdottoVoceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdottoVoceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdottoVoceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProdottoVoce model
   */
  readonly fields: ProdottoVoceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProdottoVoce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProdottoVoceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prodotto<T extends ProdottoVoce$prodottoArgs<ExtArgs> = {}>(args?: Subset<T, ProdottoVoce$prodottoArgs<ExtArgs>>): Prisma__ProdottoClient<$Result.GetResult<Prisma.$ProdottoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProdottoVoce model
   */
  interface ProdottoVoceFieldRefs {
    readonly id: FieldRef<"ProdottoVoce", 'Int'>
    readonly idprodotto: FieldRef<"ProdottoVoce", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProdottoVoce findUnique
   */
  export type ProdottoVoceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * Filter, which ProdottoVoce to fetch.
     */
    where: ProdottoVoceWhereUniqueInput
  }

  /**
   * ProdottoVoce findUniqueOrThrow
   */
  export type ProdottoVoceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * Filter, which ProdottoVoce to fetch.
     */
    where: ProdottoVoceWhereUniqueInput
  }

  /**
   * ProdottoVoce findFirst
   */
  export type ProdottoVoceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * Filter, which ProdottoVoce to fetch.
     */
    where?: ProdottoVoceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdottoVoces to fetch.
     */
    orderBy?: ProdottoVoceOrderByWithRelationInput | ProdottoVoceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProdottoVoces.
     */
    cursor?: ProdottoVoceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdottoVoces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdottoVoces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProdottoVoces.
     */
    distinct?: ProdottoVoceScalarFieldEnum | ProdottoVoceScalarFieldEnum[]
  }

  /**
   * ProdottoVoce findFirstOrThrow
   */
  export type ProdottoVoceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * Filter, which ProdottoVoce to fetch.
     */
    where?: ProdottoVoceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdottoVoces to fetch.
     */
    orderBy?: ProdottoVoceOrderByWithRelationInput | ProdottoVoceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProdottoVoces.
     */
    cursor?: ProdottoVoceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdottoVoces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdottoVoces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProdottoVoces.
     */
    distinct?: ProdottoVoceScalarFieldEnum | ProdottoVoceScalarFieldEnum[]
  }

  /**
   * ProdottoVoce findMany
   */
  export type ProdottoVoceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * Filter, which ProdottoVoces to fetch.
     */
    where?: ProdottoVoceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProdottoVoces to fetch.
     */
    orderBy?: ProdottoVoceOrderByWithRelationInput | ProdottoVoceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProdottoVoces.
     */
    cursor?: ProdottoVoceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProdottoVoces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProdottoVoces.
     */
    skip?: number
    distinct?: ProdottoVoceScalarFieldEnum | ProdottoVoceScalarFieldEnum[]
  }

  /**
   * ProdottoVoce create
   */
  export type ProdottoVoceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProdottoVoce.
     */
    data?: XOR<ProdottoVoceCreateInput, ProdottoVoceUncheckedCreateInput>
  }

  /**
   * ProdottoVoce createMany
   */
  export type ProdottoVoceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProdottoVoces.
     */
    data: ProdottoVoceCreateManyInput | ProdottoVoceCreateManyInput[]
  }

  /**
   * ProdottoVoce createManyAndReturn
   */
  export type ProdottoVoceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * The data used to create many ProdottoVoces.
     */
    data: ProdottoVoceCreateManyInput | ProdottoVoceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProdottoVoce update
   */
  export type ProdottoVoceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProdottoVoce.
     */
    data: XOR<ProdottoVoceUpdateInput, ProdottoVoceUncheckedUpdateInput>
    /**
     * Choose, which ProdottoVoce to update.
     */
    where: ProdottoVoceWhereUniqueInput
  }

  /**
   * ProdottoVoce updateMany
   */
  export type ProdottoVoceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProdottoVoces.
     */
    data: XOR<ProdottoVoceUpdateManyMutationInput, ProdottoVoceUncheckedUpdateManyInput>
    /**
     * Filter which ProdottoVoces to update
     */
    where?: ProdottoVoceWhereInput
    /**
     * Limit how many ProdottoVoces to update.
     */
    limit?: number
  }

  /**
   * ProdottoVoce updateManyAndReturn
   */
  export type ProdottoVoceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * The data used to update ProdottoVoces.
     */
    data: XOR<ProdottoVoceUpdateManyMutationInput, ProdottoVoceUncheckedUpdateManyInput>
    /**
     * Filter which ProdottoVoces to update
     */
    where?: ProdottoVoceWhereInput
    /**
     * Limit how many ProdottoVoces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProdottoVoce upsert
   */
  export type ProdottoVoceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProdottoVoce to update in case it exists.
     */
    where: ProdottoVoceWhereUniqueInput
    /**
     * In case the ProdottoVoce found by the `where` argument doesn't exist, create a new ProdottoVoce with this data.
     */
    create: XOR<ProdottoVoceCreateInput, ProdottoVoceUncheckedCreateInput>
    /**
     * In case the ProdottoVoce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProdottoVoceUpdateInput, ProdottoVoceUncheckedUpdateInput>
  }

  /**
   * ProdottoVoce delete
   */
  export type ProdottoVoceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
    /**
     * Filter which ProdottoVoce to delete.
     */
    where: ProdottoVoceWhereUniqueInput
  }

  /**
   * ProdottoVoce deleteMany
   */
  export type ProdottoVoceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProdottoVoces to delete
     */
    where?: ProdottoVoceWhereInput
    /**
     * Limit how many ProdottoVoces to delete.
     */
    limit?: number
  }

  /**
   * ProdottoVoce.prodotto
   */
  export type ProdottoVoce$prodottoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prodotto
     */
    select?: ProdottoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prodotto
     */
    omit?: ProdottoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoInclude<ExtArgs> | null
    where?: ProdottoWhereInput
  }

  /**
   * ProdottoVoce without action
   */
  export type ProdottoVoceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProdottoVoce
     */
    select?: ProdottoVoceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProdottoVoce
     */
    omit?: ProdottoVoceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProdottoVoceInclude<ExtArgs> | null
  }


  /**
   * Model Contratto
   */

  export type AggregateContratto = {
    _count: ContrattoCountAggregateOutputType | null
    _avg: ContrattoAvgAggregateOutputType | null
    _sum: ContrattoSumAggregateOutputType | null
    _min: ContrattoMinAggregateOutputType | null
    _max: ContrattoMaxAggregateOutputType | null
  }

  export type ContrattoAvgAggregateOutputType = {
    id: number | null
    tipo: number | null
    durata: number | null
    avvprima: number | null
    avvdopo: number | null
  }

  export type ContrattoSumAggregateOutputType = {
    id: number | null
    tipo: number | null
    durata: number | null
    avvprima: number | null
    avvdopo: number | null
  }

  export type ContrattoMinAggregateOutputType = {
    id: number | null
    tipo: number | null
    denominazione: string | null
    tipodurata: string | null
    durata: number | null
    avvprima: number | null
    avvdopo: number | null
    cancellato: string | null
  }

  export type ContrattoMaxAggregateOutputType = {
    id: number | null
    tipo: number | null
    denominazione: string | null
    tipodurata: string | null
    durata: number | null
    avvprima: number | null
    avvdopo: number | null
    cancellato: string | null
  }

  export type ContrattoCountAggregateOutputType = {
    id: number
    tipo: number
    denominazione: number
    tipodurata: number
    durata: number
    avvprima: number
    avvdopo: number
    cancellato: number
    _all: number
  }


  export type ContrattoAvgAggregateInputType = {
    id?: true
    tipo?: true
    durata?: true
    avvprima?: true
    avvdopo?: true
  }

  export type ContrattoSumAggregateInputType = {
    id?: true
    tipo?: true
    durata?: true
    avvprima?: true
    avvdopo?: true
  }

  export type ContrattoMinAggregateInputType = {
    id?: true
    tipo?: true
    denominazione?: true
    tipodurata?: true
    durata?: true
    avvprima?: true
    avvdopo?: true
    cancellato?: true
  }

  export type ContrattoMaxAggregateInputType = {
    id?: true
    tipo?: true
    denominazione?: true
    tipodurata?: true
    durata?: true
    avvprima?: true
    avvdopo?: true
    cancellato?: true
  }

  export type ContrattoCountAggregateInputType = {
    id?: true
    tipo?: true
    denominazione?: true
    tipodurata?: true
    durata?: true
    avvprima?: true
    avvdopo?: true
    cancellato?: true
    _all?: true
  }

  export type ContrattoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contratto to aggregate.
     */
    where?: ContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrattos to fetch.
     */
    orderBy?: ContrattoOrderByWithRelationInput | ContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contrattos
    **/
    _count?: true | ContrattoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContrattoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContrattoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContrattoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContrattoMaxAggregateInputType
  }

  export type GetContrattoAggregateType<T extends ContrattoAggregateArgs> = {
        [P in keyof T & keyof AggregateContratto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContratto[P]>
      : GetScalarType<T[P], AggregateContratto[P]>
  }




  export type ContrattoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContrattoWhereInput
    orderBy?: ContrattoOrderByWithAggregationInput | ContrattoOrderByWithAggregationInput[]
    by: ContrattoScalarFieldEnum[] | ContrattoScalarFieldEnum
    having?: ContrattoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContrattoCountAggregateInputType | true
    _avg?: ContrattoAvgAggregateInputType
    _sum?: ContrattoSumAggregateInputType
    _min?: ContrattoMinAggregateInputType
    _max?: ContrattoMaxAggregateInputType
  }

  export type ContrattoGroupByOutputType = {
    id: number
    tipo: number | null
    denominazione: string | null
    tipodurata: string | null
    durata: number | null
    avvprima: number | null
    avvdopo: number | null
    cancellato: string | null
    _count: ContrattoCountAggregateOutputType | null
    _avg: ContrattoAvgAggregateOutputType | null
    _sum: ContrattoSumAggregateOutputType | null
    _min: ContrattoMinAggregateOutputType | null
    _max: ContrattoMaxAggregateOutputType | null
  }

  type GetContrattoGroupByPayload<T extends ContrattoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContrattoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContrattoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContrattoGroupByOutputType[P]>
            : GetScalarType<T[P], ContrattoGroupByOutputType[P]>
        }
      >
    >


  export type ContrattoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    denominazione?: boolean
    tipodurata?: boolean
    durata?: boolean
    avvprima?: boolean
    avvdopo?: boolean
    cancellato?: boolean
  }, ExtArgs["result"]["contratto"]>

  export type ContrattoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    denominazione?: boolean
    tipodurata?: boolean
    durata?: boolean
    avvprima?: boolean
    avvdopo?: boolean
    cancellato?: boolean
  }, ExtArgs["result"]["contratto"]>

  export type ContrattoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    denominazione?: boolean
    tipodurata?: boolean
    durata?: boolean
    avvprima?: boolean
    avvdopo?: boolean
    cancellato?: boolean
  }, ExtArgs["result"]["contratto"]>

  export type ContrattoSelectScalar = {
    id?: boolean
    tipo?: boolean
    denominazione?: boolean
    tipodurata?: boolean
    durata?: boolean
    avvprima?: boolean
    avvdopo?: boolean
    cancellato?: boolean
  }

  export type ContrattoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "denominazione" | "tipodurata" | "durata" | "avvprima" | "avvdopo" | "cancellato", ExtArgs["result"]["contratto"]>

  export type $ContrattoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contratto"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: number | null
      denominazione: string | null
      tipodurata: string | null
      durata: number | null
      avvprima: number | null
      avvdopo: number | null
      cancellato: string | null
    }, ExtArgs["result"]["contratto"]>
    composites: {}
  }

  type ContrattoGetPayload<S extends boolean | null | undefined | ContrattoDefaultArgs> = $Result.GetResult<Prisma.$ContrattoPayload, S>

  type ContrattoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContrattoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContrattoCountAggregateInputType | true
    }

  export interface ContrattoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contratto'], meta: { name: 'Contratto' } }
    /**
     * Find zero or one Contratto that matches the filter.
     * @param {ContrattoFindUniqueArgs} args - Arguments to find a Contratto
     * @example
     * // Get one Contratto
     * const contratto = await prisma.contratto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContrattoFindUniqueArgs>(args: SelectSubset<T, ContrattoFindUniqueArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contratto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContrattoFindUniqueOrThrowArgs} args - Arguments to find a Contratto
     * @example
     * // Get one Contratto
     * const contratto = await prisma.contratto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContrattoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContrattoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contratto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoFindFirstArgs} args - Arguments to find a Contratto
     * @example
     * // Get one Contratto
     * const contratto = await prisma.contratto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContrattoFindFirstArgs>(args?: SelectSubset<T, ContrattoFindFirstArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contratto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoFindFirstOrThrowArgs} args - Arguments to find a Contratto
     * @example
     * // Get one Contratto
     * const contratto = await prisma.contratto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContrattoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContrattoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contrattos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contrattos
     * const contrattos = await prisma.contratto.findMany()
     * 
     * // Get first 10 Contrattos
     * const contrattos = await prisma.contratto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contrattoWithIdOnly = await prisma.contratto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContrattoFindManyArgs>(args?: SelectSubset<T, ContrattoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contratto.
     * @param {ContrattoCreateArgs} args - Arguments to create a Contratto.
     * @example
     * // Create one Contratto
     * const Contratto = await prisma.contratto.create({
     *   data: {
     *     // ... data to create a Contratto
     *   }
     * })
     * 
     */
    create<T extends ContrattoCreateArgs>(args: SelectSubset<T, ContrattoCreateArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contrattos.
     * @param {ContrattoCreateManyArgs} args - Arguments to create many Contrattos.
     * @example
     * // Create many Contrattos
     * const contratto = await prisma.contratto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContrattoCreateManyArgs>(args?: SelectSubset<T, ContrattoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contrattos and returns the data saved in the database.
     * @param {ContrattoCreateManyAndReturnArgs} args - Arguments to create many Contrattos.
     * @example
     * // Create many Contrattos
     * const contratto = await prisma.contratto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contrattos and only return the `id`
     * const contrattoWithIdOnly = await prisma.contratto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContrattoCreateManyAndReturnArgs>(args?: SelectSubset<T, ContrattoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contratto.
     * @param {ContrattoDeleteArgs} args - Arguments to delete one Contratto.
     * @example
     * // Delete one Contratto
     * const Contratto = await prisma.contratto.delete({
     *   where: {
     *     // ... filter to delete one Contratto
     *   }
     * })
     * 
     */
    delete<T extends ContrattoDeleteArgs>(args: SelectSubset<T, ContrattoDeleteArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contratto.
     * @param {ContrattoUpdateArgs} args - Arguments to update one Contratto.
     * @example
     * // Update one Contratto
     * const contratto = await prisma.contratto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContrattoUpdateArgs>(args: SelectSubset<T, ContrattoUpdateArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contrattos.
     * @param {ContrattoDeleteManyArgs} args - Arguments to filter Contrattos to delete.
     * @example
     * // Delete a few Contrattos
     * const { count } = await prisma.contratto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContrattoDeleteManyArgs>(args?: SelectSubset<T, ContrattoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contrattos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contrattos
     * const contratto = await prisma.contratto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContrattoUpdateManyArgs>(args: SelectSubset<T, ContrattoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contrattos and returns the data updated in the database.
     * @param {ContrattoUpdateManyAndReturnArgs} args - Arguments to update many Contrattos.
     * @example
     * // Update many Contrattos
     * const contratto = await prisma.contratto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contrattos and only return the `id`
     * const contrattoWithIdOnly = await prisma.contratto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContrattoUpdateManyAndReturnArgs>(args: SelectSubset<T, ContrattoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contratto.
     * @param {ContrattoUpsertArgs} args - Arguments to update or create a Contratto.
     * @example
     * // Update or create a Contratto
     * const contratto = await prisma.contratto.upsert({
     *   create: {
     *     // ... data to create a Contratto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contratto we want to update
     *   }
     * })
     */
    upsert<T extends ContrattoUpsertArgs>(args: SelectSubset<T, ContrattoUpsertArgs<ExtArgs>>): Prisma__ContrattoClient<$Result.GetResult<Prisma.$ContrattoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contrattos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoCountArgs} args - Arguments to filter Contrattos to count.
     * @example
     * // Count the number of Contrattos
     * const count = await prisma.contratto.count({
     *   where: {
     *     // ... the filter for the Contrattos we want to count
     *   }
     * })
    **/
    count<T extends ContrattoCountArgs>(
      args?: Subset<T, ContrattoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContrattoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contratto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContrattoAggregateArgs>(args: Subset<T, ContrattoAggregateArgs>): Prisma.PrismaPromise<GetContrattoAggregateType<T>>

    /**
     * Group by Contratto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContrattoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContrattoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContrattoGroupByArgs['orderBy'] }
        : { orderBy?: ContrattoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContrattoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContrattoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contratto model
   */
  readonly fields: ContrattoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contratto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContrattoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contratto model
   */
  interface ContrattoFieldRefs {
    readonly id: FieldRef<"Contratto", 'Int'>
    readonly tipo: FieldRef<"Contratto", 'Int'>
    readonly denominazione: FieldRef<"Contratto", 'String'>
    readonly tipodurata: FieldRef<"Contratto", 'String'>
    readonly durata: FieldRef<"Contratto", 'Int'>
    readonly avvprima: FieldRef<"Contratto", 'Int'>
    readonly avvdopo: FieldRef<"Contratto", 'Int'>
    readonly cancellato: FieldRef<"Contratto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contratto findUnique
   */
  export type ContrattoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * Filter, which Contratto to fetch.
     */
    where: ContrattoWhereUniqueInput
  }

  /**
   * Contratto findUniqueOrThrow
   */
  export type ContrattoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * Filter, which Contratto to fetch.
     */
    where: ContrattoWhereUniqueInput
  }

  /**
   * Contratto findFirst
   */
  export type ContrattoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * Filter, which Contratto to fetch.
     */
    where?: ContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrattos to fetch.
     */
    orderBy?: ContrattoOrderByWithRelationInput | ContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contrattos.
     */
    cursor?: ContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contrattos.
     */
    distinct?: ContrattoScalarFieldEnum | ContrattoScalarFieldEnum[]
  }

  /**
   * Contratto findFirstOrThrow
   */
  export type ContrattoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * Filter, which Contratto to fetch.
     */
    where?: ContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrattos to fetch.
     */
    orderBy?: ContrattoOrderByWithRelationInput | ContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contrattos.
     */
    cursor?: ContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrattos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contrattos.
     */
    distinct?: ContrattoScalarFieldEnum | ContrattoScalarFieldEnum[]
  }

  /**
   * Contratto findMany
   */
  export type ContrattoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * Filter, which Contrattos to fetch.
     */
    where?: ContrattoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrattos to fetch.
     */
    orderBy?: ContrattoOrderByWithRelationInput | ContrattoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contrattos.
     */
    cursor?: ContrattoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrattos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrattos.
     */
    skip?: number
    distinct?: ContrattoScalarFieldEnum | ContrattoScalarFieldEnum[]
  }

  /**
   * Contratto create
   */
  export type ContrattoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * The data needed to create a Contratto.
     */
    data?: XOR<ContrattoCreateInput, ContrattoUncheckedCreateInput>
  }

  /**
   * Contratto createMany
   */
  export type ContrattoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contrattos.
     */
    data: ContrattoCreateManyInput | ContrattoCreateManyInput[]
  }

  /**
   * Contratto createManyAndReturn
   */
  export type ContrattoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * The data used to create many Contrattos.
     */
    data: ContrattoCreateManyInput | ContrattoCreateManyInput[]
  }

  /**
   * Contratto update
   */
  export type ContrattoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * The data needed to update a Contratto.
     */
    data: XOR<ContrattoUpdateInput, ContrattoUncheckedUpdateInput>
    /**
     * Choose, which Contratto to update.
     */
    where: ContrattoWhereUniqueInput
  }

  /**
   * Contratto updateMany
   */
  export type ContrattoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contrattos.
     */
    data: XOR<ContrattoUpdateManyMutationInput, ContrattoUncheckedUpdateManyInput>
    /**
     * Filter which Contrattos to update
     */
    where?: ContrattoWhereInput
    /**
     * Limit how many Contrattos to update.
     */
    limit?: number
  }

  /**
   * Contratto updateManyAndReturn
   */
  export type ContrattoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * The data used to update Contrattos.
     */
    data: XOR<ContrattoUpdateManyMutationInput, ContrattoUncheckedUpdateManyInput>
    /**
     * Filter which Contrattos to update
     */
    where?: ContrattoWhereInput
    /**
     * Limit how many Contrattos to update.
     */
    limit?: number
  }

  /**
   * Contratto upsert
   */
  export type ContrattoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * The filter to search for the Contratto to update in case it exists.
     */
    where: ContrattoWhereUniqueInput
    /**
     * In case the Contratto found by the `where` argument doesn't exist, create a new Contratto with this data.
     */
    create: XOR<ContrattoCreateInput, ContrattoUncheckedCreateInput>
    /**
     * In case the Contratto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContrattoUpdateInput, ContrattoUncheckedUpdateInput>
  }

  /**
   * Contratto delete
   */
  export type ContrattoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
    /**
     * Filter which Contratto to delete.
     */
    where: ContrattoWhereUniqueInput
  }

  /**
   * Contratto deleteMany
   */
  export type ContrattoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contrattos to delete
     */
    where?: ContrattoWhereInput
    /**
     * Limit how many Contrattos to delete.
     */
    limit?: number
  }

  /**
   * Contratto without action
   */
  export type ContrattoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contratto
     */
    select?: ContrattoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contratto
     */
    omit?: ContrattoOmit<ExtArgs> | null
  }


  /**
   * Model PianningTipoIntervento
   */

  export type AggregatePianningTipoIntervento = {
    _count: PianningTipoInterventoCountAggregateOutputType | null
    _avg: PianningTipoInterventoAvgAggregateOutputType | null
    _sum: PianningTipoInterventoSumAggregateOutputType | null
    _min: PianningTipoInterventoMinAggregateOutputType | null
    _max: PianningTipoInterventoMaxAggregateOutputType | null
  }

  export type PianningTipoInterventoAvgAggregateOutputType = {
    id: number | null
  }

  export type PianningTipoInterventoSumAggregateOutputType = {
    id: number | null
  }

  export type PianningTipoInterventoMinAggregateOutputType = {
    id: number | null
  }

  export type PianningTipoInterventoMaxAggregateOutputType = {
    id: number | null
  }

  export type PianningTipoInterventoCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type PianningTipoInterventoAvgAggregateInputType = {
    id?: true
  }

  export type PianningTipoInterventoSumAggregateInputType = {
    id?: true
  }

  export type PianningTipoInterventoMinAggregateInputType = {
    id?: true
  }

  export type PianningTipoInterventoMaxAggregateInputType = {
    id?: true
  }

  export type PianningTipoInterventoCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type PianningTipoInterventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PianningTipoIntervento to aggregate.
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningTipoInterventos to fetch.
     */
    orderBy?: PianningTipoInterventoOrderByWithRelationInput | PianningTipoInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PianningTipoInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningTipoInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningTipoInterventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PianningTipoInterventos
    **/
    _count?: true | PianningTipoInterventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PianningTipoInterventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PianningTipoInterventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PianningTipoInterventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PianningTipoInterventoMaxAggregateInputType
  }

  export type GetPianningTipoInterventoAggregateType<T extends PianningTipoInterventoAggregateArgs> = {
        [P in keyof T & keyof AggregatePianningTipoIntervento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePianningTipoIntervento[P]>
      : GetScalarType<T[P], AggregatePianningTipoIntervento[P]>
  }




  export type PianningTipoInterventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PianningTipoInterventoWhereInput
    orderBy?: PianningTipoInterventoOrderByWithAggregationInput | PianningTipoInterventoOrderByWithAggregationInput[]
    by: PianningTipoInterventoScalarFieldEnum[] | PianningTipoInterventoScalarFieldEnum
    having?: PianningTipoInterventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PianningTipoInterventoCountAggregateInputType | true
    _avg?: PianningTipoInterventoAvgAggregateInputType
    _sum?: PianningTipoInterventoSumAggregateInputType
    _min?: PianningTipoInterventoMinAggregateInputType
    _max?: PianningTipoInterventoMaxAggregateInputType
  }

  export type PianningTipoInterventoGroupByOutputType = {
    id: number
    _count: PianningTipoInterventoCountAggregateOutputType | null
    _avg: PianningTipoInterventoAvgAggregateOutputType | null
    _sum: PianningTipoInterventoSumAggregateOutputType | null
    _min: PianningTipoInterventoMinAggregateOutputType | null
    _max: PianningTipoInterventoMaxAggregateOutputType | null
  }

  type GetPianningTipoInterventoGroupByPayload<T extends PianningTipoInterventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PianningTipoInterventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PianningTipoInterventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PianningTipoInterventoGroupByOutputType[P]>
            : GetScalarType<T[P], PianningTipoInterventoGroupByOutputType[P]>
        }
      >
    >


  export type PianningTipoInterventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["pianningTipoIntervento"]>

  export type PianningTipoInterventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["pianningTipoIntervento"]>

  export type PianningTipoInterventoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["pianningTipoIntervento"]>

  export type PianningTipoInterventoSelectScalar = {
    id?: boolean
  }

  export type PianningTipoInterventoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["pianningTipoIntervento"]>

  export type $PianningTipoInterventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PianningTipoIntervento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["pianningTipoIntervento"]>
    composites: {}
  }

  type PianningTipoInterventoGetPayload<S extends boolean | null | undefined | PianningTipoInterventoDefaultArgs> = $Result.GetResult<Prisma.$PianningTipoInterventoPayload, S>

  type PianningTipoInterventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PianningTipoInterventoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PianningTipoInterventoCountAggregateInputType | true
    }

  export interface PianningTipoInterventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PianningTipoIntervento'], meta: { name: 'PianningTipoIntervento' } }
    /**
     * Find zero or one PianningTipoIntervento that matches the filter.
     * @param {PianningTipoInterventoFindUniqueArgs} args - Arguments to find a PianningTipoIntervento
     * @example
     * // Get one PianningTipoIntervento
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PianningTipoInterventoFindUniqueArgs>(args: SelectSubset<T, PianningTipoInterventoFindUniqueArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PianningTipoIntervento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PianningTipoInterventoFindUniqueOrThrowArgs} args - Arguments to find a PianningTipoIntervento
     * @example
     * // Get one PianningTipoIntervento
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PianningTipoInterventoFindUniqueOrThrowArgs>(args: SelectSubset<T, PianningTipoInterventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PianningTipoIntervento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoFindFirstArgs} args - Arguments to find a PianningTipoIntervento
     * @example
     * // Get one PianningTipoIntervento
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PianningTipoInterventoFindFirstArgs>(args?: SelectSubset<T, PianningTipoInterventoFindFirstArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PianningTipoIntervento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoFindFirstOrThrowArgs} args - Arguments to find a PianningTipoIntervento
     * @example
     * // Get one PianningTipoIntervento
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PianningTipoInterventoFindFirstOrThrowArgs>(args?: SelectSubset<T, PianningTipoInterventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PianningTipoInterventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PianningTipoInterventos
     * const pianningTipoInterventos = await prisma.pianningTipoIntervento.findMany()
     * 
     * // Get first 10 PianningTipoInterventos
     * const pianningTipoInterventos = await prisma.pianningTipoIntervento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pianningTipoInterventoWithIdOnly = await prisma.pianningTipoIntervento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PianningTipoInterventoFindManyArgs>(args?: SelectSubset<T, PianningTipoInterventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PianningTipoIntervento.
     * @param {PianningTipoInterventoCreateArgs} args - Arguments to create a PianningTipoIntervento.
     * @example
     * // Create one PianningTipoIntervento
     * const PianningTipoIntervento = await prisma.pianningTipoIntervento.create({
     *   data: {
     *     // ... data to create a PianningTipoIntervento
     *   }
     * })
     * 
     */
    create<T extends PianningTipoInterventoCreateArgs>(args: SelectSubset<T, PianningTipoInterventoCreateArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PianningTipoInterventos.
     * @param {PianningTipoInterventoCreateManyArgs} args - Arguments to create many PianningTipoInterventos.
     * @example
     * // Create many PianningTipoInterventos
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PianningTipoInterventoCreateManyArgs>(args?: SelectSubset<T, PianningTipoInterventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PianningTipoInterventos and returns the data saved in the database.
     * @param {PianningTipoInterventoCreateManyAndReturnArgs} args - Arguments to create many PianningTipoInterventos.
     * @example
     * // Create many PianningTipoInterventos
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PianningTipoInterventos and only return the `id`
     * const pianningTipoInterventoWithIdOnly = await prisma.pianningTipoIntervento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PianningTipoInterventoCreateManyAndReturnArgs>(args?: SelectSubset<T, PianningTipoInterventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PianningTipoIntervento.
     * @param {PianningTipoInterventoDeleteArgs} args - Arguments to delete one PianningTipoIntervento.
     * @example
     * // Delete one PianningTipoIntervento
     * const PianningTipoIntervento = await prisma.pianningTipoIntervento.delete({
     *   where: {
     *     // ... filter to delete one PianningTipoIntervento
     *   }
     * })
     * 
     */
    delete<T extends PianningTipoInterventoDeleteArgs>(args: SelectSubset<T, PianningTipoInterventoDeleteArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PianningTipoIntervento.
     * @param {PianningTipoInterventoUpdateArgs} args - Arguments to update one PianningTipoIntervento.
     * @example
     * // Update one PianningTipoIntervento
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PianningTipoInterventoUpdateArgs>(args: SelectSubset<T, PianningTipoInterventoUpdateArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PianningTipoInterventos.
     * @param {PianningTipoInterventoDeleteManyArgs} args - Arguments to filter PianningTipoInterventos to delete.
     * @example
     * // Delete a few PianningTipoInterventos
     * const { count } = await prisma.pianningTipoIntervento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PianningTipoInterventoDeleteManyArgs>(args?: SelectSubset<T, PianningTipoInterventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PianningTipoInterventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PianningTipoInterventos
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PianningTipoInterventoUpdateManyArgs>(args: SelectSubset<T, PianningTipoInterventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PianningTipoInterventos and returns the data updated in the database.
     * @param {PianningTipoInterventoUpdateManyAndReturnArgs} args - Arguments to update many PianningTipoInterventos.
     * @example
     * // Update many PianningTipoInterventos
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PianningTipoInterventos and only return the `id`
     * const pianningTipoInterventoWithIdOnly = await prisma.pianningTipoIntervento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PianningTipoInterventoUpdateManyAndReturnArgs>(args: SelectSubset<T, PianningTipoInterventoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PianningTipoIntervento.
     * @param {PianningTipoInterventoUpsertArgs} args - Arguments to update or create a PianningTipoIntervento.
     * @example
     * // Update or create a PianningTipoIntervento
     * const pianningTipoIntervento = await prisma.pianningTipoIntervento.upsert({
     *   create: {
     *     // ... data to create a PianningTipoIntervento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PianningTipoIntervento we want to update
     *   }
     * })
     */
    upsert<T extends PianningTipoInterventoUpsertArgs>(args: SelectSubset<T, PianningTipoInterventoUpsertArgs<ExtArgs>>): Prisma__PianningTipoInterventoClient<$Result.GetResult<Prisma.$PianningTipoInterventoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PianningTipoInterventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoCountArgs} args - Arguments to filter PianningTipoInterventos to count.
     * @example
     * // Count the number of PianningTipoInterventos
     * const count = await prisma.pianningTipoIntervento.count({
     *   where: {
     *     // ... the filter for the PianningTipoInterventos we want to count
     *   }
     * })
    **/
    count<T extends PianningTipoInterventoCountArgs>(
      args?: Subset<T, PianningTipoInterventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PianningTipoInterventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PianningTipoIntervento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PianningTipoInterventoAggregateArgs>(args: Subset<T, PianningTipoInterventoAggregateArgs>): Prisma.PrismaPromise<GetPianningTipoInterventoAggregateType<T>>

    /**
     * Group by PianningTipoIntervento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningTipoInterventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PianningTipoInterventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PianningTipoInterventoGroupByArgs['orderBy'] }
        : { orderBy?: PianningTipoInterventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PianningTipoInterventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPianningTipoInterventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PianningTipoIntervento model
   */
  readonly fields: PianningTipoInterventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PianningTipoIntervento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PianningTipoInterventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PianningTipoIntervento model
   */
  interface PianningTipoInterventoFieldRefs {
    readonly id: FieldRef<"PianningTipoIntervento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PianningTipoIntervento findUnique
   */
  export type PianningTipoInterventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * Filter, which PianningTipoIntervento to fetch.
     */
    where: PianningTipoInterventoWhereUniqueInput
  }

  /**
   * PianningTipoIntervento findUniqueOrThrow
   */
  export type PianningTipoInterventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * Filter, which PianningTipoIntervento to fetch.
     */
    where: PianningTipoInterventoWhereUniqueInput
  }

  /**
   * PianningTipoIntervento findFirst
   */
  export type PianningTipoInterventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * Filter, which PianningTipoIntervento to fetch.
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningTipoInterventos to fetch.
     */
    orderBy?: PianningTipoInterventoOrderByWithRelationInput | PianningTipoInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PianningTipoInterventos.
     */
    cursor?: PianningTipoInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningTipoInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningTipoInterventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PianningTipoInterventos.
     */
    distinct?: PianningTipoInterventoScalarFieldEnum | PianningTipoInterventoScalarFieldEnum[]
  }

  /**
   * PianningTipoIntervento findFirstOrThrow
   */
  export type PianningTipoInterventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * Filter, which PianningTipoIntervento to fetch.
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningTipoInterventos to fetch.
     */
    orderBy?: PianningTipoInterventoOrderByWithRelationInput | PianningTipoInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PianningTipoInterventos.
     */
    cursor?: PianningTipoInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningTipoInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningTipoInterventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PianningTipoInterventos.
     */
    distinct?: PianningTipoInterventoScalarFieldEnum | PianningTipoInterventoScalarFieldEnum[]
  }

  /**
   * PianningTipoIntervento findMany
   */
  export type PianningTipoInterventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * Filter, which PianningTipoInterventos to fetch.
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningTipoInterventos to fetch.
     */
    orderBy?: PianningTipoInterventoOrderByWithRelationInput | PianningTipoInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PianningTipoInterventos.
     */
    cursor?: PianningTipoInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningTipoInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningTipoInterventos.
     */
    skip?: number
    distinct?: PianningTipoInterventoScalarFieldEnum | PianningTipoInterventoScalarFieldEnum[]
  }

  /**
   * PianningTipoIntervento create
   */
  export type PianningTipoInterventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * The data needed to create a PianningTipoIntervento.
     */
    data?: XOR<PianningTipoInterventoCreateInput, PianningTipoInterventoUncheckedCreateInput>
  }

  /**
   * PianningTipoIntervento createMany
   */
  export type PianningTipoInterventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PianningTipoInterventos.
     */
    data: PianningTipoInterventoCreateManyInput | PianningTipoInterventoCreateManyInput[]
  }

  /**
   * PianningTipoIntervento createManyAndReturn
   */
  export type PianningTipoInterventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * The data used to create many PianningTipoInterventos.
     */
    data: PianningTipoInterventoCreateManyInput | PianningTipoInterventoCreateManyInput[]
  }

  /**
   * PianningTipoIntervento update
   */
  export type PianningTipoInterventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * The data needed to update a PianningTipoIntervento.
     */
    data: XOR<PianningTipoInterventoUpdateInput, PianningTipoInterventoUncheckedUpdateInput>
    /**
     * Choose, which PianningTipoIntervento to update.
     */
    where: PianningTipoInterventoWhereUniqueInput
  }

  /**
   * PianningTipoIntervento updateMany
   */
  export type PianningTipoInterventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PianningTipoInterventos.
     */
    data: XOR<PianningTipoInterventoUpdateManyMutationInput, PianningTipoInterventoUncheckedUpdateManyInput>
    /**
     * Filter which PianningTipoInterventos to update
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * Limit how many PianningTipoInterventos to update.
     */
    limit?: number
  }

  /**
   * PianningTipoIntervento updateManyAndReturn
   */
  export type PianningTipoInterventoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * The data used to update PianningTipoInterventos.
     */
    data: XOR<PianningTipoInterventoUpdateManyMutationInput, PianningTipoInterventoUncheckedUpdateManyInput>
    /**
     * Filter which PianningTipoInterventos to update
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * Limit how many PianningTipoInterventos to update.
     */
    limit?: number
  }

  /**
   * PianningTipoIntervento upsert
   */
  export type PianningTipoInterventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * The filter to search for the PianningTipoIntervento to update in case it exists.
     */
    where: PianningTipoInterventoWhereUniqueInput
    /**
     * In case the PianningTipoIntervento found by the `where` argument doesn't exist, create a new PianningTipoIntervento with this data.
     */
    create: XOR<PianningTipoInterventoCreateInput, PianningTipoInterventoUncheckedCreateInput>
    /**
     * In case the PianningTipoIntervento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PianningTipoInterventoUpdateInput, PianningTipoInterventoUncheckedUpdateInput>
  }

  /**
   * PianningTipoIntervento delete
   */
  export type PianningTipoInterventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
    /**
     * Filter which PianningTipoIntervento to delete.
     */
    where: PianningTipoInterventoWhereUniqueInput
  }

  /**
   * PianningTipoIntervento deleteMany
   */
  export type PianningTipoInterventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PianningTipoInterventos to delete
     */
    where?: PianningTipoInterventoWhereInput
    /**
     * Limit how many PianningTipoInterventos to delete.
     */
    limit?: number
  }

  /**
   * PianningTipoIntervento without action
   */
  export type PianningTipoInterventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningTipoIntervento
     */
    select?: PianningTipoInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningTipoIntervento
     */
    omit?: PianningTipoInterventoOmit<ExtArgs> | null
  }


  /**
   * Model PianningEmail
   */

  export type AggregatePianningEmail = {
    _count: PianningEmailCountAggregateOutputType | null
    _avg: PianningEmailAvgAggregateOutputType | null
    _sum: PianningEmailSumAggregateOutputType | null
    _min: PianningEmailMinAggregateOutputType | null
    _max: PianningEmailMaxAggregateOutputType | null
  }

  export type PianningEmailAvgAggregateOutputType = {
    id: number | null
    idlogin: number | null
  }

  export type PianningEmailSumAggregateOutputType = {
    id: number | null
    idlogin: number | null
  }

  export type PianningEmailMinAggregateOutputType = {
    id: number | null
    idlogin: number | null
  }

  export type PianningEmailMaxAggregateOutputType = {
    id: number | null
    idlogin: number | null
  }

  export type PianningEmailCountAggregateOutputType = {
    id: number
    idlogin: number
    _all: number
  }


  export type PianningEmailAvgAggregateInputType = {
    id?: true
    idlogin?: true
  }

  export type PianningEmailSumAggregateInputType = {
    id?: true
    idlogin?: true
  }

  export type PianningEmailMinAggregateInputType = {
    id?: true
    idlogin?: true
  }

  export type PianningEmailMaxAggregateInputType = {
    id?: true
    idlogin?: true
  }

  export type PianningEmailCountAggregateInputType = {
    id?: true
    idlogin?: true
    _all?: true
  }

  export type PianningEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PianningEmail to aggregate.
     */
    where?: PianningEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningEmails to fetch.
     */
    orderBy?: PianningEmailOrderByWithRelationInput | PianningEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PianningEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PianningEmails
    **/
    _count?: true | PianningEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PianningEmailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PianningEmailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PianningEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PianningEmailMaxAggregateInputType
  }

  export type GetPianningEmailAggregateType<T extends PianningEmailAggregateArgs> = {
        [P in keyof T & keyof AggregatePianningEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePianningEmail[P]>
      : GetScalarType<T[P], AggregatePianningEmail[P]>
  }




  export type PianningEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PianningEmailWhereInput
    orderBy?: PianningEmailOrderByWithAggregationInput | PianningEmailOrderByWithAggregationInput[]
    by: PianningEmailScalarFieldEnum[] | PianningEmailScalarFieldEnum
    having?: PianningEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PianningEmailCountAggregateInputType | true
    _avg?: PianningEmailAvgAggregateInputType
    _sum?: PianningEmailSumAggregateInputType
    _min?: PianningEmailMinAggregateInputType
    _max?: PianningEmailMaxAggregateInputType
  }

  export type PianningEmailGroupByOutputType = {
    id: number
    idlogin: number | null
    _count: PianningEmailCountAggregateOutputType | null
    _avg: PianningEmailAvgAggregateOutputType | null
    _sum: PianningEmailSumAggregateOutputType | null
    _min: PianningEmailMinAggregateOutputType | null
    _max: PianningEmailMaxAggregateOutputType | null
  }

  type GetPianningEmailGroupByPayload<T extends PianningEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PianningEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PianningEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PianningEmailGroupByOutputType[P]>
            : GetScalarType<T[P], PianningEmailGroupByOutputType[P]>
        }
      >
    >


  export type PianningEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idlogin?: boolean
    user?: boolean | PianningEmail$userArgs<ExtArgs>
  }, ExtArgs["result"]["pianningEmail"]>

  export type PianningEmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idlogin?: boolean
    user?: boolean | PianningEmail$userArgs<ExtArgs>
  }, ExtArgs["result"]["pianningEmail"]>

  export type PianningEmailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idlogin?: boolean
    user?: boolean | PianningEmail$userArgs<ExtArgs>
  }, ExtArgs["result"]["pianningEmail"]>

  export type PianningEmailSelectScalar = {
    id?: boolean
    idlogin?: boolean
  }

  export type PianningEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idlogin", ExtArgs["result"]["pianningEmail"]>
  export type PianningEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PianningEmail$userArgs<ExtArgs>
  }
  export type PianningEmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PianningEmail$userArgs<ExtArgs>
  }
  export type PianningEmailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PianningEmail$userArgs<ExtArgs>
  }

  export type $PianningEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PianningEmail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idlogin: number | null
    }, ExtArgs["result"]["pianningEmail"]>
    composites: {}
  }

  type PianningEmailGetPayload<S extends boolean | null | undefined | PianningEmailDefaultArgs> = $Result.GetResult<Prisma.$PianningEmailPayload, S>

  type PianningEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PianningEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PianningEmailCountAggregateInputType | true
    }

  export interface PianningEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PianningEmail'], meta: { name: 'PianningEmail' } }
    /**
     * Find zero or one PianningEmail that matches the filter.
     * @param {PianningEmailFindUniqueArgs} args - Arguments to find a PianningEmail
     * @example
     * // Get one PianningEmail
     * const pianningEmail = await prisma.pianningEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PianningEmailFindUniqueArgs>(args: SelectSubset<T, PianningEmailFindUniqueArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PianningEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PianningEmailFindUniqueOrThrowArgs} args - Arguments to find a PianningEmail
     * @example
     * // Get one PianningEmail
     * const pianningEmail = await prisma.pianningEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PianningEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, PianningEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PianningEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailFindFirstArgs} args - Arguments to find a PianningEmail
     * @example
     * // Get one PianningEmail
     * const pianningEmail = await prisma.pianningEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PianningEmailFindFirstArgs>(args?: SelectSubset<T, PianningEmailFindFirstArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PianningEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailFindFirstOrThrowArgs} args - Arguments to find a PianningEmail
     * @example
     * // Get one PianningEmail
     * const pianningEmail = await prisma.pianningEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PianningEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, PianningEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PianningEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PianningEmails
     * const pianningEmails = await prisma.pianningEmail.findMany()
     * 
     * // Get first 10 PianningEmails
     * const pianningEmails = await prisma.pianningEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pianningEmailWithIdOnly = await prisma.pianningEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PianningEmailFindManyArgs>(args?: SelectSubset<T, PianningEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PianningEmail.
     * @param {PianningEmailCreateArgs} args - Arguments to create a PianningEmail.
     * @example
     * // Create one PianningEmail
     * const PianningEmail = await prisma.pianningEmail.create({
     *   data: {
     *     // ... data to create a PianningEmail
     *   }
     * })
     * 
     */
    create<T extends PianningEmailCreateArgs>(args: SelectSubset<T, PianningEmailCreateArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PianningEmails.
     * @param {PianningEmailCreateManyArgs} args - Arguments to create many PianningEmails.
     * @example
     * // Create many PianningEmails
     * const pianningEmail = await prisma.pianningEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PianningEmailCreateManyArgs>(args?: SelectSubset<T, PianningEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PianningEmails and returns the data saved in the database.
     * @param {PianningEmailCreateManyAndReturnArgs} args - Arguments to create many PianningEmails.
     * @example
     * // Create many PianningEmails
     * const pianningEmail = await prisma.pianningEmail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PianningEmails and only return the `id`
     * const pianningEmailWithIdOnly = await prisma.pianningEmail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PianningEmailCreateManyAndReturnArgs>(args?: SelectSubset<T, PianningEmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PianningEmail.
     * @param {PianningEmailDeleteArgs} args - Arguments to delete one PianningEmail.
     * @example
     * // Delete one PianningEmail
     * const PianningEmail = await prisma.pianningEmail.delete({
     *   where: {
     *     // ... filter to delete one PianningEmail
     *   }
     * })
     * 
     */
    delete<T extends PianningEmailDeleteArgs>(args: SelectSubset<T, PianningEmailDeleteArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PianningEmail.
     * @param {PianningEmailUpdateArgs} args - Arguments to update one PianningEmail.
     * @example
     * // Update one PianningEmail
     * const pianningEmail = await prisma.pianningEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PianningEmailUpdateArgs>(args: SelectSubset<T, PianningEmailUpdateArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PianningEmails.
     * @param {PianningEmailDeleteManyArgs} args - Arguments to filter PianningEmails to delete.
     * @example
     * // Delete a few PianningEmails
     * const { count } = await prisma.pianningEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PianningEmailDeleteManyArgs>(args?: SelectSubset<T, PianningEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PianningEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PianningEmails
     * const pianningEmail = await prisma.pianningEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PianningEmailUpdateManyArgs>(args: SelectSubset<T, PianningEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PianningEmails and returns the data updated in the database.
     * @param {PianningEmailUpdateManyAndReturnArgs} args - Arguments to update many PianningEmails.
     * @example
     * // Update many PianningEmails
     * const pianningEmail = await prisma.pianningEmail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PianningEmails and only return the `id`
     * const pianningEmailWithIdOnly = await prisma.pianningEmail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PianningEmailUpdateManyAndReturnArgs>(args: SelectSubset<T, PianningEmailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PianningEmail.
     * @param {PianningEmailUpsertArgs} args - Arguments to update or create a PianningEmail.
     * @example
     * // Update or create a PianningEmail
     * const pianningEmail = await prisma.pianningEmail.upsert({
     *   create: {
     *     // ... data to create a PianningEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PianningEmail we want to update
     *   }
     * })
     */
    upsert<T extends PianningEmailUpsertArgs>(args: SelectSubset<T, PianningEmailUpsertArgs<ExtArgs>>): Prisma__PianningEmailClient<$Result.GetResult<Prisma.$PianningEmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PianningEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailCountArgs} args - Arguments to filter PianningEmails to count.
     * @example
     * // Count the number of PianningEmails
     * const count = await prisma.pianningEmail.count({
     *   where: {
     *     // ... the filter for the PianningEmails we want to count
     *   }
     * })
    **/
    count<T extends PianningEmailCountArgs>(
      args?: Subset<T, PianningEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PianningEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PianningEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PianningEmailAggregateArgs>(args: Subset<T, PianningEmailAggregateArgs>): Prisma.PrismaPromise<GetPianningEmailAggregateType<T>>

    /**
     * Group by PianningEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PianningEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PianningEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PianningEmailGroupByArgs['orderBy'] }
        : { orderBy?: PianningEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PianningEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPianningEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PianningEmail model
   */
  readonly fields: PianningEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PianningEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PianningEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PianningEmail$userArgs<ExtArgs> = {}>(args?: Subset<T, PianningEmail$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PianningEmail model
   */
  interface PianningEmailFieldRefs {
    readonly id: FieldRef<"PianningEmail", 'Int'>
    readonly idlogin: FieldRef<"PianningEmail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PianningEmail findUnique
   */
  export type PianningEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * Filter, which PianningEmail to fetch.
     */
    where: PianningEmailWhereUniqueInput
  }

  /**
   * PianningEmail findUniqueOrThrow
   */
  export type PianningEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * Filter, which PianningEmail to fetch.
     */
    where: PianningEmailWhereUniqueInput
  }

  /**
   * PianningEmail findFirst
   */
  export type PianningEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * Filter, which PianningEmail to fetch.
     */
    where?: PianningEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningEmails to fetch.
     */
    orderBy?: PianningEmailOrderByWithRelationInput | PianningEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PianningEmails.
     */
    cursor?: PianningEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PianningEmails.
     */
    distinct?: PianningEmailScalarFieldEnum | PianningEmailScalarFieldEnum[]
  }

  /**
   * PianningEmail findFirstOrThrow
   */
  export type PianningEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * Filter, which PianningEmail to fetch.
     */
    where?: PianningEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningEmails to fetch.
     */
    orderBy?: PianningEmailOrderByWithRelationInput | PianningEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PianningEmails.
     */
    cursor?: PianningEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PianningEmails.
     */
    distinct?: PianningEmailScalarFieldEnum | PianningEmailScalarFieldEnum[]
  }

  /**
   * PianningEmail findMany
   */
  export type PianningEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * Filter, which PianningEmails to fetch.
     */
    where?: PianningEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PianningEmails to fetch.
     */
    orderBy?: PianningEmailOrderByWithRelationInput | PianningEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PianningEmails.
     */
    cursor?: PianningEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PianningEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PianningEmails.
     */
    skip?: number
    distinct?: PianningEmailScalarFieldEnum | PianningEmailScalarFieldEnum[]
  }

  /**
   * PianningEmail create
   */
  export type PianningEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a PianningEmail.
     */
    data?: XOR<PianningEmailCreateInput, PianningEmailUncheckedCreateInput>
  }

  /**
   * PianningEmail createMany
   */
  export type PianningEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PianningEmails.
     */
    data: PianningEmailCreateManyInput | PianningEmailCreateManyInput[]
  }

  /**
   * PianningEmail createManyAndReturn
   */
  export type PianningEmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * The data used to create many PianningEmails.
     */
    data: PianningEmailCreateManyInput | PianningEmailCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PianningEmail update
   */
  export type PianningEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a PianningEmail.
     */
    data: XOR<PianningEmailUpdateInput, PianningEmailUncheckedUpdateInput>
    /**
     * Choose, which PianningEmail to update.
     */
    where: PianningEmailWhereUniqueInput
  }

  /**
   * PianningEmail updateMany
   */
  export type PianningEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PianningEmails.
     */
    data: XOR<PianningEmailUpdateManyMutationInput, PianningEmailUncheckedUpdateManyInput>
    /**
     * Filter which PianningEmails to update
     */
    where?: PianningEmailWhereInput
    /**
     * Limit how many PianningEmails to update.
     */
    limit?: number
  }

  /**
   * PianningEmail updateManyAndReturn
   */
  export type PianningEmailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * The data used to update PianningEmails.
     */
    data: XOR<PianningEmailUpdateManyMutationInput, PianningEmailUncheckedUpdateManyInput>
    /**
     * Filter which PianningEmails to update
     */
    where?: PianningEmailWhereInput
    /**
     * Limit how many PianningEmails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PianningEmail upsert
   */
  export type PianningEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the PianningEmail to update in case it exists.
     */
    where: PianningEmailWhereUniqueInput
    /**
     * In case the PianningEmail found by the `where` argument doesn't exist, create a new PianningEmail with this data.
     */
    create: XOR<PianningEmailCreateInput, PianningEmailUncheckedCreateInput>
    /**
     * In case the PianningEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PianningEmailUpdateInput, PianningEmailUncheckedUpdateInput>
  }

  /**
   * PianningEmail delete
   */
  export type PianningEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
    /**
     * Filter which PianningEmail to delete.
     */
    where: PianningEmailWhereUniqueInput
  }

  /**
   * PianningEmail deleteMany
   */
  export type PianningEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PianningEmails to delete
     */
    where?: PianningEmailWhereInput
    /**
     * Limit how many PianningEmails to delete.
     */
    limit?: number
  }

  /**
   * PianningEmail.user
   */
  export type PianningEmail$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PianningEmail without action
   */
  export type PianningEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PianningEmail
     */
    select?: PianningEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PianningEmail
     */
    omit?: PianningEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PianningEmailInclude<ExtArgs> | null
  }


  /**
   * Model VociIntervento
   */

  export type AggregateVociIntervento = {
    _count: VociInterventoCountAggregateOutputType | null
    _avg: VociInterventoAvgAggregateOutputType | null
    _sum: VociInterventoSumAggregateOutputType | null
    _min: VociInterventoMinAggregateOutputType | null
    _max: VociInterventoMaxAggregateOutputType | null
  }

  export type VociInterventoAvgAggregateOutputType = {
    id: number | null
  }

  export type VociInterventoSumAggregateOutputType = {
    id: number | null
  }

  export type VociInterventoMinAggregateOutputType = {
    id: number | null
  }

  export type VociInterventoMaxAggregateOutputType = {
    id: number | null
  }

  export type VociInterventoCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type VociInterventoAvgAggregateInputType = {
    id?: true
  }

  export type VociInterventoSumAggregateInputType = {
    id?: true
  }

  export type VociInterventoMinAggregateInputType = {
    id?: true
  }

  export type VociInterventoMaxAggregateInputType = {
    id?: true
  }

  export type VociInterventoCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type VociInterventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VociIntervento to aggregate.
     */
    where?: VociInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VociInterventos to fetch.
     */
    orderBy?: VociInterventoOrderByWithRelationInput | VociInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VociInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VociInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VociInterventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VociInterventos
    **/
    _count?: true | VociInterventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VociInterventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VociInterventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VociInterventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VociInterventoMaxAggregateInputType
  }

  export type GetVociInterventoAggregateType<T extends VociInterventoAggregateArgs> = {
        [P in keyof T & keyof AggregateVociIntervento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVociIntervento[P]>
      : GetScalarType<T[P], AggregateVociIntervento[P]>
  }




  export type VociInterventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VociInterventoWhereInput
    orderBy?: VociInterventoOrderByWithAggregationInput | VociInterventoOrderByWithAggregationInput[]
    by: VociInterventoScalarFieldEnum[] | VociInterventoScalarFieldEnum
    having?: VociInterventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VociInterventoCountAggregateInputType | true
    _avg?: VociInterventoAvgAggregateInputType
    _sum?: VociInterventoSumAggregateInputType
    _min?: VociInterventoMinAggregateInputType
    _max?: VociInterventoMaxAggregateInputType
  }

  export type VociInterventoGroupByOutputType = {
    id: number
    _count: VociInterventoCountAggregateOutputType | null
    _avg: VociInterventoAvgAggregateOutputType | null
    _sum: VociInterventoSumAggregateOutputType | null
    _min: VociInterventoMinAggregateOutputType | null
    _max: VociInterventoMaxAggregateOutputType | null
  }

  type GetVociInterventoGroupByPayload<T extends VociInterventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VociInterventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VociInterventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VociInterventoGroupByOutputType[P]>
            : GetScalarType<T[P], VociInterventoGroupByOutputType[P]>
        }
      >
    >


  export type VociInterventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["vociIntervento"]>

  export type VociInterventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["vociIntervento"]>

  export type VociInterventoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["vociIntervento"]>

  export type VociInterventoSelectScalar = {
    id?: boolean
  }

  export type VociInterventoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["vociIntervento"]>

  export type $VociInterventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VociIntervento"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["vociIntervento"]>
    composites: {}
  }

  type VociInterventoGetPayload<S extends boolean | null | undefined | VociInterventoDefaultArgs> = $Result.GetResult<Prisma.$VociInterventoPayload, S>

  type VociInterventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VociInterventoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VociInterventoCountAggregateInputType | true
    }

  export interface VociInterventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VociIntervento'], meta: { name: 'VociIntervento' } }
    /**
     * Find zero or one VociIntervento that matches the filter.
     * @param {VociInterventoFindUniqueArgs} args - Arguments to find a VociIntervento
     * @example
     * // Get one VociIntervento
     * const vociIntervento = await prisma.vociIntervento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VociInterventoFindUniqueArgs>(args: SelectSubset<T, VociInterventoFindUniqueArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VociIntervento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VociInterventoFindUniqueOrThrowArgs} args - Arguments to find a VociIntervento
     * @example
     * // Get one VociIntervento
     * const vociIntervento = await prisma.vociIntervento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VociInterventoFindUniqueOrThrowArgs>(args: SelectSubset<T, VociInterventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VociIntervento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoFindFirstArgs} args - Arguments to find a VociIntervento
     * @example
     * // Get one VociIntervento
     * const vociIntervento = await prisma.vociIntervento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VociInterventoFindFirstArgs>(args?: SelectSubset<T, VociInterventoFindFirstArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VociIntervento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoFindFirstOrThrowArgs} args - Arguments to find a VociIntervento
     * @example
     * // Get one VociIntervento
     * const vociIntervento = await prisma.vociIntervento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VociInterventoFindFirstOrThrowArgs>(args?: SelectSubset<T, VociInterventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VociInterventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VociInterventos
     * const vociInterventos = await prisma.vociIntervento.findMany()
     * 
     * // Get first 10 VociInterventos
     * const vociInterventos = await prisma.vociIntervento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vociInterventoWithIdOnly = await prisma.vociIntervento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VociInterventoFindManyArgs>(args?: SelectSubset<T, VociInterventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VociIntervento.
     * @param {VociInterventoCreateArgs} args - Arguments to create a VociIntervento.
     * @example
     * // Create one VociIntervento
     * const VociIntervento = await prisma.vociIntervento.create({
     *   data: {
     *     // ... data to create a VociIntervento
     *   }
     * })
     * 
     */
    create<T extends VociInterventoCreateArgs>(args: SelectSubset<T, VociInterventoCreateArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VociInterventos.
     * @param {VociInterventoCreateManyArgs} args - Arguments to create many VociInterventos.
     * @example
     * // Create many VociInterventos
     * const vociIntervento = await prisma.vociIntervento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VociInterventoCreateManyArgs>(args?: SelectSubset<T, VociInterventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VociInterventos and returns the data saved in the database.
     * @param {VociInterventoCreateManyAndReturnArgs} args - Arguments to create many VociInterventos.
     * @example
     * // Create many VociInterventos
     * const vociIntervento = await prisma.vociIntervento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VociInterventos and only return the `id`
     * const vociInterventoWithIdOnly = await prisma.vociIntervento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VociInterventoCreateManyAndReturnArgs>(args?: SelectSubset<T, VociInterventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VociIntervento.
     * @param {VociInterventoDeleteArgs} args - Arguments to delete one VociIntervento.
     * @example
     * // Delete one VociIntervento
     * const VociIntervento = await prisma.vociIntervento.delete({
     *   where: {
     *     // ... filter to delete one VociIntervento
     *   }
     * })
     * 
     */
    delete<T extends VociInterventoDeleteArgs>(args: SelectSubset<T, VociInterventoDeleteArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VociIntervento.
     * @param {VociInterventoUpdateArgs} args - Arguments to update one VociIntervento.
     * @example
     * // Update one VociIntervento
     * const vociIntervento = await prisma.vociIntervento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VociInterventoUpdateArgs>(args: SelectSubset<T, VociInterventoUpdateArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VociInterventos.
     * @param {VociInterventoDeleteManyArgs} args - Arguments to filter VociInterventos to delete.
     * @example
     * // Delete a few VociInterventos
     * const { count } = await prisma.vociIntervento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VociInterventoDeleteManyArgs>(args?: SelectSubset<T, VociInterventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VociInterventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VociInterventos
     * const vociIntervento = await prisma.vociIntervento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VociInterventoUpdateManyArgs>(args: SelectSubset<T, VociInterventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VociInterventos and returns the data updated in the database.
     * @param {VociInterventoUpdateManyAndReturnArgs} args - Arguments to update many VociInterventos.
     * @example
     * // Update many VociInterventos
     * const vociIntervento = await prisma.vociIntervento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VociInterventos and only return the `id`
     * const vociInterventoWithIdOnly = await prisma.vociIntervento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VociInterventoUpdateManyAndReturnArgs>(args: SelectSubset<T, VociInterventoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VociIntervento.
     * @param {VociInterventoUpsertArgs} args - Arguments to update or create a VociIntervento.
     * @example
     * // Update or create a VociIntervento
     * const vociIntervento = await prisma.vociIntervento.upsert({
     *   create: {
     *     // ... data to create a VociIntervento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VociIntervento we want to update
     *   }
     * })
     */
    upsert<T extends VociInterventoUpsertArgs>(args: SelectSubset<T, VociInterventoUpsertArgs<ExtArgs>>): Prisma__VociInterventoClient<$Result.GetResult<Prisma.$VociInterventoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VociInterventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoCountArgs} args - Arguments to filter VociInterventos to count.
     * @example
     * // Count the number of VociInterventos
     * const count = await prisma.vociIntervento.count({
     *   where: {
     *     // ... the filter for the VociInterventos we want to count
     *   }
     * })
    **/
    count<T extends VociInterventoCountArgs>(
      args?: Subset<T, VociInterventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VociInterventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VociIntervento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VociInterventoAggregateArgs>(args: Subset<T, VociInterventoAggregateArgs>): Prisma.PrismaPromise<GetVociInterventoAggregateType<T>>

    /**
     * Group by VociIntervento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VociInterventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VociInterventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VociInterventoGroupByArgs['orderBy'] }
        : { orderBy?: VociInterventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VociInterventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVociInterventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VociIntervento model
   */
  readonly fields: VociInterventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VociIntervento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VociInterventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VociIntervento model
   */
  interface VociInterventoFieldRefs {
    readonly id: FieldRef<"VociIntervento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VociIntervento findUnique
   */
  export type VociInterventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * Filter, which VociIntervento to fetch.
     */
    where: VociInterventoWhereUniqueInput
  }

  /**
   * VociIntervento findUniqueOrThrow
   */
  export type VociInterventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * Filter, which VociIntervento to fetch.
     */
    where: VociInterventoWhereUniqueInput
  }

  /**
   * VociIntervento findFirst
   */
  export type VociInterventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * Filter, which VociIntervento to fetch.
     */
    where?: VociInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VociInterventos to fetch.
     */
    orderBy?: VociInterventoOrderByWithRelationInput | VociInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VociInterventos.
     */
    cursor?: VociInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VociInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VociInterventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VociInterventos.
     */
    distinct?: VociInterventoScalarFieldEnum | VociInterventoScalarFieldEnum[]
  }

  /**
   * VociIntervento findFirstOrThrow
   */
  export type VociInterventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * Filter, which VociIntervento to fetch.
     */
    where?: VociInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VociInterventos to fetch.
     */
    orderBy?: VociInterventoOrderByWithRelationInput | VociInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VociInterventos.
     */
    cursor?: VociInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VociInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VociInterventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VociInterventos.
     */
    distinct?: VociInterventoScalarFieldEnum | VociInterventoScalarFieldEnum[]
  }

  /**
   * VociIntervento findMany
   */
  export type VociInterventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * Filter, which VociInterventos to fetch.
     */
    where?: VociInterventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VociInterventos to fetch.
     */
    orderBy?: VociInterventoOrderByWithRelationInput | VociInterventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VociInterventos.
     */
    cursor?: VociInterventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VociInterventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VociInterventos.
     */
    skip?: number
    distinct?: VociInterventoScalarFieldEnum | VociInterventoScalarFieldEnum[]
  }

  /**
   * VociIntervento create
   */
  export type VociInterventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * The data needed to create a VociIntervento.
     */
    data?: XOR<VociInterventoCreateInput, VociInterventoUncheckedCreateInput>
  }

  /**
   * VociIntervento createMany
   */
  export type VociInterventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VociInterventos.
     */
    data: VociInterventoCreateManyInput | VociInterventoCreateManyInput[]
  }

  /**
   * VociIntervento createManyAndReturn
   */
  export type VociInterventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * The data used to create many VociInterventos.
     */
    data: VociInterventoCreateManyInput | VociInterventoCreateManyInput[]
  }

  /**
   * VociIntervento update
   */
  export type VociInterventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * The data needed to update a VociIntervento.
     */
    data: XOR<VociInterventoUpdateInput, VociInterventoUncheckedUpdateInput>
    /**
     * Choose, which VociIntervento to update.
     */
    where: VociInterventoWhereUniqueInput
  }

  /**
   * VociIntervento updateMany
   */
  export type VociInterventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VociInterventos.
     */
    data: XOR<VociInterventoUpdateManyMutationInput, VociInterventoUncheckedUpdateManyInput>
    /**
     * Filter which VociInterventos to update
     */
    where?: VociInterventoWhereInput
    /**
     * Limit how many VociInterventos to update.
     */
    limit?: number
  }

  /**
   * VociIntervento updateManyAndReturn
   */
  export type VociInterventoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * The data used to update VociInterventos.
     */
    data: XOR<VociInterventoUpdateManyMutationInput, VociInterventoUncheckedUpdateManyInput>
    /**
     * Filter which VociInterventos to update
     */
    where?: VociInterventoWhereInput
    /**
     * Limit how many VociInterventos to update.
     */
    limit?: number
  }

  /**
   * VociIntervento upsert
   */
  export type VociInterventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * The filter to search for the VociIntervento to update in case it exists.
     */
    where: VociInterventoWhereUniqueInput
    /**
     * In case the VociIntervento found by the `where` argument doesn't exist, create a new VociIntervento with this data.
     */
    create: XOR<VociInterventoCreateInput, VociInterventoUncheckedCreateInput>
    /**
     * In case the VociIntervento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VociInterventoUpdateInput, VociInterventoUncheckedUpdateInput>
  }

  /**
   * VociIntervento delete
   */
  export type VociInterventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
    /**
     * Filter which VociIntervento to delete.
     */
    where: VociInterventoWhereUniqueInput
  }

  /**
   * VociIntervento deleteMany
   */
  export type VociInterventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VociInterventos to delete
     */
    where?: VociInterventoWhereInput
    /**
     * Limit how many VociInterventos to delete.
     */
    limit?: number
  }

  /**
   * VociIntervento without action
   */
  export type VociInterventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VociIntervento
     */
    select?: VociInterventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VociIntervento
     */
    omit?: VociInterventoOmit<ExtArgs> | null
  }


  /**
   * Model Straordinario
   */

  export type AggregateStraordinario = {
    _count: StraordinarioCountAggregateOutputType | null
    _avg: StraordinarioAvgAggregateOutputType | null
    _sum: StraordinarioSumAggregateOutputType | null
    _min: StraordinarioMinAggregateOutputType | null
    _max: StraordinarioMaxAggregateOutputType | null
  }

  export type StraordinarioAvgAggregateOutputType = {
    id: number | null
  }

  export type StraordinarioSumAggregateOutputType = {
    id: number | null
  }

  export type StraordinarioMinAggregateOutputType = {
    id: number | null
  }

  export type StraordinarioMaxAggregateOutputType = {
    id: number | null
  }

  export type StraordinarioCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type StraordinarioAvgAggregateInputType = {
    id?: true
  }

  export type StraordinarioSumAggregateInputType = {
    id?: true
  }

  export type StraordinarioMinAggregateInputType = {
    id?: true
  }

  export type StraordinarioMaxAggregateInputType = {
    id?: true
  }

  export type StraordinarioCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type StraordinarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Straordinario to aggregate.
     */
    where?: StraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Straordinarios to fetch.
     */
    orderBy?: StraordinarioOrderByWithRelationInput | StraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Straordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Straordinarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Straordinarios
    **/
    _count?: true | StraordinarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StraordinarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StraordinarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StraordinarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StraordinarioMaxAggregateInputType
  }

  export type GetStraordinarioAggregateType<T extends StraordinarioAggregateArgs> = {
        [P in keyof T & keyof AggregateStraordinario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStraordinario[P]>
      : GetScalarType<T[P], AggregateStraordinario[P]>
  }




  export type StraordinarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StraordinarioWhereInput
    orderBy?: StraordinarioOrderByWithAggregationInput | StraordinarioOrderByWithAggregationInput[]
    by: StraordinarioScalarFieldEnum[] | StraordinarioScalarFieldEnum
    having?: StraordinarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StraordinarioCountAggregateInputType | true
    _avg?: StraordinarioAvgAggregateInputType
    _sum?: StraordinarioSumAggregateInputType
    _min?: StraordinarioMinAggregateInputType
    _max?: StraordinarioMaxAggregateInputType
  }

  export type StraordinarioGroupByOutputType = {
    id: number
    _count: StraordinarioCountAggregateOutputType | null
    _avg: StraordinarioAvgAggregateOutputType | null
    _sum: StraordinarioSumAggregateOutputType | null
    _min: StraordinarioMinAggregateOutputType | null
    _max: StraordinarioMaxAggregateOutputType | null
  }

  type GetStraordinarioGroupByPayload<T extends StraordinarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StraordinarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StraordinarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StraordinarioGroupByOutputType[P]>
            : GetScalarType<T[P], StraordinarioGroupByOutputType[P]>
        }
      >
    >


  export type StraordinarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["straordinario"]>

  export type StraordinarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["straordinario"]>

  export type StraordinarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["straordinario"]>

  export type StraordinarioSelectScalar = {
    id?: boolean
  }

  export type StraordinarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["straordinario"]>

  export type $StraordinarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Straordinario"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["straordinario"]>
    composites: {}
  }

  type StraordinarioGetPayload<S extends boolean | null | undefined | StraordinarioDefaultArgs> = $Result.GetResult<Prisma.$StraordinarioPayload, S>

  type StraordinarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StraordinarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StraordinarioCountAggregateInputType | true
    }

  export interface StraordinarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Straordinario'], meta: { name: 'Straordinario' } }
    /**
     * Find zero or one Straordinario that matches the filter.
     * @param {StraordinarioFindUniqueArgs} args - Arguments to find a Straordinario
     * @example
     * // Get one Straordinario
     * const straordinario = await prisma.straordinario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StraordinarioFindUniqueArgs>(args: SelectSubset<T, StraordinarioFindUniqueArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Straordinario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StraordinarioFindUniqueOrThrowArgs} args - Arguments to find a Straordinario
     * @example
     * // Get one Straordinario
     * const straordinario = await prisma.straordinario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StraordinarioFindUniqueOrThrowArgs>(args: SelectSubset<T, StraordinarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Straordinario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioFindFirstArgs} args - Arguments to find a Straordinario
     * @example
     * // Get one Straordinario
     * const straordinario = await prisma.straordinario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StraordinarioFindFirstArgs>(args?: SelectSubset<T, StraordinarioFindFirstArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Straordinario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioFindFirstOrThrowArgs} args - Arguments to find a Straordinario
     * @example
     * // Get one Straordinario
     * const straordinario = await prisma.straordinario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StraordinarioFindFirstOrThrowArgs>(args?: SelectSubset<T, StraordinarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Straordinarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Straordinarios
     * const straordinarios = await prisma.straordinario.findMany()
     * 
     * // Get first 10 Straordinarios
     * const straordinarios = await prisma.straordinario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const straordinarioWithIdOnly = await prisma.straordinario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StraordinarioFindManyArgs>(args?: SelectSubset<T, StraordinarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Straordinario.
     * @param {StraordinarioCreateArgs} args - Arguments to create a Straordinario.
     * @example
     * // Create one Straordinario
     * const Straordinario = await prisma.straordinario.create({
     *   data: {
     *     // ... data to create a Straordinario
     *   }
     * })
     * 
     */
    create<T extends StraordinarioCreateArgs>(args: SelectSubset<T, StraordinarioCreateArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Straordinarios.
     * @param {StraordinarioCreateManyArgs} args - Arguments to create many Straordinarios.
     * @example
     * // Create many Straordinarios
     * const straordinario = await prisma.straordinario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StraordinarioCreateManyArgs>(args?: SelectSubset<T, StraordinarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Straordinarios and returns the data saved in the database.
     * @param {StraordinarioCreateManyAndReturnArgs} args - Arguments to create many Straordinarios.
     * @example
     * // Create many Straordinarios
     * const straordinario = await prisma.straordinario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Straordinarios and only return the `id`
     * const straordinarioWithIdOnly = await prisma.straordinario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StraordinarioCreateManyAndReturnArgs>(args?: SelectSubset<T, StraordinarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Straordinario.
     * @param {StraordinarioDeleteArgs} args - Arguments to delete one Straordinario.
     * @example
     * // Delete one Straordinario
     * const Straordinario = await prisma.straordinario.delete({
     *   where: {
     *     // ... filter to delete one Straordinario
     *   }
     * })
     * 
     */
    delete<T extends StraordinarioDeleteArgs>(args: SelectSubset<T, StraordinarioDeleteArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Straordinario.
     * @param {StraordinarioUpdateArgs} args - Arguments to update one Straordinario.
     * @example
     * // Update one Straordinario
     * const straordinario = await prisma.straordinario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StraordinarioUpdateArgs>(args: SelectSubset<T, StraordinarioUpdateArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Straordinarios.
     * @param {StraordinarioDeleteManyArgs} args - Arguments to filter Straordinarios to delete.
     * @example
     * // Delete a few Straordinarios
     * const { count } = await prisma.straordinario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StraordinarioDeleteManyArgs>(args?: SelectSubset<T, StraordinarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Straordinarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Straordinarios
     * const straordinario = await prisma.straordinario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StraordinarioUpdateManyArgs>(args: SelectSubset<T, StraordinarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Straordinarios and returns the data updated in the database.
     * @param {StraordinarioUpdateManyAndReturnArgs} args - Arguments to update many Straordinarios.
     * @example
     * // Update many Straordinarios
     * const straordinario = await prisma.straordinario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Straordinarios and only return the `id`
     * const straordinarioWithIdOnly = await prisma.straordinario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StraordinarioUpdateManyAndReturnArgs>(args: SelectSubset<T, StraordinarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Straordinario.
     * @param {StraordinarioUpsertArgs} args - Arguments to update or create a Straordinario.
     * @example
     * // Update or create a Straordinario
     * const straordinario = await prisma.straordinario.upsert({
     *   create: {
     *     // ... data to create a Straordinario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Straordinario we want to update
     *   }
     * })
     */
    upsert<T extends StraordinarioUpsertArgs>(args: SelectSubset<T, StraordinarioUpsertArgs<ExtArgs>>): Prisma__StraordinarioClient<$Result.GetResult<Prisma.$StraordinarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Straordinarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioCountArgs} args - Arguments to filter Straordinarios to count.
     * @example
     * // Count the number of Straordinarios
     * const count = await prisma.straordinario.count({
     *   where: {
     *     // ... the filter for the Straordinarios we want to count
     *   }
     * })
    **/
    count<T extends StraordinarioCountArgs>(
      args?: Subset<T, StraordinarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StraordinarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Straordinario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StraordinarioAggregateArgs>(args: Subset<T, StraordinarioAggregateArgs>): Prisma.PrismaPromise<GetStraordinarioAggregateType<T>>

    /**
     * Group by Straordinario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StraordinarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StraordinarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StraordinarioGroupByArgs['orderBy'] }
        : { orderBy?: StraordinarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StraordinarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStraordinarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Straordinario model
   */
  readonly fields: StraordinarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Straordinario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StraordinarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Straordinario model
   */
  interface StraordinarioFieldRefs {
    readonly id: FieldRef<"Straordinario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Straordinario findUnique
   */
  export type StraordinarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which Straordinario to fetch.
     */
    where: StraordinarioWhereUniqueInput
  }

  /**
   * Straordinario findUniqueOrThrow
   */
  export type StraordinarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which Straordinario to fetch.
     */
    where: StraordinarioWhereUniqueInput
  }

  /**
   * Straordinario findFirst
   */
  export type StraordinarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which Straordinario to fetch.
     */
    where?: StraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Straordinarios to fetch.
     */
    orderBy?: StraordinarioOrderByWithRelationInput | StraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Straordinarios.
     */
    cursor?: StraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Straordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Straordinarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Straordinarios.
     */
    distinct?: StraordinarioScalarFieldEnum | StraordinarioScalarFieldEnum[]
  }

  /**
   * Straordinario findFirstOrThrow
   */
  export type StraordinarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which Straordinario to fetch.
     */
    where?: StraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Straordinarios to fetch.
     */
    orderBy?: StraordinarioOrderByWithRelationInput | StraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Straordinarios.
     */
    cursor?: StraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Straordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Straordinarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Straordinarios.
     */
    distinct?: StraordinarioScalarFieldEnum | StraordinarioScalarFieldEnum[]
  }

  /**
   * Straordinario findMany
   */
  export type StraordinarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which Straordinarios to fetch.
     */
    where?: StraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Straordinarios to fetch.
     */
    orderBy?: StraordinarioOrderByWithRelationInput | StraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Straordinarios.
     */
    cursor?: StraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Straordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Straordinarios.
     */
    skip?: number
    distinct?: StraordinarioScalarFieldEnum | StraordinarioScalarFieldEnum[]
  }

  /**
   * Straordinario create
   */
  export type StraordinarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * The data needed to create a Straordinario.
     */
    data?: XOR<StraordinarioCreateInput, StraordinarioUncheckedCreateInput>
  }

  /**
   * Straordinario createMany
   */
  export type StraordinarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Straordinarios.
     */
    data: StraordinarioCreateManyInput | StraordinarioCreateManyInput[]
  }

  /**
   * Straordinario createManyAndReturn
   */
  export type StraordinarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * The data used to create many Straordinarios.
     */
    data: StraordinarioCreateManyInput | StraordinarioCreateManyInput[]
  }

  /**
   * Straordinario update
   */
  export type StraordinarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * The data needed to update a Straordinario.
     */
    data: XOR<StraordinarioUpdateInput, StraordinarioUncheckedUpdateInput>
    /**
     * Choose, which Straordinario to update.
     */
    where: StraordinarioWhereUniqueInput
  }

  /**
   * Straordinario updateMany
   */
  export type StraordinarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Straordinarios.
     */
    data: XOR<StraordinarioUpdateManyMutationInput, StraordinarioUncheckedUpdateManyInput>
    /**
     * Filter which Straordinarios to update
     */
    where?: StraordinarioWhereInput
    /**
     * Limit how many Straordinarios to update.
     */
    limit?: number
  }

  /**
   * Straordinario updateManyAndReturn
   */
  export type StraordinarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * The data used to update Straordinarios.
     */
    data: XOR<StraordinarioUpdateManyMutationInput, StraordinarioUncheckedUpdateManyInput>
    /**
     * Filter which Straordinarios to update
     */
    where?: StraordinarioWhereInput
    /**
     * Limit how many Straordinarios to update.
     */
    limit?: number
  }

  /**
   * Straordinario upsert
   */
  export type StraordinarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * The filter to search for the Straordinario to update in case it exists.
     */
    where: StraordinarioWhereUniqueInput
    /**
     * In case the Straordinario found by the `where` argument doesn't exist, create a new Straordinario with this data.
     */
    create: XOR<StraordinarioCreateInput, StraordinarioUncheckedCreateInput>
    /**
     * In case the Straordinario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StraordinarioUpdateInput, StraordinarioUncheckedUpdateInput>
  }

  /**
   * Straordinario delete
   */
  export type StraordinarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
    /**
     * Filter which Straordinario to delete.
     */
    where: StraordinarioWhereUniqueInput
  }

  /**
   * Straordinario deleteMany
   */
  export type StraordinarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Straordinarios to delete
     */
    where?: StraordinarioWhereInput
    /**
     * Limit how many Straordinarios to delete.
     */
    limit?: number
  }

  /**
   * Straordinario without action
   */
  export type StraordinarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Straordinario
     */
    select?: StraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Straordinario
     */
    omit?: StraordinarioOmit<ExtArgs> | null
  }


  /**
   * Model InserimentoStraordinario
   */

  export type AggregateInserimentoStraordinario = {
    _count: InserimentoStraordinarioCountAggregateOutputType | null
    _avg: InserimentoStraordinarioAvgAggregateOutputType | null
    _sum: InserimentoStraordinarioSumAggregateOutputType | null
    _min: InserimentoStraordinarioMinAggregateOutputType | null
    _max: InserimentoStraordinarioMaxAggregateOutputType | null
  }

  export type InserimentoStraordinarioAvgAggregateOutputType = {
    id: number | null
  }

  export type InserimentoStraordinarioSumAggregateOutputType = {
    id: number | null
  }

  export type InserimentoStraordinarioMinAggregateOutputType = {
    id: number | null
  }

  export type InserimentoStraordinarioMaxAggregateOutputType = {
    id: number | null
  }

  export type InserimentoStraordinarioCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type InserimentoStraordinarioAvgAggregateInputType = {
    id?: true
  }

  export type InserimentoStraordinarioSumAggregateInputType = {
    id?: true
  }

  export type InserimentoStraordinarioMinAggregateInputType = {
    id?: true
  }

  export type InserimentoStraordinarioMaxAggregateInputType = {
    id?: true
  }

  export type InserimentoStraordinarioCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type InserimentoStraordinarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InserimentoStraordinario to aggregate.
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InserimentoStraordinarios to fetch.
     */
    orderBy?: InserimentoStraordinarioOrderByWithRelationInput | InserimentoStraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InserimentoStraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InserimentoStraordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InserimentoStraordinarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InserimentoStraordinarios
    **/
    _count?: true | InserimentoStraordinarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InserimentoStraordinarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InserimentoStraordinarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InserimentoStraordinarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InserimentoStraordinarioMaxAggregateInputType
  }

  export type GetInserimentoStraordinarioAggregateType<T extends InserimentoStraordinarioAggregateArgs> = {
        [P in keyof T & keyof AggregateInserimentoStraordinario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInserimentoStraordinario[P]>
      : GetScalarType<T[P], AggregateInserimentoStraordinario[P]>
  }




  export type InserimentoStraordinarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InserimentoStraordinarioWhereInput
    orderBy?: InserimentoStraordinarioOrderByWithAggregationInput | InserimentoStraordinarioOrderByWithAggregationInput[]
    by: InserimentoStraordinarioScalarFieldEnum[] | InserimentoStraordinarioScalarFieldEnum
    having?: InserimentoStraordinarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InserimentoStraordinarioCountAggregateInputType | true
    _avg?: InserimentoStraordinarioAvgAggregateInputType
    _sum?: InserimentoStraordinarioSumAggregateInputType
    _min?: InserimentoStraordinarioMinAggregateInputType
    _max?: InserimentoStraordinarioMaxAggregateInputType
  }

  export type InserimentoStraordinarioGroupByOutputType = {
    id: number
    _count: InserimentoStraordinarioCountAggregateOutputType | null
    _avg: InserimentoStraordinarioAvgAggregateOutputType | null
    _sum: InserimentoStraordinarioSumAggregateOutputType | null
    _min: InserimentoStraordinarioMinAggregateOutputType | null
    _max: InserimentoStraordinarioMaxAggregateOutputType | null
  }

  type GetInserimentoStraordinarioGroupByPayload<T extends InserimentoStraordinarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InserimentoStraordinarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InserimentoStraordinarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InserimentoStraordinarioGroupByOutputType[P]>
            : GetScalarType<T[P], InserimentoStraordinarioGroupByOutputType[P]>
        }
      >
    >


  export type InserimentoStraordinarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["inserimentoStraordinario"]>

  export type InserimentoStraordinarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["inserimentoStraordinario"]>

  export type InserimentoStraordinarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["inserimentoStraordinario"]>

  export type InserimentoStraordinarioSelectScalar = {
    id?: boolean
  }

  export type InserimentoStraordinarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["inserimentoStraordinario"]>

  export type $InserimentoStraordinarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InserimentoStraordinario"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["inserimentoStraordinario"]>
    composites: {}
  }

  type InserimentoStraordinarioGetPayload<S extends boolean | null | undefined | InserimentoStraordinarioDefaultArgs> = $Result.GetResult<Prisma.$InserimentoStraordinarioPayload, S>

  type InserimentoStraordinarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InserimentoStraordinarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InserimentoStraordinarioCountAggregateInputType | true
    }

  export interface InserimentoStraordinarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InserimentoStraordinario'], meta: { name: 'InserimentoStraordinario' } }
    /**
     * Find zero or one InserimentoStraordinario that matches the filter.
     * @param {InserimentoStraordinarioFindUniqueArgs} args - Arguments to find a InserimentoStraordinario
     * @example
     * // Get one InserimentoStraordinario
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InserimentoStraordinarioFindUniqueArgs>(args: SelectSubset<T, InserimentoStraordinarioFindUniqueArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InserimentoStraordinario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InserimentoStraordinarioFindUniqueOrThrowArgs} args - Arguments to find a InserimentoStraordinario
     * @example
     * // Get one InserimentoStraordinario
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InserimentoStraordinarioFindUniqueOrThrowArgs>(args: SelectSubset<T, InserimentoStraordinarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InserimentoStraordinario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioFindFirstArgs} args - Arguments to find a InserimentoStraordinario
     * @example
     * // Get one InserimentoStraordinario
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InserimentoStraordinarioFindFirstArgs>(args?: SelectSubset<T, InserimentoStraordinarioFindFirstArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InserimentoStraordinario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioFindFirstOrThrowArgs} args - Arguments to find a InserimentoStraordinario
     * @example
     * // Get one InserimentoStraordinario
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InserimentoStraordinarioFindFirstOrThrowArgs>(args?: SelectSubset<T, InserimentoStraordinarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InserimentoStraordinarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InserimentoStraordinarios
     * const inserimentoStraordinarios = await prisma.inserimentoStraordinario.findMany()
     * 
     * // Get first 10 InserimentoStraordinarios
     * const inserimentoStraordinarios = await prisma.inserimentoStraordinario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inserimentoStraordinarioWithIdOnly = await prisma.inserimentoStraordinario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InserimentoStraordinarioFindManyArgs>(args?: SelectSubset<T, InserimentoStraordinarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InserimentoStraordinario.
     * @param {InserimentoStraordinarioCreateArgs} args - Arguments to create a InserimentoStraordinario.
     * @example
     * // Create one InserimentoStraordinario
     * const InserimentoStraordinario = await prisma.inserimentoStraordinario.create({
     *   data: {
     *     // ... data to create a InserimentoStraordinario
     *   }
     * })
     * 
     */
    create<T extends InserimentoStraordinarioCreateArgs>(args: SelectSubset<T, InserimentoStraordinarioCreateArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InserimentoStraordinarios.
     * @param {InserimentoStraordinarioCreateManyArgs} args - Arguments to create many InserimentoStraordinarios.
     * @example
     * // Create many InserimentoStraordinarios
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InserimentoStraordinarioCreateManyArgs>(args?: SelectSubset<T, InserimentoStraordinarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InserimentoStraordinarios and returns the data saved in the database.
     * @param {InserimentoStraordinarioCreateManyAndReturnArgs} args - Arguments to create many InserimentoStraordinarios.
     * @example
     * // Create many InserimentoStraordinarios
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InserimentoStraordinarios and only return the `id`
     * const inserimentoStraordinarioWithIdOnly = await prisma.inserimentoStraordinario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InserimentoStraordinarioCreateManyAndReturnArgs>(args?: SelectSubset<T, InserimentoStraordinarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InserimentoStraordinario.
     * @param {InserimentoStraordinarioDeleteArgs} args - Arguments to delete one InserimentoStraordinario.
     * @example
     * // Delete one InserimentoStraordinario
     * const InserimentoStraordinario = await prisma.inserimentoStraordinario.delete({
     *   where: {
     *     // ... filter to delete one InserimentoStraordinario
     *   }
     * })
     * 
     */
    delete<T extends InserimentoStraordinarioDeleteArgs>(args: SelectSubset<T, InserimentoStraordinarioDeleteArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InserimentoStraordinario.
     * @param {InserimentoStraordinarioUpdateArgs} args - Arguments to update one InserimentoStraordinario.
     * @example
     * // Update one InserimentoStraordinario
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InserimentoStraordinarioUpdateArgs>(args: SelectSubset<T, InserimentoStraordinarioUpdateArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InserimentoStraordinarios.
     * @param {InserimentoStraordinarioDeleteManyArgs} args - Arguments to filter InserimentoStraordinarios to delete.
     * @example
     * // Delete a few InserimentoStraordinarios
     * const { count } = await prisma.inserimentoStraordinario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InserimentoStraordinarioDeleteManyArgs>(args?: SelectSubset<T, InserimentoStraordinarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InserimentoStraordinarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InserimentoStraordinarios
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InserimentoStraordinarioUpdateManyArgs>(args: SelectSubset<T, InserimentoStraordinarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InserimentoStraordinarios and returns the data updated in the database.
     * @param {InserimentoStraordinarioUpdateManyAndReturnArgs} args - Arguments to update many InserimentoStraordinarios.
     * @example
     * // Update many InserimentoStraordinarios
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InserimentoStraordinarios and only return the `id`
     * const inserimentoStraordinarioWithIdOnly = await prisma.inserimentoStraordinario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InserimentoStraordinarioUpdateManyAndReturnArgs>(args: SelectSubset<T, InserimentoStraordinarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InserimentoStraordinario.
     * @param {InserimentoStraordinarioUpsertArgs} args - Arguments to update or create a InserimentoStraordinario.
     * @example
     * // Update or create a InserimentoStraordinario
     * const inserimentoStraordinario = await prisma.inserimentoStraordinario.upsert({
     *   create: {
     *     // ... data to create a InserimentoStraordinario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InserimentoStraordinario we want to update
     *   }
     * })
     */
    upsert<T extends InserimentoStraordinarioUpsertArgs>(args: SelectSubset<T, InserimentoStraordinarioUpsertArgs<ExtArgs>>): Prisma__InserimentoStraordinarioClient<$Result.GetResult<Prisma.$InserimentoStraordinarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InserimentoStraordinarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioCountArgs} args - Arguments to filter InserimentoStraordinarios to count.
     * @example
     * // Count the number of InserimentoStraordinarios
     * const count = await prisma.inserimentoStraordinario.count({
     *   where: {
     *     // ... the filter for the InserimentoStraordinarios we want to count
     *   }
     * })
    **/
    count<T extends InserimentoStraordinarioCountArgs>(
      args?: Subset<T, InserimentoStraordinarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InserimentoStraordinarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InserimentoStraordinario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InserimentoStraordinarioAggregateArgs>(args: Subset<T, InserimentoStraordinarioAggregateArgs>): Prisma.PrismaPromise<GetInserimentoStraordinarioAggregateType<T>>

    /**
     * Group by InserimentoStraordinario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InserimentoStraordinarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InserimentoStraordinarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InserimentoStraordinarioGroupByArgs['orderBy'] }
        : { orderBy?: InserimentoStraordinarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InserimentoStraordinarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInserimentoStraordinarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InserimentoStraordinario model
   */
  readonly fields: InserimentoStraordinarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InserimentoStraordinario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InserimentoStraordinarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InserimentoStraordinario model
   */
  interface InserimentoStraordinarioFieldRefs {
    readonly id: FieldRef<"InserimentoStraordinario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InserimentoStraordinario findUnique
   */
  export type InserimentoStraordinarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which InserimentoStraordinario to fetch.
     */
    where: InserimentoStraordinarioWhereUniqueInput
  }

  /**
   * InserimentoStraordinario findUniqueOrThrow
   */
  export type InserimentoStraordinarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which InserimentoStraordinario to fetch.
     */
    where: InserimentoStraordinarioWhereUniqueInput
  }

  /**
   * InserimentoStraordinario findFirst
   */
  export type InserimentoStraordinarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which InserimentoStraordinario to fetch.
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InserimentoStraordinarios to fetch.
     */
    orderBy?: InserimentoStraordinarioOrderByWithRelationInput | InserimentoStraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InserimentoStraordinarios.
     */
    cursor?: InserimentoStraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InserimentoStraordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InserimentoStraordinarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InserimentoStraordinarios.
     */
    distinct?: InserimentoStraordinarioScalarFieldEnum | InserimentoStraordinarioScalarFieldEnum[]
  }

  /**
   * InserimentoStraordinario findFirstOrThrow
   */
  export type InserimentoStraordinarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which InserimentoStraordinario to fetch.
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InserimentoStraordinarios to fetch.
     */
    orderBy?: InserimentoStraordinarioOrderByWithRelationInput | InserimentoStraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InserimentoStraordinarios.
     */
    cursor?: InserimentoStraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InserimentoStraordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InserimentoStraordinarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InserimentoStraordinarios.
     */
    distinct?: InserimentoStraordinarioScalarFieldEnum | InserimentoStraordinarioScalarFieldEnum[]
  }

  /**
   * InserimentoStraordinario findMany
   */
  export type InserimentoStraordinarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * Filter, which InserimentoStraordinarios to fetch.
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InserimentoStraordinarios to fetch.
     */
    orderBy?: InserimentoStraordinarioOrderByWithRelationInput | InserimentoStraordinarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InserimentoStraordinarios.
     */
    cursor?: InserimentoStraordinarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InserimentoStraordinarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InserimentoStraordinarios.
     */
    skip?: number
    distinct?: InserimentoStraordinarioScalarFieldEnum | InserimentoStraordinarioScalarFieldEnum[]
  }

  /**
   * InserimentoStraordinario create
   */
  export type InserimentoStraordinarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * The data needed to create a InserimentoStraordinario.
     */
    data?: XOR<InserimentoStraordinarioCreateInput, InserimentoStraordinarioUncheckedCreateInput>
  }

  /**
   * InserimentoStraordinario createMany
   */
  export type InserimentoStraordinarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InserimentoStraordinarios.
     */
    data: InserimentoStraordinarioCreateManyInput | InserimentoStraordinarioCreateManyInput[]
  }

  /**
   * InserimentoStraordinario createManyAndReturn
   */
  export type InserimentoStraordinarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * The data used to create many InserimentoStraordinarios.
     */
    data: InserimentoStraordinarioCreateManyInput | InserimentoStraordinarioCreateManyInput[]
  }

  /**
   * InserimentoStraordinario update
   */
  export type InserimentoStraordinarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * The data needed to update a InserimentoStraordinario.
     */
    data: XOR<InserimentoStraordinarioUpdateInput, InserimentoStraordinarioUncheckedUpdateInput>
    /**
     * Choose, which InserimentoStraordinario to update.
     */
    where: InserimentoStraordinarioWhereUniqueInput
  }

  /**
   * InserimentoStraordinario updateMany
   */
  export type InserimentoStraordinarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InserimentoStraordinarios.
     */
    data: XOR<InserimentoStraordinarioUpdateManyMutationInput, InserimentoStraordinarioUncheckedUpdateManyInput>
    /**
     * Filter which InserimentoStraordinarios to update
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * Limit how many InserimentoStraordinarios to update.
     */
    limit?: number
  }

  /**
   * InserimentoStraordinario updateManyAndReturn
   */
  export type InserimentoStraordinarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * The data used to update InserimentoStraordinarios.
     */
    data: XOR<InserimentoStraordinarioUpdateManyMutationInput, InserimentoStraordinarioUncheckedUpdateManyInput>
    /**
     * Filter which InserimentoStraordinarios to update
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * Limit how many InserimentoStraordinarios to update.
     */
    limit?: number
  }

  /**
   * InserimentoStraordinario upsert
   */
  export type InserimentoStraordinarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * The filter to search for the InserimentoStraordinario to update in case it exists.
     */
    where: InserimentoStraordinarioWhereUniqueInput
    /**
     * In case the InserimentoStraordinario found by the `where` argument doesn't exist, create a new InserimentoStraordinario with this data.
     */
    create: XOR<InserimentoStraordinarioCreateInput, InserimentoStraordinarioUncheckedCreateInput>
    /**
     * In case the InserimentoStraordinario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InserimentoStraordinarioUpdateInput, InserimentoStraordinarioUncheckedUpdateInput>
  }

  /**
   * InserimentoStraordinario delete
   */
  export type InserimentoStraordinarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
    /**
     * Filter which InserimentoStraordinario to delete.
     */
    where: InserimentoStraordinarioWhereUniqueInput
  }

  /**
   * InserimentoStraordinario deleteMany
   */
  export type InserimentoStraordinarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InserimentoStraordinarios to delete
     */
    where?: InserimentoStraordinarioWhereInput
    /**
     * Limit how many InserimentoStraordinarios to delete.
     */
    limit?: number
  }

  /**
   * InserimentoStraordinario without action
   */
  export type InserimentoStraordinarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InserimentoStraordinario
     */
    select?: InserimentoStraordinarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InserimentoStraordinario
     */
    omit?: InserimentoStraordinarioOmit<ExtArgs> | null
  }


  /**
   * Model ImpostazioniUtente
   */

  export type AggregateImpostazioniUtente = {
    _count: ImpostazioniUtenteCountAggregateOutputType | null
    _avg: ImpostazioniUtenteAvgAggregateOutputType | null
    _sum: ImpostazioniUtenteSumAggregateOutputType | null
    _min: ImpostazioniUtenteMinAggregateOutputType | null
    _max: ImpostazioniUtenteMaxAggregateOutputType | null
  }

  export type ImpostazioniUtenteAvgAggregateOutputType = {
    id: number | null
  }

  export type ImpostazioniUtenteSumAggregateOutputType = {
    id: number | null
  }

  export type ImpostazioniUtenteMinAggregateOutputType = {
    id: number | null
  }

  export type ImpostazioniUtenteMaxAggregateOutputType = {
    id: number | null
  }

  export type ImpostazioniUtenteCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ImpostazioniUtenteAvgAggregateInputType = {
    id?: true
  }

  export type ImpostazioniUtenteSumAggregateInputType = {
    id?: true
  }

  export type ImpostazioniUtenteMinAggregateInputType = {
    id?: true
  }

  export type ImpostazioniUtenteMaxAggregateInputType = {
    id?: true
  }

  export type ImpostazioniUtenteCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ImpostazioniUtenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImpostazioniUtente to aggregate.
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpostazioniUtentes to fetch.
     */
    orderBy?: ImpostazioniUtenteOrderByWithRelationInput | ImpostazioniUtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpostazioniUtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpostazioniUtentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpostazioniUtentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImpostazioniUtentes
    **/
    _count?: true | ImpostazioniUtenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImpostazioniUtenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImpostazioniUtenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpostazioniUtenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpostazioniUtenteMaxAggregateInputType
  }

  export type GetImpostazioniUtenteAggregateType<T extends ImpostazioniUtenteAggregateArgs> = {
        [P in keyof T & keyof AggregateImpostazioniUtente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpostazioniUtente[P]>
      : GetScalarType<T[P], AggregateImpostazioniUtente[P]>
  }




  export type ImpostazioniUtenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpostazioniUtenteWhereInput
    orderBy?: ImpostazioniUtenteOrderByWithAggregationInput | ImpostazioniUtenteOrderByWithAggregationInput[]
    by: ImpostazioniUtenteScalarFieldEnum[] | ImpostazioniUtenteScalarFieldEnum
    having?: ImpostazioniUtenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpostazioniUtenteCountAggregateInputType | true
    _avg?: ImpostazioniUtenteAvgAggregateInputType
    _sum?: ImpostazioniUtenteSumAggregateInputType
    _min?: ImpostazioniUtenteMinAggregateInputType
    _max?: ImpostazioniUtenteMaxAggregateInputType
  }

  export type ImpostazioniUtenteGroupByOutputType = {
    id: number
    _count: ImpostazioniUtenteCountAggregateOutputType | null
    _avg: ImpostazioniUtenteAvgAggregateOutputType | null
    _sum: ImpostazioniUtenteSumAggregateOutputType | null
    _min: ImpostazioniUtenteMinAggregateOutputType | null
    _max: ImpostazioniUtenteMaxAggregateOutputType | null
  }

  type GetImpostazioniUtenteGroupByPayload<T extends ImpostazioniUtenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImpostazioniUtenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpostazioniUtenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpostazioniUtenteGroupByOutputType[P]>
            : GetScalarType<T[P], ImpostazioniUtenteGroupByOutputType[P]>
        }
      >
    >


  export type ImpostazioniUtenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["impostazioniUtente"]>

  export type ImpostazioniUtenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["impostazioniUtente"]>

  export type ImpostazioniUtenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["impostazioniUtente"]>

  export type ImpostazioniUtenteSelectScalar = {
    id?: boolean
  }

  export type ImpostazioniUtenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["impostazioniUtente"]>

  export type $ImpostazioniUtentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImpostazioniUtente"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["impostazioniUtente"]>
    composites: {}
  }

  type ImpostazioniUtenteGetPayload<S extends boolean | null | undefined | ImpostazioniUtenteDefaultArgs> = $Result.GetResult<Prisma.$ImpostazioniUtentePayload, S>

  type ImpostazioniUtenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImpostazioniUtenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImpostazioniUtenteCountAggregateInputType | true
    }

  export interface ImpostazioniUtenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImpostazioniUtente'], meta: { name: 'ImpostazioniUtente' } }
    /**
     * Find zero or one ImpostazioniUtente that matches the filter.
     * @param {ImpostazioniUtenteFindUniqueArgs} args - Arguments to find a ImpostazioniUtente
     * @example
     * // Get one ImpostazioniUtente
     * const impostazioniUtente = await prisma.impostazioniUtente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImpostazioniUtenteFindUniqueArgs>(args: SelectSubset<T, ImpostazioniUtenteFindUniqueArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImpostazioniUtente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImpostazioniUtenteFindUniqueOrThrowArgs} args - Arguments to find a ImpostazioniUtente
     * @example
     * // Get one ImpostazioniUtente
     * const impostazioniUtente = await prisma.impostazioniUtente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImpostazioniUtenteFindUniqueOrThrowArgs>(args: SelectSubset<T, ImpostazioniUtenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImpostazioniUtente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteFindFirstArgs} args - Arguments to find a ImpostazioniUtente
     * @example
     * // Get one ImpostazioniUtente
     * const impostazioniUtente = await prisma.impostazioniUtente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImpostazioniUtenteFindFirstArgs>(args?: SelectSubset<T, ImpostazioniUtenteFindFirstArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImpostazioniUtente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteFindFirstOrThrowArgs} args - Arguments to find a ImpostazioniUtente
     * @example
     * // Get one ImpostazioniUtente
     * const impostazioniUtente = await prisma.impostazioniUtente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImpostazioniUtenteFindFirstOrThrowArgs>(args?: SelectSubset<T, ImpostazioniUtenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImpostazioniUtentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImpostazioniUtentes
     * const impostazioniUtentes = await prisma.impostazioniUtente.findMany()
     * 
     * // Get first 10 ImpostazioniUtentes
     * const impostazioniUtentes = await prisma.impostazioniUtente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impostazioniUtenteWithIdOnly = await prisma.impostazioniUtente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImpostazioniUtenteFindManyArgs>(args?: SelectSubset<T, ImpostazioniUtenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImpostazioniUtente.
     * @param {ImpostazioniUtenteCreateArgs} args - Arguments to create a ImpostazioniUtente.
     * @example
     * // Create one ImpostazioniUtente
     * const ImpostazioniUtente = await prisma.impostazioniUtente.create({
     *   data: {
     *     // ... data to create a ImpostazioniUtente
     *   }
     * })
     * 
     */
    create<T extends ImpostazioniUtenteCreateArgs>(args: SelectSubset<T, ImpostazioniUtenteCreateArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImpostazioniUtentes.
     * @param {ImpostazioniUtenteCreateManyArgs} args - Arguments to create many ImpostazioniUtentes.
     * @example
     * // Create many ImpostazioniUtentes
     * const impostazioniUtente = await prisma.impostazioniUtente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImpostazioniUtenteCreateManyArgs>(args?: SelectSubset<T, ImpostazioniUtenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImpostazioniUtentes and returns the data saved in the database.
     * @param {ImpostazioniUtenteCreateManyAndReturnArgs} args - Arguments to create many ImpostazioniUtentes.
     * @example
     * // Create many ImpostazioniUtentes
     * const impostazioniUtente = await prisma.impostazioniUtente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImpostazioniUtentes and only return the `id`
     * const impostazioniUtenteWithIdOnly = await prisma.impostazioniUtente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImpostazioniUtenteCreateManyAndReturnArgs>(args?: SelectSubset<T, ImpostazioniUtenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImpostazioniUtente.
     * @param {ImpostazioniUtenteDeleteArgs} args - Arguments to delete one ImpostazioniUtente.
     * @example
     * // Delete one ImpostazioniUtente
     * const ImpostazioniUtente = await prisma.impostazioniUtente.delete({
     *   where: {
     *     // ... filter to delete one ImpostazioniUtente
     *   }
     * })
     * 
     */
    delete<T extends ImpostazioniUtenteDeleteArgs>(args: SelectSubset<T, ImpostazioniUtenteDeleteArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImpostazioniUtente.
     * @param {ImpostazioniUtenteUpdateArgs} args - Arguments to update one ImpostazioniUtente.
     * @example
     * // Update one ImpostazioniUtente
     * const impostazioniUtente = await prisma.impostazioniUtente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImpostazioniUtenteUpdateArgs>(args: SelectSubset<T, ImpostazioniUtenteUpdateArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImpostazioniUtentes.
     * @param {ImpostazioniUtenteDeleteManyArgs} args - Arguments to filter ImpostazioniUtentes to delete.
     * @example
     * // Delete a few ImpostazioniUtentes
     * const { count } = await prisma.impostazioniUtente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImpostazioniUtenteDeleteManyArgs>(args?: SelectSubset<T, ImpostazioniUtenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImpostazioniUtentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImpostazioniUtentes
     * const impostazioniUtente = await prisma.impostazioniUtente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImpostazioniUtenteUpdateManyArgs>(args: SelectSubset<T, ImpostazioniUtenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImpostazioniUtentes and returns the data updated in the database.
     * @param {ImpostazioniUtenteUpdateManyAndReturnArgs} args - Arguments to update many ImpostazioniUtentes.
     * @example
     * // Update many ImpostazioniUtentes
     * const impostazioniUtente = await prisma.impostazioniUtente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImpostazioniUtentes and only return the `id`
     * const impostazioniUtenteWithIdOnly = await prisma.impostazioniUtente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImpostazioniUtenteUpdateManyAndReturnArgs>(args: SelectSubset<T, ImpostazioniUtenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImpostazioniUtente.
     * @param {ImpostazioniUtenteUpsertArgs} args - Arguments to update or create a ImpostazioniUtente.
     * @example
     * // Update or create a ImpostazioniUtente
     * const impostazioniUtente = await prisma.impostazioniUtente.upsert({
     *   create: {
     *     // ... data to create a ImpostazioniUtente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImpostazioniUtente we want to update
     *   }
     * })
     */
    upsert<T extends ImpostazioniUtenteUpsertArgs>(args: SelectSubset<T, ImpostazioniUtenteUpsertArgs<ExtArgs>>): Prisma__ImpostazioniUtenteClient<$Result.GetResult<Prisma.$ImpostazioniUtentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImpostazioniUtentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteCountArgs} args - Arguments to filter ImpostazioniUtentes to count.
     * @example
     * // Count the number of ImpostazioniUtentes
     * const count = await prisma.impostazioniUtente.count({
     *   where: {
     *     // ... the filter for the ImpostazioniUtentes we want to count
     *   }
     * })
    **/
    count<T extends ImpostazioniUtenteCountArgs>(
      args?: Subset<T, ImpostazioniUtenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpostazioniUtenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImpostazioniUtente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpostazioniUtenteAggregateArgs>(args: Subset<T, ImpostazioniUtenteAggregateArgs>): Prisma.PrismaPromise<GetImpostazioniUtenteAggregateType<T>>

    /**
     * Group by ImpostazioniUtente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpostazioniUtenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpostazioniUtenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpostazioniUtenteGroupByArgs['orderBy'] }
        : { orderBy?: ImpostazioniUtenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpostazioniUtenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpostazioniUtenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImpostazioniUtente model
   */
  readonly fields: ImpostazioniUtenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImpostazioniUtente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImpostazioniUtenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImpostazioniUtente model
   */
  interface ImpostazioniUtenteFieldRefs {
    readonly id: FieldRef<"ImpostazioniUtente", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ImpostazioniUtente findUnique
   */
  export type ImpostazioniUtenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * Filter, which ImpostazioniUtente to fetch.
     */
    where: ImpostazioniUtenteWhereUniqueInput
  }

  /**
   * ImpostazioniUtente findUniqueOrThrow
   */
  export type ImpostazioniUtenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * Filter, which ImpostazioniUtente to fetch.
     */
    where: ImpostazioniUtenteWhereUniqueInput
  }

  /**
   * ImpostazioniUtente findFirst
   */
  export type ImpostazioniUtenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * Filter, which ImpostazioniUtente to fetch.
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpostazioniUtentes to fetch.
     */
    orderBy?: ImpostazioniUtenteOrderByWithRelationInput | ImpostazioniUtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpostazioniUtentes.
     */
    cursor?: ImpostazioniUtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpostazioniUtentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpostazioniUtentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpostazioniUtentes.
     */
    distinct?: ImpostazioniUtenteScalarFieldEnum | ImpostazioniUtenteScalarFieldEnum[]
  }

  /**
   * ImpostazioniUtente findFirstOrThrow
   */
  export type ImpostazioniUtenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * Filter, which ImpostazioniUtente to fetch.
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpostazioniUtentes to fetch.
     */
    orderBy?: ImpostazioniUtenteOrderByWithRelationInput | ImpostazioniUtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpostazioniUtentes.
     */
    cursor?: ImpostazioniUtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpostazioniUtentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpostazioniUtentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpostazioniUtentes.
     */
    distinct?: ImpostazioniUtenteScalarFieldEnum | ImpostazioniUtenteScalarFieldEnum[]
  }

  /**
   * ImpostazioniUtente findMany
   */
  export type ImpostazioniUtenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * Filter, which ImpostazioniUtentes to fetch.
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpostazioniUtentes to fetch.
     */
    orderBy?: ImpostazioniUtenteOrderByWithRelationInput | ImpostazioniUtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImpostazioniUtentes.
     */
    cursor?: ImpostazioniUtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpostazioniUtentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpostazioniUtentes.
     */
    skip?: number
    distinct?: ImpostazioniUtenteScalarFieldEnum | ImpostazioniUtenteScalarFieldEnum[]
  }

  /**
   * ImpostazioniUtente create
   */
  export type ImpostazioniUtenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * The data needed to create a ImpostazioniUtente.
     */
    data?: XOR<ImpostazioniUtenteCreateInput, ImpostazioniUtenteUncheckedCreateInput>
  }

  /**
   * ImpostazioniUtente createMany
   */
  export type ImpostazioniUtenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImpostazioniUtentes.
     */
    data: ImpostazioniUtenteCreateManyInput | ImpostazioniUtenteCreateManyInput[]
  }

  /**
   * ImpostazioniUtente createManyAndReturn
   */
  export type ImpostazioniUtenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * The data used to create many ImpostazioniUtentes.
     */
    data: ImpostazioniUtenteCreateManyInput | ImpostazioniUtenteCreateManyInput[]
  }

  /**
   * ImpostazioniUtente update
   */
  export type ImpostazioniUtenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * The data needed to update a ImpostazioniUtente.
     */
    data: XOR<ImpostazioniUtenteUpdateInput, ImpostazioniUtenteUncheckedUpdateInput>
    /**
     * Choose, which ImpostazioniUtente to update.
     */
    where: ImpostazioniUtenteWhereUniqueInput
  }

  /**
   * ImpostazioniUtente updateMany
   */
  export type ImpostazioniUtenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImpostazioniUtentes.
     */
    data: XOR<ImpostazioniUtenteUpdateManyMutationInput, ImpostazioniUtenteUncheckedUpdateManyInput>
    /**
     * Filter which ImpostazioniUtentes to update
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * Limit how many ImpostazioniUtentes to update.
     */
    limit?: number
  }

  /**
   * ImpostazioniUtente updateManyAndReturn
   */
  export type ImpostazioniUtenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * The data used to update ImpostazioniUtentes.
     */
    data: XOR<ImpostazioniUtenteUpdateManyMutationInput, ImpostazioniUtenteUncheckedUpdateManyInput>
    /**
     * Filter which ImpostazioniUtentes to update
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * Limit how many ImpostazioniUtentes to update.
     */
    limit?: number
  }

  /**
   * ImpostazioniUtente upsert
   */
  export type ImpostazioniUtenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * The filter to search for the ImpostazioniUtente to update in case it exists.
     */
    where: ImpostazioniUtenteWhereUniqueInput
    /**
     * In case the ImpostazioniUtente found by the `where` argument doesn't exist, create a new ImpostazioniUtente with this data.
     */
    create: XOR<ImpostazioniUtenteCreateInput, ImpostazioniUtenteUncheckedCreateInput>
    /**
     * In case the ImpostazioniUtente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpostazioniUtenteUpdateInput, ImpostazioniUtenteUncheckedUpdateInput>
  }

  /**
   * ImpostazioniUtente delete
   */
  export type ImpostazioniUtenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
    /**
     * Filter which ImpostazioniUtente to delete.
     */
    where: ImpostazioniUtenteWhereUniqueInput
  }

  /**
   * ImpostazioniUtente deleteMany
   */
  export type ImpostazioniUtenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImpostazioniUtentes to delete
     */
    where?: ImpostazioniUtenteWhereInput
    /**
     * Limit how many ImpostazioniUtentes to delete.
     */
    limit?: number
  }

  /**
   * ImpostazioniUtente without action
   */
  export type ImpostazioniUtenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpostazioniUtente
     */
    select?: ImpostazioniUtenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImpostazioniUtente
     */
    omit?: ImpostazioniUtenteOmit<ExtArgs> | null
  }


  /**
   * Model SpeseNotti
   */

  export type AggregateSpeseNotti = {
    _count: SpeseNottiCountAggregateOutputType | null
    _avg: SpeseNottiAvgAggregateOutputType | null
    _sum: SpeseNottiSumAggregateOutputType | null
    _min: SpeseNottiMinAggregateOutputType | null
    _max: SpeseNottiMaxAggregateOutputType | null
  }

  export type SpeseNottiAvgAggregateOutputType = {
    id: number | null
  }

  export type SpeseNottiSumAggregateOutputType = {
    id: number | null
  }

  export type SpeseNottiMinAggregateOutputType = {
    id: number | null
  }

  export type SpeseNottiMaxAggregateOutputType = {
    id: number | null
  }

  export type SpeseNottiCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type SpeseNottiAvgAggregateInputType = {
    id?: true
  }

  export type SpeseNottiSumAggregateInputType = {
    id?: true
  }

  export type SpeseNottiMinAggregateInputType = {
    id?: true
  }

  export type SpeseNottiMaxAggregateInputType = {
    id?: true
  }

  export type SpeseNottiCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type SpeseNottiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeseNotti to aggregate.
     */
    where?: SpeseNottiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeseNottis to fetch.
     */
    orderBy?: SpeseNottiOrderByWithRelationInput | SpeseNottiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeseNottiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeseNottis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeseNottis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeseNottis
    **/
    _count?: true | SpeseNottiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeseNottiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeseNottiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeseNottiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeseNottiMaxAggregateInputType
  }

  export type GetSpeseNottiAggregateType<T extends SpeseNottiAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeseNotti]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeseNotti[P]>
      : GetScalarType<T[P], AggregateSpeseNotti[P]>
  }




  export type SpeseNottiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeseNottiWhereInput
    orderBy?: SpeseNottiOrderByWithAggregationInput | SpeseNottiOrderByWithAggregationInput[]
    by: SpeseNottiScalarFieldEnum[] | SpeseNottiScalarFieldEnum
    having?: SpeseNottiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeseNottiCountAggregateInputType | true
    _avg?: SpeseNottiAvgAggregateInputType
    _sum?: SpeseNottiSumAggregateInputType
    _min?: SpeseNottiMinAggregateInputType
    _max?: SpeseNottiMaxAggregateInputType
  }

  export type SpeseNottiGroupByOutputType = {
    id: number
    _count: SpeseNottiCountAggregateOutputType | null
    _avg: SpeseNottiAvgAggregateOutputType | null
    _sum: SpeseNottiSumAggregateOutputType | null
    _min: SpeseNottiMinAggregateOutputType | null
    _max: SpeseNottiMaxAggregateOutputType | null
  }

  type GetSpeseNottiGroupByPayload<T extends SpeseNottiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeseNottiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeseNottiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeseNottiGroupByOutputType[P]>
            : GetScalarType<T[P], SpeseNottiGroupByOutputType[P]>
        }
      >
    >


  export type SpeseNottiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["speseNotti"]>

  export type SpeseNottiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["speseNotti"]>

  export type SpeseNottiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["speseNotti"]>

  export type SpeseNottiSelectScalar = {
    id?: boolean
  }

  export type SpeseNottiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["speseNotti"]>

  export type $SpeseNottiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeseNotti"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
    }, ExtArgs["result"]["speseNotti"]>
    composites: {}
  }

  type SpeseNottiGetPayload<S extends boolean | null | undefined | SpeseNottiDefaultArgs> = $Result.GetResult<Prisma.$SpeseNottiPayload, S>

  type SpeseNottiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeseNottiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeseNottiCountAggregateInputType | true
    }

  export interface SpeseNottiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeseNotti'], meta: { name: 'SpeseNotti' } }
    /**
     * Find zero or one SpeseNotti that matches the filter.
     * @param {SpeseNottiFindUniqueArgs} args - Arguments to find a SpeseNotti
     * @example
     * // Get one SpeseNotti
     * const speseNotti = await prisma.speseNotti.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeseNottiFindUniqueArgs>(args: SelectSubset<T, SpeseNottiFindUniqueArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpeseNotti that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeseNottiFindUniqueOrThrowArgs} args - Arguments to find a SpeseNotti
     * @example
     * // Get one SpeseNotti
     * const speseNotti = await prisma.speseNotti.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeseNottiFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeseNottiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeseNotti that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiFindFirstArgs} args - Arguments to find a SpeseNotti
     * @example
     * // Get one SpeseNotti
     * const speseNotti = await prisma.speseNotti.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeseNottiFindFirstArgs>(args?: SelectSubset<T, SpeseNottiFindFirstArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeseNotti that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiFindFirstOrThrowArgs} args - Arguments to find a SpeseNotti
     * @example
     * // Get one SpeseNotti
     * const speseNotti = await prisma.speseNotti.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeseNottiFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeseNottiFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpeseNottis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeseNottis
     * const speseNottis = await prisma.speseNotti.findMany()
     * 
     * // Get first 10 SpeseNottis
     * const speseNottis = await prisma.speseNotti.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speseNottiWithIdOnly = await prisma.speseNotti.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeseNottiFindManyArgs>(args?: SelectSubset<T, SpeseNottiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpeseNotti.
     * @param {SpeseNottiCreateArgs} args - Arguments to create a SpeseNotti.
     * @example
     * // Create one SpeseNotti
     * const SpeseNotti = await prisma.speseNotti.create({
     *   data: {
     *     // ... data to create a SpeseNotti
     *   }
     * })
     * 
     */
    create<T extends SpeseNottiCreateArgs>(args: SelectSubset<T, SpeseNottiCreateArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpeseNottis.
     * @param {SpeseNottiCreateManyArgs} args - Arguments to create many SpeseNottis.
     * @example
     * // Create many SpeseNottis
     * const speseNotti = await prisma.speseNotti.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeseNottiCreateManyArgs>(args?: SelectSubset<T, SpeseNottiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeseNottis and returns the data saved in the database.
     * @param {SpeseNottiCreateManyAndReturnArgs} args - Arguments to create many SpeseNottis.
     * @example
     * // Create many SpeseNottis
     * const speseNotti = await prisma.speseNotti.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeseNottis and only return the `id`
     * const speseNottiWithIdOnly = await prisma.speseNotti.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeseNottiCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeseNottiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpeseNotti.
     * @param {SpeseNottiDeleteArgs} args - Arguments to delete one SpeseNotti.
     * @example
     * // Delete one SpeseNotti
     * const SpeseNotti = await prisma.speseNotti.delete({
     *   where: {
     *     // ... filter to delete one SpeseNotti
     *   }
     * })
     * 
     */
    delete<T extends SpeseNottiDeleteArgs>(args: SelectSubset<T, SpeseNottiDeleteArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpeseNotti.
     * @param {SpeseNottiUpdateArgs} args - Arguments to update one SpeseNotti.
     * @example
     * // Update one SpeseNotti
     * const speseNotti = await prisma.speseNotti.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeseNottiUpdateArgs>(args: SelectSubset<T, SpeseNottiUpdateArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpeseNottis.
     * @param {SpeseNottiDeleteManyArgs} args - Arguments to filter SpeseNottis to delete.
     * @example
     * // Delete a few SpeseNottis
     * const { count } = await prisma.speseNotti.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeseNottiDeleteManyArgs>(args?: SelectSubset<T, SpeseNottiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeseNottis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeseNottis
     * const speseNotti = await prisma.speseNotti.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeseNottiUpdateManyArgs>(args: SelectSubset<T, SpeseNottiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeseNottis and returns the data updated in the database.
     * @param {SpeseNottiUpdateManyAndReturnArgs} args - Arguments to update many SpeseNottis.
     * @example
     * // Update many SpeseNottis
     * const speseNotti = await prisma.speseNotti.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpeseNottis and only return the `id`
     * const speseNottiWithIdOnly = await prisma.speseNotti.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpeseNottiUpdateManyAndReturnArgs>(args: SelectSubset<T, SpeseNottiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpeseNotti.
     * @param {SpeseNottiUpsertArgs} args - Arguments to update or create a SpeseNotti.
     * @example
     * // Update or create a SpeseNotti
     * const speseNotti = await prisma.speseNotti.upsert({
     *   create: {
     *     // ... data to create a SpeseNotti
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeseNotti we want to update
     *   }
     * })
     */
    upsert<T extends SpeseNottiUpsertArgs>(args: SelectSubset<T, SpeseNottiUpsertArgs<ExtArgs>>): Prisma__SpeseNottiClient<$Result.GetResult<Prisma.$SpeseNottiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpeseNottis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiCountArgs} args - Arguments to filter SpeseNottis to count.
     * @example
     * // Count the number of SpeseNottis
     * const count = await prisma.speseNotti.count({
     *   where: {
     *     // ... the filter for the SpeseNottis we want to count
     *   }
     * })
    **/
    count<T extends SpeseNottiCountArgs>(
      args?: Subset<T, SpeseNottiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeseNottiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeseNotti.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeseNottiAggregateArgs>(args: Subset<T, SpeseNottiAggregateArgs>): Prisma.PrismaPromise<GetSpeseNottiAggregateType<T>>

    /**
     * Group by SpeseNotti.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeseNottiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeseNottiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeseNottiGroupByArgs['orderBy'] }
        : { orderBy?: SpeseNottiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeseNottiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeseNottiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeseNotti model
   */
  readonly fields: SpeseNottiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeseNotti.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeseNottiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeseNotti model
   */
  interface SpeseNottiFieldRefs {
    readonly id: FieldRef<"SpeseNotti", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpeseNotti findUnique
   */
  export type SpeseNottiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * Filter, which SpeseNotti to fetch.
     */
    where: SpeseNottiWhereUniqueInput
  }

  /**
   * SpeseNotti findUniqueOrThrow
   */
  export type SpeseNottiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * Filter, which SpeseNotti to fetch.
     */
    where: SpeseNottiWhereUniqueInput
  }

  /**
   * SpeseNotti findFirst
   */
  export type SpeseNottiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * Filter, which SpeseNotti to fetch.
     */
    where?: SpeseNottiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeseNottis to fetch.
     */
    orderBy?: SpeseNottiOrderByWithRelationInput | SpeseNottiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeseNottis.
     */
    cursor?: SpeseNottiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeseNottis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeseNottis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeseNottis.
     */
    distinct?: SpeseNottiScalarFieldEnum | SpeseNottiScalarFieldEnum[]
  }

  /**
   * SpeseNotti findFirstOrThrow
   */
  export type SpeseNottiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * Filter, which SpeseNotti to fetch.
     */
    where?: SpeseNottiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeseNottis to fetch.
     */
    orderBy?: SpeseNottiOrderByWithRelationInput | SpeseNottiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeseNottis.
     */
    cursor?: SpeseNottiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeseNottis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeseNottis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeseNottis.
     */
    distinct?: SpeseNottiScalarFieldEnum | SpeseNottiScalarFieldEnum[]
  }

  /**
   * SpeseNotti findMany
   */
  export type SpeseNottiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * Filter, which SpeseNottis to fetch.
     */
    where?: SpeseNottiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeseNottis to fetch.
     */
    orderBy?: SpeseNottiOrderByWithRelationInput | SpeseNottiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeseNottis.
     */
    cursor?: SpeseNottiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeseNottis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeseNottis.
     */
    skip?: number
    distinct?: SpeseNottiScalarFieldEnum | SpeseNottiScalarFieldEnum[]
  }

  /**
   * SpeseNotti create
   */
  export type SpeseNottiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * The data needed to create a SpeseNotti.
     */
    data?: XOR<SpeseNottiCreateInput, SpeseNottiUncheckedCreateInput>
  }

  /**
   * SpeseNotti createMany
   */
  export type SpeseNottiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeseNottis.
     */
    data: SpeseNottiCreateManyInput | SpeseNottiCreateManyInput[]
  }

  /**
   * SpeseNotti createManyAndReturn
   */
  export type SpeseNottiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * The data used to create many SpeseNottis.
     */
    data: SpeseNottiCreateManyInput | SpeseNottiCreateManyInput[]
  }

  /**
   * SpeseNotti update
   */
  export type SpeseNottiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * The data needed to update a SpeseNotti.
     */
    data: XOR<SpeseNottiUpdateInput, SpeseNottiUncheckedUpdateInput>
    /**
     * Choose, which SpeseNotti to update.
     */
    where: SpeseNottiWhereUniqueInput
  }

  /**
   * SpeseNotti updateMany
   */
  export type SpeseNottiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeseNottis.
     */
    data: XOR<SpeseNottiUpdateManyMutationInput, SpeseNottiUncheckedUpdateManyInput>
    /**
     * Filter which SpeseNottis to update
     */
    where?: SpeseNottiWhereInput
    /**
     * Limit how many SpeseNottis to update.
     */
    limit?: number
  }

  /**
   * SpeseNotti updateManyAndReturn
   */
  export type SpeseNottiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * The data used to update SpeseNottis.
     */
    data: XOR<SpeseNottiUpdateManyMutationInput, SpeseNottiUncheckedUpdateManyInput>
    /**
     * Filter which SpeseNottis to update
     */
    where?: SpeseNottiWhereInput
    /**
     * Limit how many SpeseNottis to update.
     */
    limit?: number
  }

  /**
   * SpeseNotti upsert
   */
  export type SpeseNottiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * The filter to search for the SpeseNotti to update in case it exists.
     */
    where: SpeseNottiWhereUniqueInput
    /**
     * In case the SpeseNotti found by the `where` argument doesn't exist, create a new SpeseNotti with this data.
     */
    create: XOR<SpeseNottiCreateInput, SpeseNottiUncheckedCreateInput>
    /**
     * In case the SpeseNotti was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeseNottiUpdateInput, SpeseNottiUncheckedUpdateInput>
  }

  /**
   * SpeseNotti delete
   */
  export type SpeseNottiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
    /**
     * Filter which SpeseNotti to delete.
     */
    where: SpeseNottiWhereUniqueInput
  }

  /**
   * SpeseNotti deleteMany
   */
  export type SpeseNottiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeseNottis to delete
     */
    where?: SpeseNottiWhereInput
    /**
     * Limit how many SpeseNottis to delete.
     */
    limit?: number
  }

  /**
   * SpeseNotti without action
   */
  export type SpeseNottiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeseNotti
     */
    select?: SpeseNottiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeseNotti
     */
    omit?: SpeseNottiOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    idLogin: 'idLogin',
    nome: 'nome',
    cognome: 'cognome',
    email: 'email',
    password: 'password',
    societa: 'societa',
    tecnicocod: 'tecnicocod',
    attivo: 'attivo',
    typeutente: 'typeutente',
    colore: 'colore'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    codicecliente: 'codicecliente',
    idazienda: 'idazienda'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const ClienteContattoScalarFieldEnum: {
    id: 'id',
    idcliente: 'idcliente'
  };

  export type ClienteContattoScalarFieldEnum = (typeof ClienteContattoScalarFieldEnum)[keyof typeof ClienteContattoScalarFieldEnum]


  export const ClienteContrattoScalarFieldEnum: {
    id: 'id',
    idcliente: 'idcliente'
  };

  export type ClienteContrattoScalarFieldEnum = (typeof ClienteContrattoScalarFieldEnum)[keyof typeof ClienteContrattoScalarFieldEnum]


  export const ClienteNotaScalarFieldEnum: {
    id: 'id',
    idcliente: 'idcliente'
  };

  export type ClienteNotaScalarFieldEnum = (typeof ClienteNotaScalarFieldEnum)[keyof typeof ClienteNotaScalarFieldEnum]


  export const ClienteProdottoScalarFieldEnum: {
    id: 'id',
    idcliente: 'idcliente',
    idprodotto: 'idprodotto'
  };

  export type ClienteProdottoScalarFieldEnum = (typeof ClienteProdottoScalarFieldEnum)[keyof typeof ClienteProdottoScalarFieldEnum]


  export const OperazioneScalarFieldEnum: {
    id: 'id',
    datacreazione: 'datacreazione',
    tipo: 'tipo',
    codice: 'codice',
    anno: 'anno',
    idazienda: 'idazienda',
    idcliente: 'idcliente',
    idintervento: 'idintervento',
    operatore: 'operatore',
    idprodotto: 'idprodotto',
    dataesecuzione: 'dataesecuzione',
    orainizio: 'orainizio',
    orafine: 'orafine',
    totaleore: 'totaleore',
    osservazioni: 'osservazioni',
    codicecliente: 'codicecliente',
    stato: 'stato',
    eliminato: 'eliminato',
    idprodottocliente: 'idprodottocliente',
    faseoperazione: 'faseoperazione'
  };

  export type OperazioneScalarFieldEnum = (typeof OperazioneScalarFieldEnum)[keyof typeof OperazioneScalarFieldEnum]


  export const OperazioneFirmaScalarFieldEnum: {
    id: 'id',
    idoperazione: 'idoperazione'
  };

  export type OperazioneFirmaScalarFieldEnum = (typeof OperazioneFirmaScalarFieldEnum)[keyof typeof OperazioneFirmaScalarFieldEnum]


  export const OperazioneDescrizazioniScalarFieldEnum: {
    id: 'id',
    idoperazione: 'idoperazione'
  };

  export type OperazioneDescrizazioniScalarFieldEnum = (typeof OperazioneDescrizazioniScalarFieldEnum)[keyof typeof OperazioneDescrizazioniScalarFieldEnum]


  export const OperazionePutazioneScalarFieldEnum: {
    id: 'id',
    idoperazione: 'idoperazione'
  };

  export type OperazionePutazioneScalarFieldEnum = (typeof OperazionePutazioneScalarFieldEnum)[keyof typeof OperazionePutazioneScalarFieldEnum]


  export const ProdottoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type ProdottoScalarFieldEnum = (typeof ProdottoScalarFieldEnum)[keyof typeof ProdottoScalarFieldEnum]


  export const ProdottoVoceScalarFieldEnum: {
    id: 'id',
    idprodotto: 'idprodotto'
  };

  export type ProdottoVoceScalarFieldEnum = (typeof ProdottoVoceScalarFieldEnum)[keyof typeof ProdottoVoceScalarFieldEnum]


  export const ContrattoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    denominazione: 'denominazione',
    tipodurata: 'tipodurata',
    durata: 'durata',
    avvprima: 'avvprima',
    avvdopo: 'avvdopo',
    cancellato: 'cancellato'
  };

  export type ContrattoScalarFieldEnum = (typeof ContrattoScalarFieldEnum)[keyof typeof ContrattoScalarFieldEnum]


  export const PianningTipoInterventoScalarFieldEnum: {
    id: 'id'
  };

  export type PianningTipoInterventoScalarFieldEnum = (typeof PianningTipoInterventoScalarFieldEnum)[keyof typeof PianningTipoInterventoScalarFieldEnum]


  export const PianningEmailScalarFieldEnum: {
    id: 'id',
    idlogin: 'idlogin'
  };

  export type PianningEmailScalarFieldEnum = (typeof PianningEmailScalarFieldEnum)[keyof typeof PianningEmailScalarFieldEnum]


  export const VociInterventoScalarFieldEnum: {
    id: 'id'
  };

  export type VociInterventoScalarFieldEnum = (typeof VociInterventoScalarFieldEnum)[keyof typeof VociInterventoScalarFieldEnum]


  export const StraordinarioScalarFieldEnum: {
    id: 'id'
  };

  export type StraordinarioScalarFieldEnum = (typeof StraordinarioScalarFieldEnum)[keyof typeof StraordinarioScalarFieldEnum]


  export const InserimentoStraordinarioScalarFieldEnum: {
    id: 'id'
  };

  export type InserimentoStraordinarioScalarFieldEnum = (typeof InserimentoStraordinarioScalarFieldEnum)[keyof typeof InserimentoStraordinarioScalarFieldEnum]


  export const ImpostazioniUtenteScalarFieldEnum: {
    id: 'id'
  };

  export type ImpostazioniUtenteScalarFieldEnum = (typeof ImpostazioniUtenteScalarFieldEnum)[keyof typeof ImpostazioniUtenteScalarFieldEnum]


  export const SpeseNottiScalarFieldEnum: {
    id: 'id'
  };

  export type SpeseNottiScalarFieldEnum = (typeof SpeseNottiScalarFieldEnum)[keyof typeof SpeseNottiScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    idLogin?: IntFilter<"User"> | number
    nome?: StringNullableFilter<"User"> | string | null
    cognome?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    societa?: StringNullableFilter<"User"> | string | null
    tecnicocod?: StringNullableFilter<"User"> | string | null
    attivo?: StringFilter<"User"> | string
    typeutente?: StringFilter<"User"> | string
    colore?: StringNullableFilter<"User"> | string | null
    pianningEmail?: PianningEmailListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    idLogin?: SortOrder
    nome?: SortOrderInput | SortOrder
    cognome?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    societa?: SortOrderInput | SortOrder
    tecnicocod?: SortOrderInput | SortOrder
    attivo?: SortOrder
    typeutente?: SortOrder
    colore?: SortOrderInput | SortOrder
    pianningEmail?: PianningEmailOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    idLogin?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nome?: StringNullableFilter<"User"> | string | null
    cognome?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    societa?: StringNullableFilter<"User"> | string | null
    tecnicocod?: StringNullableFilter<"User"> | string | null
    attivo?: StringFilter<"User"> | string
    typeutente?: StringFilter<"User"> | string
    colore?: StringNullableFilter<"User"> | string | null
    pianningEmail?: PianningEmailListRelationFilter
  }, "idLogin" | "email">

  export type UserOrderByWithAggregationInput = {
    idLogin?: SortOrder
    nome?: SortOrderInput | SortOrder
    cognome?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    societa?: SortOrderInput | SortOrder
    tecnicocod?: SortOrderInput | SortOrder
    attivo?: SortOrder
    typeutente?: SortOrder
    colore?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    idLogin?: IntWithAggregatesFilter<"User"> | number
    nome?: StringNullableWithAggregatesFilter<"User"> | string | null
    cognome?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    societa?: StringNullableWithAggregatesFilter<"User"> | string | null
    tecnicocod?: StringNullableWithAggregatesFilter<"User"> | string | null
    attivo?: StringWithAggregatesFilter<"User"> | string
    typeutente?: StringWithAggregatesFilter<"User"> | string
    colore?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    codicecliente?: StringNullableFilter<"Cliente"> | string | null
    idazienda?: IntNullableFilter<"Cliente"> | number | null
    operazioni?: OperazioneListRelationFilter
    prodotti?: ClienteProdottoListRelationFilter
    contatti?: ClienteContattoListRelationFilter
    contratti?: ClienteContrattoListRelationFilter
    note?: ClienteNotaListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    codicecliente?: SortOrderInput | SortOrder
    idazienda?: SortOrderInput | SortOrder
    operazioni?: OperazioneOrderByRelationAggregateInput
    prodotti?: ClienteProdottoOrderByRelationAggregateInput
    contatti?: ClienteContattoOrderByRelationAggregateInput
    contratti?: ClienteContrattoOrderByRelationAggregateInput
    note?: ClienteNotaOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    codicecliente?: StringNullableFilter<"Cliente"> | string | null
    idazienda?: IntNullableFilter<"Cliente"> | number | null
    operazioni?: OperazioneListRelationFilter
    prodotti?: ClienteProdottoListRelationFilter
    contatti?: ClienteContattoListRelationFilter
    contratti?: ClienteContrattoListRelationFilter
    note?: ClienteNotaListRelationFilter
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    codicecliente?: SortOrderInput | SortOrder
    idazienda?: SortOrderInput | SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
    codicecliente?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    idazienda?: IntNullableWithAggregatesFilter<"Cliente"> | number | null
  }

  export type ClienteContattoWhereInput = {
    AND?: ClienteContattoWhereInput | ClienteContattoWhereInput[]
    OR?: ClienteContattoWhereInput[]
    NOT?: ClienteContattoWhereInput | ClienteContattoWhereInput[]
    id?: IntFilter<"ClienteContatto"> | number
    idcliente?: IntFilter<"ClienteContatto"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }

  export type ClienteContattoOrderByWithRelationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type ClienteContattoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteContattoWhereInput | ClienteContattoWhereInput[]
    OR?: ClienteContattoWhereInput[]
    NOT?: ClienteContattoWhereInput | ClienteContattoWhereInput[]
    idcliente?: IntFilter<"ClienteContatto"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }, "id">

  export type ClienteContattoOrderByWithAggregationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    _count?: ClienteContattoCountOrderByAggregateInput
    _avg?: ClienteContattoAvgOrderByAggregateInput
    _max?: ClienteContattoMaxOrderByAggregateInput
    _min?: ClienteContattoMinOrderByAggregateInput
    _sum?: ClienteContattoSumOrderByAggregateInput
  }

  export type ClienteContattoScalarWhereWithAggregatesInput = {
    AND?: ClienteContattoScalarWhereWithAggregatesInput | ClienteContattoScalarWhereWithAggregatesInput[]
    OR?: ClienteContattoScalarWhereWithAggregatesInput[]
    NOT?: ClienteContattoScalarWhereWithAggregatesInput | ClienteContattoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClienteContatto"> | number
    idcliente?: IntWithAggregatesFilter<"ClienteContatto"> | number
  }

  export type ClienteContrattoWhereInput = {
    AND?: ClienteContrattoWhereInput | ClienteContrattoWhereInput[]
    OR?: ClienteContrattoWhereInput[]
    NOT?: ClienteContrattoWhereInput | ClienteContrattoWhereInput[]
    id?: IntFilter<"ClienteContratto"> | number
    idcliente?: IntFilter<"ClienteContratto"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }

  export type ClienteContrattoOrderByWithRelationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type ClienteContrattoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteContrattoWhereInput | ClienteContrattoWhereInput[]
    OR?: ClienteContrattoWhereInput[]
    NOT?: ClienteContrattoWhereInput | ClienteContrattoWhereInput[]
    idcliente?: IntFilter<"ClienteContratto"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }, "id">

  export type ClienteContrattoOrderByWithAggregationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    _count?: ClienteContrattoCountOrderByAggregateInput
    _avg?: ClienteContrattoAvgOrderByAggregateInput
    _max?: ClienteContrattoMaxOrderByAggregateInput
    _min?: ClienteContrattoMinOrderByAggregateInput
    _sum?: ClienteContrattoSumOrderByAggregateInput
  }

  export type ClienteContrattoScalarWhereWithAggregatesInput = {
    AND?: ClienteContrattoScalarWhereWithAggregatesInput | ClienteContrattoScalarWhereWithAggregatesInput[]
    OR?: ClienteContrattoScalarWhereWithAggregatesInput[]
    NOT?: ClienteContrattoScalarWhereWithAggregatesInput | ClienteContrattoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClienteContratto"> | number
    idcliente?: IntWithAggregatesFilter<"ClienteContratto"> | number
  }

  export type ClienteNotaWhereInput = {
    AND?: ClienteNotaWhereInput | ClienteNotaWhereInput[]
    OR?: ClienteNotaWhereInput[]
    NOT?: ClienteNotaWhereInput | ClienteNotaWhereInput[]
    id?: IntFilter<"ClienteNota"> | number
    idcliente?: IntFilter<"ClienteNota"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }

  export type ClienteNotaOrderByWithRelationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type ClienteNotaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteNotaWhereInput | ClienteNotaWhereInput[]
    OR?: ClienteNotaWhereInput[]
    NOT?: ClienteNotaWhereInput | ClienteNotaWhereInput[]
    idcliente?: IntFilter<"ClienteNota"> | number
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }, "id">

  export type ClienteNotaOrderByWithAggregationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    _count?: ClienteNotaCountOrderByAggregateInput
    _avg?: ClienteNotaAvgOrderByAggregateInput
    _max?: ClienteNotaMaxOrderByAggregateInput
    _min?: ClienteNotaMinOrderByAggregateInput
    _sum?: ClienteNotaSumOrderByAggregateInput
  }

  export type ClienteNotaScalarWhereWithAggregatesInput = {
    AND?: ClienteNotaScalarWhereWithAggregatesInput | ClienteNotaScalarWhereWithAggregatesInput[]
    OR?: ClienteNotaScalarWhereWithAggregatesInput[]
    NOT?: ClienteNotaScalarWhereWithAggregatesInput | ClienteNotaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClienteNota"> | number
    idcliente?: IntWithAggregatesFilter<"ClienteNota"> | number
  }

  export type ClienteProdottoWhereInput = {
    AND?: ClienteProdottoWhereInput | ClienteProdottoWhereInput[]
    OR?: ClienteProdottoWhereInput[]
    NOT?: ClienteProdottoWhereInput | ClienteProdottoWhereInput[]
    id?: IntFilter<"ClienteProdotto"> | number
    idcliente?: IntFilter<"ClienteProdotto"> | number
    idprodotto?: IntNullableFilter<"ClienteProdotto"> | number | null
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }

  export type ClienteProdottoOrderByWithRelationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrderInput | SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type ClienteProdottoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteProdottoWhereInput | ClienteProdottoWhereInput[]
    OR?: ClienteProdottoWhereInput[]
    NOT?: ClienteProdottoWhereInput | ClienteProdottoWhereInput[]
    idcliente?: IntFilter<"ClienteProdotto"> | number
    idprodotto?: IntNullableFilter<"ClienteProdotto"> | number | null
    cliente?: XOR<ClienteScalarRelationFilter, ClienteWhereInput>
  }, "id">

  export type ClienteProdottoOrderByWithAggregationInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrderInput | SortOrder
    _count?: ClienteProdottoCountOrderByAggregateInput
    _avg?: ClienteProdottoAvgOrderByAggregateInput
    _max?: ClienteProdottoMaxOrderByAggregateInput
    _min?: ClienteProdottoMinOrderByAggregateInput
    _sum?: ClienteProdottoSumOrderByAggregateInput
  }

  export type ClienteProdottoScalarWhereWithAggregatesInput = {
    AND?: ClienteProdottoScalarWhereWithAggregatesInput | ClienteProdottoScalarWhereWithAggregatesInput[]
    OR?: ClienteProdottoScalarWhereWithAggregatesInput[]
    NOT?: ClienteProdottoScalarWhereWithAggregatesInput | ClienteProdottoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClienteProdotto"> | number
    idcliente?: IntWithAggregatesFilter<"ClienteProdotto"> | number
    idprodotto?: IntNullableWithAggregatesFilter<"ClienteProdotto"> | number | null
  }

  export type OperazioneWhereInput = {
    AND?: OperazioneWhereInput | OperazioneWhereInput[]
    OR?: OperazioneWhereInput[]
    NOT?: OperazioneWhereInput | OperazioneWhereInput[]
    id?: IntFilter<"Operazione"> | number
    datacreazione?: DateTimeNullableFilter<"Operazione"> | Date | string | null
    tipo?: StringNullableFilter<"Operazione"> | string | null
    codice?: StringNullableFilter<"Operazione"> | string | null
    anno?: IntNullableFilter<"Operazione"> | number | null
    idazienda?: IntNullableFilter<"Operazione"> | number | null
    idcliente?: IntNullableFilter<"Operazione"> | number | null
    idintervento?: IntNullableFilter<"Operazione"> | number | null
    operatore?: StringNullableFilter<"Operazione"> | string | null
    idprodotto?: IntNullableFilter<"Operazione"> | number | null
    dataesecuzione?: DateTimeNullableFilter<"Operazione"> | Date | string | null
    orainizio?: IntNullableFilter<"Operazione"> | number | null
    orafine?: IntNullableFilter<"Operazione"> | number | null
    totaleore?: IntNullableFilter<"Operazione"> | number | null
    osservazioni?: StringNullableFilter<"Operazione"> | string | null
    codicecliente?: StringNullableFilter<"Operazione"> | string | null
    stato?: IntNullableFilter<"Operazione"> | number | null
    eliminato?: StringNullableFilter<"Operazione"> | string | null
    idprodottocliente?: IntNullableFilter<"Operazione"> | number | null
    faseoperazione?: IntNullableFilter<"Operazione"> | number | null
    cliente?: XOR<ClienteNullableScalarRelationFilter, ClienteWhereInput> | null
  }

  export type OperazioneOrderByWithRelationInput = {
    id?: SortOrder
    datacreazione?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    codice?: SortOrderInput | SortOrder
    anno?: SortOrderInput | SortOrder
    idazienda?: SortOrderInput | SortOrder
    idcliente?: SortOrderInput | SortOrder
    idintervento?: SortOrderInput | SortOrder
    operatore?: SortOrderInput | SortOrder
    idprodotto?: SortOrderInput | SortOrder
    dataesecuzione?: SortOrderInput | SortOrder
    orainizio?: SortOrderInput | SortOrder
    orafine?: SortOrderInput | SortOrder
    totaleore?: SortOrderInput | SortOrder
    osservazioni?: SortOrderInput | SortOrder
    codicecliente?: SortOrderInput | SortOrder
    stato?: SortOrderInput | SortOrder
    eliminato?: SortOrderInput | SortOrder
    idprodottocliente?: SortOrderInput | SortOrder
    faseoperazione?: SortOrderInput | SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type OperazioneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperazioneWhereInput | OperazioneWhereInput[]
    OR?: OperazioneWhereInput[]
    NOT?: OperazioneWhereInput | OperazioneWhereInput[]
    datacreazione?: DateTimeNullableFilter<"Operazione"> | Date | string | null
    tipo?: StringNullableFilter<"Operazione"> | string | null
    codice?: StringNullableFilter<"Operazione"> | string | null
    anno?: IntNullableFilter<"Operazione"> | number | null
    idazienda?: IntNullableFilter<"Operazione"> | number | null
    idcliente?: IntNullableFilter<"Operazione"> | number | null
    idintervento?: IntNullableFilter<"Operazione"> | number | null
    operatore?: StringNullableFilter<"Operazione"> | string | null
    idprodotto?: IntNullableFilter<"Operazione"> | number | null
    dataesecuzione?: DateTimeNullableFilter<"Operazione"> | Date | string | null
    orainizio?: IntNullableFilter<"Operazione"> | number | null
    orafine?: IntNullableFilter<"Operazione"> | number | null
    totaleore?: IntNullableFilter<"Operazione"> | number | null
    osservazioni?: StringNullableFilter<"Operazione"> | string | null
    codicecliente?: StringNullableFilter<"Operazione"> | string | null
    stato?: IntNullableFilter<"Operazione"> | number | null
    eliminato?: StringNullableFilter<"Operazione"> | string | null
    idprodottocliente?: IntNullableFilter<"Operazione"> | number | null
    faseoperazione?: IntNullableFilter<"Operazione"> | number | null
    cliente?: XOR<ClienteNullableScalarRelationFilter, ClienteWhereInput> | null
  }, "id">

  export type OperazioneOrderByWithAggregationInput = {
    id?: SortOrder
    datacreazione?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    codice?: SortOrderInput | SortOrder
    anno?: SortOrderInput | SortOrder
    idazienda?: SortOrderInput | SortOrder
    idcliente?: SortOrderInput | SortOrder
    idintervento?: SortOrderInput | SortOrder
    operatore?: SortOrderInput | SortOrder
    idprodotto?: SortOrderInput | SortOrder
    dataesecuzione?: SortOrderInput | SortOrder
    orainizio?: SortOrderInput | SortOrder
    orafine?: SortOrderInput | SortOrder
    totaleore?: SortOrderInput | SortOrder
    osservazioni?: SortOrderInput | SortOrder
    codicecliente?: SortOrderInput | SortOrder
    stato?: SortOrderInput | SortOrder
    eliminato?: SortOrderInput | SortOrder
    idprodottocliente?: SortOrderInput | SortOrder
    faseoperazione?: SortOrderInput | SortOrder
    _count?: OperazioneCountOrderByAggregateInput
    _avg?: OperazioneAvgOrderByAggregateInput
    _max?: OperazioneMaxOrderByAggregateInput
    _min?: OperazioneMinOrderByAggregateInput
    _sum?: OperazioneSumOrderByAggregateInput
  }

  export type OperazioneScalarWhereWithAggregatesInput = {
    AND?: OperazioneScalarWhereWithAggregatesInput | OperazioneScalarWhereWithAggregatesInput[]
    OR?: OperazioneScalarWhereWithAggregatesInput[]
    NOT?: OperazioneScalarWhereWithAggregatesInput | OperazioneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Operazione"> | number
    datacreazione?: DateTimeNullableWithAggregatesFilter<"Operazione"> | Date | string | null
    tipo?: StringNullableWithAggregatesFilter<"Operazione"> | string | null
    codice?: StringNullableWithAggregatesFilter<"Operazione"> | string | null
    anno?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    idazienda?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    idcliente?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    idintervento?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    operatore?: StringNullableWithAggregatesFilter<"Operazione"> | string | null
    idprodotto?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    dataesecuzione?: DateTimeNullableWithAggregatesFilter<"Operazione"> | Date | string | null
    orainizio?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    orafine?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    totaleore?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    osservazioni?: StringNullableWithAggregatesFilter<"Operazione"> | string | null
    codicecliente?: StringNullableWithAggregatesFilter<"Operazione"> | string | null
    stato?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    eliminato?: StringNullableWithAggregatesFilter<"Operazione"> | string | null
    idprodottocliente?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
    faseoperazione?: IntNullableWithAggregatesFilter<"Operazione"> | number | null
  }

  export type OperazioneFirmaWhereInput = {
    AND?: OperazioneFirmaWhereInput | OperazioneFirmaWhereInput[]
    OR?: OperazioneFirmaWhereInput[]
    NOT?: OperazioneFirmaWhereInput | OperazioneFirmaWhereInput[]
    id?: IntFilter<"OperazioneFirma"> | number
    idoperazione?: IntNullableFilter<"OperazioneFirma"> | number | null
  }

  export type OperazioneFirmaOrderByWithRelationInput = {
    id?: SortOrder
    idoperazione?: SortOrderInput | SortOrder
  }

  export type OperazioneFirmaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperazioneFirmaWhereInput | OperazioneFirmaWhereInput[]
    OR?: OperazioneFirmaWhereInput[]
    NOT?: OperazioneFirmaWhereInput | OperazioneFirmaWhereInput[]
    idoperazione?: IntNullableFilter<"OperazioneFirma"> | number | null
  }, "id">

  export type OperazioneFirmaOrderByWithAggregationInput = {
    id?: SortOrder
    idoperazione?: SortOrderInput | SortOrder
    _count?: OperazioneFirmaCountOrderByAggregateInput
    _avg?: OperazioneFirmaAvgOrderByAggregateInput
    _max?: OperazioneFirmaMaxOrderByAggregateInput
    _min?: OperazioneFirmaMinOrderByAggregateInput
    _sum?: OperazioneFirmaSumOrderByAggregateInput
  }

  export type OperazioneFirmaScalarWhereWithAggregatesInput = {
    AND?: OperazioneFirmaScalarWhereWithAggregatesInput | OperazioneFirmaScalarWhereWithAggregatesInput[]
    OR?: OperazioneFirmaScalarWhereWithAggregatesInput[]
    NOT?: OperazioneFirmaScalarWhereWithAggregatesInput | OperazioneFirmaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperazioneFirma"> | number
    idoperazione?: IntNullableWithAggregatesFilter<"OperazioneFirma"> | number | null
  }

  export type OperazioneDescrizazioniWhereInput = {
    AND?: OperazioneDescrizazioniWhereInput | OperazioneDescrizazioniWhereInput[]
    OR?: OperazioneDescrizazioniWhereInput[]
    NOT?: OperazioneDescrizazioniWhereInput | OperazioneDescrizazioniWhereInput[]
    id?: IntFilter<"OperazioneDescrizazioni"> | number
    idoperazione?: IntNullableFilter<"OperazioneDescrizazioni"> | number | null
  }

  export type OperazioneDescrizazioniOrderByWithRelationInput = {
    id?: SortOrder
    idoperazione?: SortOrderInput | SortOrder
  }

  export type OperazioneDescrizazioniWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperazioneDescrizazioniWhereInput | OperazioneDescrizazioniWhereInput[]
    OR?: OperazioneDescrizazioniWhereInput[]
    NOT?: OperazioneDescrizazioniWhereInput | OperazioneDescrizazioniWhereInput[]
    idoperazione?: IntNullableFilter<"OperazioneDescrizazioni"> | number | null
  }, "id">

  export type OperazioneDescrizazioniOrderByWithAggregationInput = {
    id?: SortOrder
    idoperazione?: SortOrderInput | SortOrder
    _count?: OperazioneDescrizazioniCountOrderByAggregateInput
    _avg?: OperazioneDescrizazioniAvgOrderByAggregateInput
    _max?: OperazioneDescrizazioniMaxOrderByAggregateInput
    _min?: OperazioneDescrizazioniMinOrderByAggregateInput
    _sum?: OperazioneDescrizazioniSumOrderByAggregateInput
  }

  export type OperazioneDescrizazioniScalarWhereWithAggregatesInput = {
    AND?: OperazioneDescrizazioniScalarWhereWithAggregatesInput | OperazioneDescrizazioniScalarWhereWithAggregatesInput[]
    OR?: OperazioneDescrizazioniScalarWhereWithAggregatesInput[]
    NOT?: OperazioneDescrizazioniScalarWhereWithAggregatesInput | OperazioneDescrizazioniScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperazioneDescrizazioni"> | number
    idoperazione?: IntNullableWithAggregatesFilter<"OperazioneDescrizazioni"> | number | null
  }

  export type OperazionePutazioneWhereInput = {
    AND?: OperazionePutazioneWhereInput | OperazionePutazioneWhereInput[]
    OR?: OperazionePutazioneWhereInput[]
    NOT?: OperazionePutazioneWhereInput | OperazionePutazioneWhereInput[]
    id?: IntFilter<"OperazionePutazione"> | number
    idoperazione?: IntNullableFilter<"OperazionePutazione"> | number | null
  }

  export type OperazionePutazioneOrderByWithRelationInput = {
    id?: SortOrder
    idoperazione?: SortOrderInput | SortOrder
  }

  export type OperazionePutazioneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OperazionePutazioneWhereInput | OperazionePutazioneWhereInput[]
    OR?: OperazionePutazioneWhereInput[]
    NOT?: OperazionePutazioneWhereInput | OperazionePutazioneWhereInput[]
    idoperazione?: IntNullableFilter<"OperazionePutazione"> | number | null
  }, "id">

  export type OperazionePutazioneOrderByWithAggregationInput = {
    id?: SortOrder
    idoperazione?: SortOrderInput | SortOrder
    _count?: OperazionePutazioneCountOrderByAggregateInput
    _avg?: OperazionePutazioneAvgOrderByAggregateInput
    _max?: OperazionePutazioneMaxOrderByAggregateInput
    _min?: OperazionePutazioneMinOrderByAggregateInput
    _sum?: OperazionePutazioneSumOrderByAggregateInput
  }

  export type OperazionePutazioneScalarWhereWithAggregatesInput = {
    AND?: OperazionePutazioneScalarWhereWithAggregatesInput | OperazionePutazioneScalarWhereWithAggregatesInput[]
    OR?: OperazionePutazioneScalarWhereWithAggregatesInput[]
    NOT?: OperazionePutazioneScalarWhereWithAggregatesInput | OperazionePutazioneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OperazionePutazione"> | number
    idoperazione?: IntNullableWithAggregatesFilter<"OperazionePutazione"> | number | null
  }

  export type ProdottoWhereInput = {
    AND?: ProdottoWhereInput | ProdottoWhereInput[]
    OR?: ProdottoWhereInput[]
    NOT?: ProdottoWhereInput | ProdottoWhereInput[]
    id?: IntFilter<"Prodotto"> | number
    nome?: StringNullableFilter<"Prodotto"> | string | null
    voci?: ProdottoVoceListRelationFilter
  }

  export type ProdottoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrderInput | SortOrder
    voci?: ProdottoVoceOrderByRelationAggregateInput
  }

  export type ProdottoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProdottoWhereInput | ProdottoWhereInput[]
    OR?: ProdottoWhereInput[]
    NOT?: ProdottoWhereInput | ProdottoWhereInput[]
    nome?: StringNullableFilter<"Prodotto"> | string | null
    voci?: ProdottoVoceListRelationFilter
  }, "id">

  export type ProdottoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrderInput | SortOrder
    _count?: ProdottoCountOrderByAggregateInput
    _avg?: ProdottoAvgOrderByAggregateInput
    _max?: ProdottoMaxOrderByAggregateInput
    _min?: ProdottoMinOrderByAggregateInput
    _sum?: ProdottoSumOrderByAggregateInput
  }

  export type ProdottoScalarWhereWithAggregatesInput = {
    AND?: ProdottoScalarWhereWithAggregatesInput | ProdottoScalarWhereWithAggregatesInput[]
    OR?: ProdottoScalarWhereWithAggregatesInput[]
    NOT?: ProdottoScalarWhereWithAggregatesInput | ProdottoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prodotto"> | number
    nome?: StringNullableWithAggregatesFilter<"Prodotto"> | string | null
  }

  export type ProdottoVoceWhereInput = {
    AND?: ProdottoVoceWhereInput | ProdottoVoceWhereInput[]
    OR?: ProdottoVoceWhereInput[]
    NOT?: ProdottoVoceWhereInput | ProdottoVoceWhereInput[]
    id?: IntFilter<"ProdottoVoce"> | number
    idprodotto?: IntNullableFilter<"ProdottoVoce"> | number | null
    prodotto?: XOR<ProdottoNullableScalarRelationFilter, ProdottoWhereInput> | null
  }

  export type ProdottoVoceOrderByWithRelationInput = {
    id?: SortOrder
    idprodotto?: SortOrderInput | SortOrder
    prodotto?: ProdottoOrderByWithRelationInput
  }

  export type ProdottoVoceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProdottoVoceWhereInput | ProdottoVoceWhereInput[]
    OR?: ProdottoVoceWhereInput[]
    NOT?: ProdottoVoceWhereInput | ProdottoVoceWhereInput[]
    idprodotto?: IntNullableFilter<"ProdottoVoce"> | number | null
    prodotto?: XOR<ProdottoNullableScalarRelationFilter, ProdottoWhereInput> | null
  }, "id">

  export type ProdottoVoceOrderByWithAggregationInput = {
    id?: SortOrder
    idprodotto?: SortOrderInput | SortOrder
    _count?: ProdottoVoceCountOrderByAggregateInput
    _avg?: ProdottoVoceAvgOrderByAggregateInput
    _max?: ProdottoVoceMaxOrderByAggregateInput
    _min?: ProdottoVoceMinOrderByAggregateInput
    _sum?: ProdottoVoceSumOrderByAggregateInput
  }

  export type ProdottoVoceScalarWhereWithAggregatesInput = {
    AND?: ProdottoVoceScalarWhereWithAggregatesInput | ProdottoVoceScalarWhereWithAggregatesInput[]
    OR?: ProdottoVoceScalarWhereWithAggregatesInput[]
    NOT?: ProdottoVoceScalarWhereWithAggregatesInput | ProdottoVoceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProdottoVoce"> | number
    idprodotto?: IntNullableWithAggregatesFilter<"ProdottoVoce"> | number | null
  }

  export type ContrattoWhereInput = {
    AND?: ContrattoWhereInput | ContrattoWhereInput[]
    OR?: ContrattoWhereInput[]
    NOT?: ContrattoWhereInput | ContrattoWhereInput[]
    id?: IntFilter<"Contratto"> | number
    tipo?: IntNullableFilter<"Contratto"> | number | null
    denominazione?: StringNullableFilter<"Contratto"> | string | null
    tipodurata?: StringNullableFilter<"Contratto"> | string | null
    durata?: IntNullableFilter<"Contratto"> | number | null
    avvprima?: IntNullableFilter<"Contratto"> | number | null
    avvdopo?: IntNullableFilter<"Contratto"> | number | null
    cancellato?: StringNullableFilter<"Contratto"> | string | null
  }

  export type ContrattoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    denominazione?: SortOrderInput | SortOrder
    tipodurata?: SortOrderInput | SortOrder
    durata?: SortOrderInput | SortOrder
    avvprima?: SortOrderInput | SortOrder
    avvdopo?: SortOrderInput | SortOrder
    cancellato?: SortOrderInput | SortOrder
  }

  export type ContrattoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContrattoWhereInput | ContrattoWhereInput[]
    OR?: ContrattoWhereInput[]
    NOT?: ContrattoWhereInput | ContrattoWhereInput[]
    tipo?: IntNullableFilter<"Contratto"> | number | null
    denominazione?: StringNullableFilter<"Contratto"> | string | null
    tipodurata?: StringNullableFilter<"Contratto"> | string | null
    durata?: IntNullableFilter<"Contratto"> | number | null
    avvprima?: IntNullableFilter<"Contratto"> | number | null
    avvdopo?: IntNullableFilter<"Contratto"> | number | null
    cancellato?: StringNullableFilter<"Contratto"> | string | null
  }, "id">

  export type ContrattoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrderInput | SortOrder
    denominazione?: SortOrderInput | SortOrder
    tipodurata?: SortOrderInput | SortOrder
    durata?: SortOrderInput | SortOrder
    avvprima?: SortOrderInput | SortOrder
    avvdopo?: SortOrderInput | SortOrder
    cancellato?: SortOrderInput | SortOrder
    _count?: ContrattoCountOrderByAggregateInput
    _avg?: ContrattoAvgOrderByAggregateInput
    _max?: ContrattoMaxOrderByAggregateInput
    _min?: ContrattoMinOrderByAggregateInput
    _sum?: ContrattoSumOrderByAggregateInput
  }

  export type ContrattoScalarWhereWithAggregatesInput = {
    AND?: ContrattoScalarWhereWithAggregatesInput | ContrattoScalarWhereWithAggregatesInput[]
    OR?: ContrattoScalarWhereWithAggregatesInput[]
    NOT?: ContrattoScalarWhereWithAggregatesInput | ContrattoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contratto"> | number
    tipo?: IntNullableWithAggregatesFilter<"Contratto"> | number | null
    denominazione?: StringNullableWithAggregatesFilter<"Contratto"> | string | null
    tipodurata?: StringNullableWithAggregatesFilter<"Contratto"> | string | null
    durata?: IntNullableWithAggregatesFilter<"Contratto"> | number | null
    avvprima?: IntNullableWithAggregatesFilter<"Contratto"> | number | null
    avvdopo?: IntNullableWithAggregatesFilter<"Contratto"> | number | null
    cancellato?: StringNullableWithAggregatesFilter<"Contratto"> | string | null
  }

  export type PianningTipoInterventoWhereInput = {
    AND?: PianningTipoInterventoWhereInput | PianningTipoInterventoWhereInput[]
    OR?: PianningTipoInterventoWhereInput[]
    NOT?: PianningTipoInterventoWhereInput | PianningTipoInterventoWhereInput[]
    id?: IntFilter<"PianningTipoIntervento"> | number
  }

  export type PianningTipoInterventoOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type PianningTipoInterventoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PianningTipoInterventoWhereInput | PianningTipoInterventoWhereInput[]
    OR?: PianningTipoInterventoWhereInput[]
    NOT?: PianningTipoInterventoWhereInput | PianningTipoInterventoWhereInput[]
  }, "id">

  export type PianningTipoInterventoOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: PianningTipoInterventoCountOrderByAggregateInput
    _avg?: PianningTipoInterventoAvgOrderByAggregateInput
    _max?: PianningTipoInterventoMaxOrderByAggregateInput
    _min?: PianningTipoInterventoMinOrderByAggregateInput
    _sum?: PianningTipoInterventoSumOrderByAggregateInput
  }

  export type PianningTipoInterventoScalarWhereWithAggregatesInput = {
    AND?: PianningTipoInterventoScalarWhereWithAggregatesInput | PianningTipoInterventoScalarWhereWithAggregatesInput[]
    OR?: PianningTipoInterventoScalarWhereWithAggregatesInput[]
    NOT?: PianningTipoInterventoScalarWhereWithAggregatesInput | PianningTipoInterventoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PianningTipoIntervento"> | number
  }

  export type PianningEmailWhereInput = {
    AND?: PianningEmailWhereInput | PianningEmailWhereInput[]
    OR?: PianningEmailWhereInput[]
    NOT?: PianningEmailWhereInput | PianningEmailWhereInput[]
    id?: IntFilter<"PianningEmail"> | number
    idlogin?: IntNullableFilter<"PianningEmail"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PianningEmailOrderByWithRelationInput = {
    id?: SortOrder
    idlogin?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PianningEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PianningEmailWhereInput | PianningEmailWhereInput[]
    OR?: PianningEmailWhereInput[]
    NOT?: PianningEmailWhereInput | PianningEmailWhereInput[]
    idlogin?: IntNullableFilter<"PianningEmail"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PianningEmailOrderByWithAggregationInput = {
    id?: SortOrder
    idlogin?: SortOrderInput | SortOrder
    _count?: PianningEmailCountOrderByAggregateInput
    _avg?: PianningEmailAvgOrderByAggregateInput
    _max?: PianningEmailMaxOrderByAggregateInput
    _min?: PianningEmailMinOrderByAggregateInput
    _sum?: PianningEmailSumOrderByAggregateInput
  }

  export type PianningEmailScalarWhereWithAggregatesInput = {
    AND?: PianningEmailScalarWhereWithAggregatesInput | PianningEmailScalarWhereWithAggregatesInput[]
    OR?: PianningEmailScalarWhereWithAggregatesInput[]
    NOT?: PianningEmailScalarWhereWithAggregatesInput | PianningEmailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PianningEmail"> | number
    idlogin?: IntNullableWithAggregatesFilter<"PianningEmail"> | number | null
  }

  export type VociInterventoWhereInput = {
    AND?: VociInterventoWhereInput | VociInterventoWhereInput[]
    OR?: VociInterventoWhereInput[]
    NOT?: VociInterventoWhereInput | VociInterventoWhereInput[]
    id?: IntFilter<"VociIntervento"> | number
  }

  export type VociInterventoOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type VociInterventoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VociInterventoWhereInput | VociInterventoWhereInput[]
    OR?: VociInterventoWhereInput[]
    NOT?: VociInterventoWhereInput | VociInterventoWhereInput[]
  }, "id">

  export type VociInterventoOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: VociInterventoCountOrderByAggregateInput
    _avg?: VociInterventoAvgOrderByAggregateInput
    _max?: VociInterventoMaxOrderByAggregateInput
    _min?: VociInterventoMinOrderByAggregateInput
    _sum?: VociInterventoSumOrderByAggregateInput
  }

  export type VociInterventoScalarWhereWithAggregatesInput = {
    AND?: VociInterventoScalarWhereWithAggregatesInput | VociInterventoScalarWhereWithAggregatesInput[]
    OR?: VociInterventoScalarWhereWithAggregatesInput[]
    NOT?: VociInterventoScalarWhereWithAggregatesInput | VociInterventoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VociIntervento"> | number
  }

  export type StraordinarioWhereInput = {
    AND?: StraordinarioWhereInput | StraordinarioWhereInput[]
    OR?: StraordinarioWhereInput[]
    NOT?: StraordinarioWhereInput | StraordinarioWhereInput[]
    id?: IntFilter<"Straordinario"> | number
  }

  export type StraordinarioOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type StraordinarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StraordinarioWhereInput | StraordinarioWhereInput[]
    OR?: StraordinarioWhereInput[]
    NOT?: StraordinarioWhereInput | StraordinarioWhereInput[]
  }, "id">

  export type StraordinarioOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: StraordinarioCountOrderByAggregateInput
    _avg?: StraordinarioAvgOrderByAggregateInput
    _max?: StraordinarioMaxOrderByAggregateInput
    _min?: StraordinarioMinOrderByAggregateInput
    _sum?: StraordinarioSumOrderByAggregateInput
  }

  export type StraordinarioScalarWhereWithAggregatesInput = {
    AND?: StraordinarioScalarWhereWithAggregatesInput | StraordinarioScalarWhereWithAggregatesInput[]
    OR?: StraordinarioScalarWhereWithAggregatesInput[]
    NOT?: StraordinarioScalarWhereWithAggregatesInput | StraordinarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Straordinario"> | number
  }

  export type InserimentoStraordinarioWhereInput = {
    AND?: InserimentoStraordinarioWhereInput | InserimentoStraordinarioWhereInput[]
    OR?: InserimentoStraordinarioWhereInput[]
    NOT?: InserimentoStraordinarioWhereInput | InserimentoStraordinarioWhereInput[]
    id?: IntFilter<"InserimentoStraordinario"> | number
  }

  export type InserimentoStraordinarioOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type InserimentoStraordinarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InserimentoStraordinarioWhereInput | InserimentoStraordinarioWhereInput[]
    OR?: InserimentoStraordinarioWhereInput[]
    NOT?: InserimentoStraordinarioWhereInput | InserimentoStraordinarioWhereInput[]
  }, "id">

  export type InserimentoStraordinarioOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: InserimentoStraordinarioCountOrderByAggregateInput
    _avg?: InserimentoStraordinarioAvgOrderByAggregateInput
    _max?: InserimentoStraordinarioMaxOrderByAggregateInput
    _min?: InserimentoStraordinarioMinOrderByAggregateInput
    _sum?: InserimentoStraordinarioSumOrderByAggregateInput
  }

  export type InserimentoStraordinarioScalarWhereWithAggregatesInput = {
    AND?: InserimentoStraordinarioScalarWhereWithAggregatesInput | InserimentoStraordinarioScalarWhereWithAggregatesInput[]
    OR?: InserimentoStraordinarioScalarWhereWithAggregatesInput[]
    NOT?: InserimentoStraordinarioScalarWhereWithAggregatesInput | InserimentoStraordinarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InserimentoStraordinario"> | number
  }

  export type ImpostazioniUtenteWhereInput = {
    AND?: ImpostazioniUtenteWhereInput | ImpostazioniUtenteWhereInput[]
    OR?: ImpostazioniUtenteWhereInput[]
    NOT?: ImpostazioniUtenteWhereInput | ImpostazioniUtenteWhereInput[]
    id?: IntFilter<"ImpostazioniUtente"> | number
  }

  export type ImpostazioniUtenteOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type ImpostazioniUtenteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImpostazioniUtenteWhereInput | ImpostazioniUtenteWhereInput[]
    OR?: ImpostazioniUtenteWhereInput[]
    NOT?: ImpostazioniUtenteWhereInput | ImpostazioniUtenteWhereInput[]
  }, "id">

  export type ImpostazioniUtenteOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ImpostazioniUtenteCountOrderByAggregateInput
    _avg?: ImpostazioniUtenteAvgOrderByAggregateInput
    _max?: ImpostazioniUtenteMaxOrderByAggregateInput
    _min?: ImpostazioniUtenteMinOrderByAggregateInput
    _sum?: ImpostazioniUtenteSumOrderByAggregateInput
  }

  export type ImpostazioniUtenteScalarWhereWithAggregatesInput = {
    AND?: ImpostazioniUtenteScalarWhereWithAggregatesInput | ImpostazioniUtenteScalarWhereWithAggregatesInput[]
    OR?: ImpostazioniUtenteScalarWhereWithAggregatesInput[]
    NOT?: ImpostazioniUtenteScalarWhereWithAggregatesInput | ImpostazioniUtenteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ImpostazioniUtente"> | number
  }

  export type SpeseNottiWhereInput = {
    AND?: SpeseNottiWhereInput | SpeseNottiWhereInput[]
    OR?: SpeseNottiWhereInput[]
    NOT?: SpeseNottiWhereInput | SpeseNottiWhereInput[]
    id?: IntFilter<"SpeseNotti"> | number
  }

  export type SpeseNottiOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type SpeseNottiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpeseNottiWhereInput | SpeseNottiWhereInput[]
    OR?: SpeseNottiWhereInput[]
    NOT?: SpeseNottiWhereInput | SpeseNottiWhereInput[]
  }, "id">

  export type SpeseNottiOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: SpeseNottiCountOrderByAggregateInput
    _avg?: SpeseNottiAvgOrderByAggregateInput
    _max?: SpeseNottiMaxOrderByAggregateInput
    _min?: SpeseNottiMinOrderByAggregateInput
    _sum?: SpeseNottiSumOrderByAggregateInput
  }

  export type SpeseNottiScalarWhereWithAggregatesInput = {
    AND?: SpeseNottiScalarWhereWithAggregatesInput | SpeseNottiScalarWhereWithAggregatesInput[]
    OR?: SpeseNottiScalarWhereWithAggregatesInput[]
    NOT?: SpeseNottiScalarWhereWithAggregatesInput | SpeseNottiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpeseNotti"> | number
  }

  export type UserCreateInput = {
    nome?: string | null
    cognome?: string | null
    email: string
    password: string
    societa?: string | null
    tecnicocod?: string | null
    attivo?: string
    typeutente?: string
    colore?: string | null
    pianningEmail?: PianningEmailCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    idLogin?: number
    nome?: string | null
    cognome?: string | null
    email: string
    password: string
    societa?: string | null
    tecnicocod?: string | null
    attivo?: string
    typeutente?: string
    colore?: string | null
    pianningEmail?: PianningEmailUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    cognome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    societa?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicocod?: NullableStringFieldUpdateOperationsInput | string | null
    attivo?: StringFieldUpdateOperationsInput | string
    typeutente?: StringFieldUpdateOperationsInput | string
    colore?: NullableStringFieldUpdateOperationsInput | string | null
    pianningEmail?: PianningEmailUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    idLogin?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    cognome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    societa?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicocod?: NullableStringFieldUpdateOperationsInput | string | null
    attivo?: StringFieldUpdateOperationsInput | string
    typeutente?: StringFieldUpdateOperationsInput | string
    colore?: NullableStringFieldUpdateOperationsInput | string | null
    pianningEmail?: PianningEmailUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    idLogin?: number
    nome?: string | null
    cognome?: string | null
    email: string
    password: string
    societa?: string | null
    tecnicocod?: string | null
    attivo?: string
    typeutente?: string
    colore?: string | null
  }

  export type UserUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    cognome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    societa?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicocod?: NullableStringFieldUpdateOperationsInput | string | null
    attivo?: StringFieldUpdateOperationsInput | string
    typeutente?: StringFieldUpdateOperationsInput | string
    colore?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    idLogin?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    cognome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    societa?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicocod?: NullableStringFieldUpdateOperationsInput | string | null
    attivo?: StringFieldUpdateOperationsInput | string
    typeutente?: StringFieldUpdateOperationsInput | string
    colore?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClienteCreateInput = {
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoCreateNestedManyWithoutClienteInput
    note?: ClienteNotaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneUncheckedCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoUncheckedCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoUncheckedCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoUncheckedCreateNestedManyWithoutClienteInput
    note?: ClienteNotaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUncheckedUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUncheckedUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUncheckedUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUncheckedUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
  }

  export type ClienteUpdateManyMutationInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteContattoCreateInput = {
    cliente: ClienteCreateNestedOneWithoutContattiInput
  }

  export type ClienteContattoUncheckedCreateInput = {
    id?: number
    idcliente: number
  }

  export type ClienteContattoUpdateInput = {
    cliente?: ClienteUpdateOneRequiredWithoutContattiNestedInput
  }

  export type ClienteContattoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteContattoCreateManyInput = {
    id?: number
    idcliente: number
  }

  export type ClienteContattoUpdateManyMutationInput = {

  }

  export type ClienteContattoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteContrattoCreateInput = {
    cliente: ClienteCreateNestedOneWithoutContrattiInput
  }

  export type ClienteContrattoUncheckedCreateInput = {
    id?: number
    idcliente: number
  }

  export type ClienteContrattoUpdateInput = {
    cliente?: ClienteUpdateOneRequiredWithoutContrattiNestedInput
  }

  export type ClienteContrattoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteContrattoCreateManyInput = {
    id?: number
    idcliente: number
  }

  export type ClienteContrattoUpdateManyMutationInput = {

  }

  export type ClienteContrattoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteNotaCreateInput = {
    cliente: ClienteCreateNestedOneWithoutNoteInput
  }

  export type ClienteNotaUncheckedCreateInput = {
    id?: number
    idcliente: number
  }

  export type ClienteNotaUpdateInput = {
    cliente?: ClienteUpdateOneRequiredWithoutNoteNestedInput
  }

  export type ClienteNotaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteNotaCreateManyInput = {
    id?: number
    idcliente: number
  }

  export type ClienteNotaUpdateManyMutationInput = {

  }

  export type ClienteNotaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteProdottoCreateInput = {
    idprodotto?: number | null
    cliente: ClienteCreateNestedOneWithoutProdottiInput
  }

  export type ClienteProdottoUncheckedCreateInput = {
    id?: number
    idcliente: number
    idprodotto?: number | null
  }

  export type ClienteProdottoUpdateInput = {
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    cliente?: ClienteUpdateOneRequiredWithoutProdottiNestedInput
  }

  export type ClienteProdottoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteProdottoCreateManyInput = {
    id?: number
    idcliente: number
    idprodotto?: number | null
  }

  export type ClienteProdottoUpdateManyMutationInput = {
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteProdottoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idcliente?: IntFieldUpdateOperationsInput | number
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneCreateInput = {
    datacreazione?: Date | string | null
    tipo?: string | null
    codice?: string | null
    anno?: number | null
    idazienda?: number | null
    idintervento?: number | null
    operatore?: string | null
    idprodotto?: number | null
    dataesecuzione?: Date | string | null
    orainizio?: number | null
    orafine?: number | null
    totaleore?: number | null
    osservazioni?: string | null
    codicecliente?: string | null
    stato?: number | null
    eliminato?: string | null
    idprodottocliente?: number | null
    faseoperazione?: number | null
    cliente?: ClienteCreateNestedOneWithoutOperazioniInput
  }

  export type OperazioneUncheckedCreateInput = {
    id?: number
    datacreazione?: Date | string | null
    tipo?: string | null
    codice?: string | null
    anno?: number | null
    idazienda?: number | null
    idcliente?: number | null
    idintervento?: number | null
    operatore?: string | null
    idprodotto?: number | null
    dataesecuzione?: Date | string | null
    orainizio?: number | null
    orafine?: number | null
    totaleore?: number | null
    osservazioni?: string | null
    codicecliente?: string | null
    stato?: number | null
    eliminato?: string | null
    idprodottocliente?: number | null
    faseoperazione?: number | null
  }

  export type OperazioneUpdateInput = {
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
    cliente?: ClienteUpdateOneWithoutOperazioniNestedInput
  }

  export type OperazioneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneCreateManyInput = {
    id?: number
    datacreazione?: Date | string | null
    tipo?: string | null
    codice?: string | null
    anno?: number | null
    idazienda?: number | null
    idcliente?: number | null
    idintervento?: number | null
    operatore?: string | null
    idprodotto?: number | null
    dataesecuzione?: Date | string | null
    orainizio?: number | null
    orafine?: number | null
    totaleore?: number | null
    osservazioni?: string | null
    codicecliente?: string | null
    stato?: number | null
    eliminato?: string | null
    idprodottocliente?: number | null
    faseoperazione?: number | null
  }

  export type OperazioneUpdateManyMutationInput = {
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idcliente?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneFirmaCreateInput = {
    idoperazione?: number | null
  }

  export type OperazioneFirmaUncheckedCreateInput = {
    id?: number
    idoperazione?: number | null
  }

  export type OperazioneFirmaUpdateInput = {
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneFirmaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneFirmaCreateManyInput = {
    id?: number
    idoperazione?: number | null
  }

  export type OperazioneFirmaUpdateManyMutationInput = {
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneFirmaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneDescrizazioniCreateInput = {
    idoperazione?: number | null
  }

  export type OperazioneDescrizazioniUncheckedCreateInput = {
    id?: number
    idoperazione?: number | null
  }

  export type OperazioneDescrizazioniUpdateInput = {
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneDescrizazioniUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneDescrizazioniCreateManyInput = {
    id?: number
    idoperazione?: number | null
  }

  export type OperazioneDescrizazioniUpdateManyMutationInput = {
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneDescrizazioniUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazionePutazioneCreateInput = {
    idoperazione?: number | null
  }

  export type OperazionePutazioneUncheckedCreateInput = {
    id?: number
    idoperazione?: number | null
  }

  export type OperazionePutazioneUpdateInput = {
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazionePutazioneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazionePutazioneCreateManyInput = {
    id?: number
    idoperazione?: number | null
  }

  export type OperazionePutazioneUpdateManyMutationInput = {
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazionePutazioneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProdottoCreateInput = {
    nome?: string | null
    voci?: ProdottoVoceCreateNestedManyWithoutProdottoInput
  }

  export type ProdottoUncheckedCreateInput = {
    id?: number
    nome?: string | null
    voci?: ProdottoVoceUncheckedCreateNestedManyWithoutProdottoInput
  }

  export type ProdottoUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    voci?: ProdottoVoceUpdateManyWithoutProdottoNestedInput
  }

  export type ProdottoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    voci?: ProdottoVoceUncheckedUpdateManyWithoutProdottoNestedInput
  }

  export type ProdottoCreateManyInput = {
    id?: number
    nome?: string | null
  }

  export type ProdottoUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProdottoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProdottoVoceCreateInput = {
    prodotto?: ProdottoCreateNestedOneWithoutVociInput
  }

  export type ProdottoVoceUncheckedCreateInput = {
    id?: number
    idprodotto?: number | null
  }

  export type ProdottoVoceUpdateInput = {
    prodotto?: ProdottoUpdateOneWithoutVociNestedInput
  }

  export type ProdottoVoceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProdottoVoceCreateManyInput = {
    id?: number
    idprodotto?: number | null
  }

  export type ProdottoVoceUpdateManyMutationInput = {

  }

  export type ProdottoVoceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContrattoCreateInput = {
    tipo?: number | null
    denominazione?: string | null
    tipodurata?: string | null
    durata?: number | null
    avvprima?: number | null
    avvdopo?: number | null
    cancellato?: string | null
  }

  export type ContrattoUncheckedCreateInput = {
    id?: number
    tipo?: number | null
    denominazione?: string | null
    tipodurata?: string | null
    durata?: number | null
    avvprima?: number | null
    avvdopo?: number | null
    cancellato?: string | null
  }

  export type ContrattoUpdateInput = {
    tipo?: NullableIntFieldUpdateOperationsInput | number | null
    denominazione?: NullableStringFieldUpdateOperationsInput | string | null
    tipodurata?: NullableStringFieldUpdateOperationsInput | string | null
    durata?: NullableIntFieldUpdateOperationsInput | number | null
    avvprima?: NullableIntFieldUpdateOperationsInput | number | null
    avvdopo?: NullableIntFieldUpdateOperationsInput | number | null
    cancellato?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContrattoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableIntFieldUpdateOperationsInput | number | null
    denominazione?: NullableStringFieldUpdateOperationsInput | string | null
    tipodurata?: NullableStringFieldUpdateOperationsInput | string | null
    durata?: NullableIntFieldUpdateOperationsInput | number | null
    avvprima?: NullableIntFieldUpdateOperationsInput | number | null
    avvdopo?: NullableIntFieldUpdateOperationsInput | number | null
    cancellato?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContrattoCreateManyInput = {
    id?: number
    tipo?: number | null
    denominazione?: string | null
    tipodurata?: string | null
    durata?: number | null
    avvprima?: number | null
    avvdopo?: number | null
    cancellato?: string | null
  }

  export type ContrattoUpdateManyMutationInput = {
    tipo?: NullableIntFieldUpdateOperationsInput | number | null
    denominazione?: NullableStringFieldUpdateOperationsInput | string | null
    tipodurata?: NullableStringFieldUpdateOperationsInput | string | null
    durata?: NullableIntFieldUpdateOperationsInput | number | null
    avvprima?: NullableIntFieldUpdateOperationsInput | number | null
    avvdopo?: NullableIntFieldUpdateOperationsInput | number | null
    cancellato?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContrattoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: NullableIntFieldUpdateOperationsInput | number | null
    denominazione?: NullableStringFieldUpdateOperationsInput | string | null
    tipodurata?: NullableStringFieldUpdateOperationsInput | string | null
    durata?: NullableIntFieldUpdateOperationsInput | number | null
    avvprima?: NullableIntFieldUpdateOperationsInput | number | null
    avvdopo?: NullableIntFieldUpdateOperationsInput | number | null
    cancellato?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PianningTipoInterventoCreateInput = {

  }

  export type PianningTipoInterventoUncheckedCreateInput = {
    id?: number
  }

  export type PianningTipoInterventoUpdateInput = {

  }

  export type PianningTipoInterventoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PianningTipoInterventoCreateManyInput = {
    id?: number
  }

  export type PianningTipoInterventoUpdateManyMutationInput = {

  }

  export type PianningTipoInterventoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PianningEmailCreateInput = {
    user?: UserCreateNestedOneWithoutPianningEmailInput
  }

  export type PianningEmailUncheckedCreateInput = {
    id?: number
    idlogin?: number | null
  }

  export type PianningEmailUpdateInput = {
    user?: UserUpdateOneWithoutPianningEmailNestedInput
  }

  export type PianningEmailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idlogin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PianningEmailCreateManyInput = {
    id?: number
    idlogin?: number | null
  }

  export type PianningEmailUpdateManyMutationInput = {

  }

  export type PianningEmailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idlogin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VociInterventoCreateInput = {

  }

  export type VociInterventoUncheckedCreateInput = {
    id?: number
  }

  export type VociInterventoUpdateInput = {

  }

  export type VociInterventoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VociInterventoCreateManyInput = {
    id?: number
  }

  export type VociInterventoUpdateManyMutationInput = {

  }

  export type VociInterventoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type StraordinarioCreateInput = {

  }

  export type StraordinarioUncheckedCreateInput = {
    id?: number
  }

  export type StraordinarioUpdateInput = {

  }

  export type StraordinarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type StraordinarioCreateManyInput = {
    id?: number
  }

  export type StraordinarioUpdateManyMutationInput = {

  }

  export type StraordinarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type InserimentoStraordinarioCreateInput = {

  }

  export type InserimentoStraordinarioUncheckedCreateInput = {
    id?: number
  }

  export type InserimentoStraordinarioUpdateInput = {

  }

  export type InserimentoStraordinarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type InserimentoStraordinarioCreateManyInput = {
    id?: number
  }

  export type InserimentoStraordinarioUpdateManyMutationInput = {

  }

  export type InserimentoStraordinarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ImpostazioniUtenteCreateInput = {

  }

  export type ImpostazioniUtenteUncheckedCreateInput = {
    id?: number
  }

  export type ImpostazioniUtenteUpdateInput = {

  }

  export type ImpostazioniUtenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ImpostazioniUtenteCreateManyInput = {
    id?: number
  }

  export type ImpostazioniUtenteUpdateManyMutationInput = {

  }

  export type ImpostazioniUtenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SpeseNottiCreateInput = {

  }

  export type SpeseNottiUncheckedCreateInput = {
    id?: number
  }

  export type SpeseNottiUpdateInput = {

  }

  export type SpeseNottiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SpeseNottiCreateManyInput = {
    id?: number
  }

  export type SpeseNottiUpdateManyMutationInput = {

  }

  export type SpeseNottiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PianningEmailListRelationFilter = {
    every?: PianningEmailWhereInput
    some?: PianningEmailWhereInput
    none?: PianningEmailWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PianningEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    idLogin?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
    email?: SortOrder
    password?: SortOrder
    societa?: SortOrder
    tecnicocod?: SortOrder
    attivo?: SortOrder
    typeutente?: SortOrder
    colore?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    idLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    idLogin?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
    email?: SortOrder
    password?: SortOrder
    societa?: SortOrder
    tecnicocod?: SortOrder
    attivo?: SortOrder
    typeutente?: SortOrder
    colore?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    idLogin?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
    email?: SortOrder
    password?: SortOrder
    societa?: SortOrder
    tecnicocod?: SortOrder
    attivo?: SortOrder
    typeutente?: SortOrder
    colore?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    idLogin?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OperazioneListRelationFilter = {
    every?: OperazioneWhereInput
    some?: OperazioneWhereInput
    none?: OperazioneWhereInput
  }

  export type ClienteProdottoListRelationFilter = {
    every?: ClienteProdottoWhereInput
    some?: ClienteProdottoWhereInput
    none?: ClienteProdottoWhereInput
  }

  export type ClienteContattoListRelationFilter = {
    every?: ClienteContattoWhereInput
    some?: ClienteContattoWhereInput
    none?: ClienteContattoWhereInput
  }

  export type ClienteContrattoListRelationFilter = {
    every?: ClienteContrattoWhereInput
    some?: ClienteContrattoWhereInput
    none?: ClienteContrattoWhereInput
  }

  export type ClienteNotaListRelationFilter = {
    every?: ClienteNotaWhereInput
    some?: ClienteNotaWhereInput
    none?: ClienteNotaWhereInput
  }

  export type OperazioneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteProdottoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteContattoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteContrattoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteNotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    codicecliente?: SortOrder
    idazienda?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
    idazienda?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    codicecliente?: SortOrder
    idazienda?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    codicecliente?: SortOrder
    idazienda?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
    idazienda?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ClienteScalarRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type ClienteContattoCountOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContattoAvgOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContattoMaxOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContattoMinOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContattoSumOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContrattoCountOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContrattoAvgOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContrattoMaxOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContrattoMinOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteContrattoSumOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteNotaCountOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteNotaAvgOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteNotaMaxOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteNotaMinOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteNotaSumOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
  }

  export type ClienteProdottoCountOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrder
  }

  export type ClienteProdottoAvgOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrder
  }

  export type ClienteProdottoMaxOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrder
  }

  export type ClienteProdottoMinOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrder
  }

  export type ClienteProdottoSumOrderByAggregateInput = {
    id?: SortOrder
    idcliente?: SortOrder
    idprodotto?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClienteNullableScalarRelationFilter = {
    is?: ClienteWhereInput | null
    isNot?: ClienteWhereInput | null
  }

  export type OperazioneCountOrderByAggregateInput = {
    id?: SortOrder
    datacreazione?: SortOrder
    tipo?: SortOrder
    codice?: SortOrder
    anno?: SortOrder
    idazienda?: SortOrder
    idcliente?: SortOrder
    idintervento?: SortOrder
    operatore?: SortOrder
    idprodotto?: SortOrder
    dataesecuzione?: SortOrder
    orainizio?: SortOrder
    orafine?: SortOrder
    totaleore?: SortOrder
    osservazioni?: SortOrder
    codicecliente?: SortOrder
    stato?: SortOrder
    eliminato?: SortOrder
    idprodottocliente?: SortOrder
    faseoperazione?: SortOrder
  }

  export type OperazioneAvgOrderByAggregateInput = {
    id?: SortOrder
    anno?: SortOrder
    idazienda?: SortOrder
    idcliente?: SortOrder
    idintervento?: SortOrder
    idprodotto?: SortOrder
    orainizio?: SortOrder
    orafine?: SortOrder
    totaleore?: SortOrder
    stato?: SortOrder
    idprodottocliente?: SortOrder
    faseoperazione?: SortOrder
  }

  export type OperazioneMaxOrderByAggregateInput = {
    id?: SortOrder
    datacreazione?: SortOrder
    tipo?: SortOrder
    codice?: SortOrder
    anno?: SortOrder
    idazienda?: SortOrder
    idcliente?: SortOrder
    idintervento?: SortOrder
    operatore?: SortOrder
    idprodotto?: SortOrder
    dataesecuzione?: SortOrder
    orainizio?: SortOrder
    orafine?: SortOrder
    totaleore?: SortOrder
    osservazioni?: SortOrder
    codicecliente?: SortOrder
    stato?: SortOrder
    eliminato?: SortOrder
    idprodottocliente?: SortOrder
    faseoperazione?: SortOrder
  }

  export type OperazioneMinOrderByAggregateInput = {
    id?: SortOrder
    datacreazione?: SortOrder
    tipo?: SortOrder
    codice?: SortOrder
    anno?: SortOrder
    idazienda?: SortOrder
    idcliente?: SortOrder
    idintervento?: SortOrder
    operatore?: SortOrder
    idprodotto?: SortOrder
    dataesecuzione?: SortOrder
    orainizio?: SortOrder
    orafine?: SortOrder
    totaleore?: SortOrder
    osservazioni?: SortOrder
    codicecliente?: SortOrder
    stato?: SortOrder
    eliminato?: SortOrder
    idprodottocliente?: SortOrder
    faseoperazione?: SortOrder
  }

  export type OperazioneSumOrderByAggregateInput = {
    id?: SortOrder
    anno?: SortOrder
    idazienda?: SortOrder
    idcliente?: SortOrder
    idintervento?: SortOrder
    idprodotto?: SortOrder
    orainizio?: SortOrder
    orafine?: SortOrder
    totaleore?: SortOrder
    stato?: SortOrder
    idprodottocliente?: SortOrder
    faseoperazione?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OperazioneFirmaCountOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneFirmaAvgOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneFirmaMaxOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneFirmaMinOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneFirmaSumOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneDescrizazioniCountOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneDescrizazioniAvgOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneDescrizazioniMaxOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneDescrizazioniMinOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazioneDescrizazioniSumOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazionePutazioneCountOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazionePutazioneAvgOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazionePutazioneMaxOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazionePutazioneMinOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type OperazionePutazioneSumOrderByAggregateInput = {
    id?: SortOrder
    idoperazione?: SortOrder
  }

  export type ProdottoVoceListRelationFilter = {
    every?: ProdottoVoceWhereInput
    some?: ProdottoVoceWhereInput
    none?: ProdottoVoceWhereInput
  }

  export type ProdottoVoceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProdottoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type ProdottoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProdottoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type ProdottoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type ProdottoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProdottoNullableScalarRelationFilter = {
    is?: ProdottoWhereInput | null
    isNot?: ProdottoWhereInput | null
  }

  export type ProdottoVoceCountOrderByAggregateInput = {
    id?: SortOrder
    idprodotto?: SortOrder
  }

  export type ProdottoVoceAvgOrderByAggregateInput = {
    id?: SortOrder
    idprodotto?: SortOrder
  }

  export type ProdottoVoceMaxOrderByAggregateInput = {
    id?: SortOrder
    idprodotto?: SortOrder
  }

  export type ProdottoVoceMinOrderByAggregateInput = {
    id?: SortOrder
    idprodotto?: SortOrder
  }

  export type ProdottoVoceSumOrderByAggregateInput = {
    id?: SortOrder
    idprodotto?: SortOrder
  }

  export type ContrattoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    denominazione?: SortOrder
    tipodurata?: SortOrder
    durata?: SortOrder
    avvprima?: SortOrder
    avvdopo?: SortOrder
    cancellato?: SortOrder
  }

  export type ContrattoAvgOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    durata?: SortOrder
    avvprima?: SortOrder
    avvdopo?: SortOrder
  }

  export type ContrattoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    denominazione?: SortOrder
    tipodurata?: SortOrder
    durata?: SortOrder
    avvprima?: SortOrder
    avvdopo?: SortOrder
    cancellato?: SortOrder
  }

  export type ContrattoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    denominazione?: SortOrder
    tipodurata?: SortOrder
    durata?: SortOrder
    avvprima?: SortOrder
    avvdopo?: SortOrder
    cancellato?: SortOrder
  }

  export type ContrattoSumOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    durata?: SortOrder
    avvprima?: SortOrder
    avvdopo?: SortOrder
  }

  export type PianningTipoInterventoCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PianningTipoInterventoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PianningTipoInterventoMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PianningTipoInterventoMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PianningTipoInterventoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PianningEmailCountOrderByAggregateInput = {
    id?: SortOrder
    idlogin?: SortOrder
  }

  export type PianningEmailAvgOrderByAggregateInput = {
    id?: SortOrder
    idlogin?: SortOrder
  }

  export type PianningEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    idlogin?: SortOrder
  }

  export type PianningEmailMinOrderByAggregateInput = {
    id?: SortOrder
    idlogin?: SortOrder
  }

  export type PianningEmailSumOrderByAggregateInput = {
    id?: SortOrder
    idlogin?: SortOrder
  }

  export type VociInterventoCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VociInterventoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VociInterventoMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VociInterventoMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VociInterventoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StraordinarioCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StraordinarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StraordinarioMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StraordinarioMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StraordinarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InserimentoStraordinarioCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InserimentoStraordinarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InserimentoStraordinarioMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InserimentoStraordinarioMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InserimentoStraordinarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImpostazioniUtenteCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImpostazioniUtenteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImpostazioniUtenteMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImpostazioniUtenteMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImpostazioniUtenteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeseNottiCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeseNottiAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeseNottiMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeseNottiMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeseNottiSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PianningEmailCreateNestedManyWithoutUserInput = {
    create?: XOR<PianningEmailCreateWithoutUserInput, PianningEmailUncheckedCreateWithoutUserInput> | PianningEmailCreateWithoutUserInput[] | PianningEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PianningEmailCreateOrConnectWithoutUserInput | PianningEmailCreateOrConnectWithoutUserInput[]
    createMany?: PianningEmailCreateManyUserInputEnvelope
    connect?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
  }

  export type PianningEmailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PianningEmailCreateWithoutUserInput, PianningEmailUncheckedCreateWithoutUserInput> | PianningEmailCreateWithoutUserInput[] | PianningEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PianningEmailCreateOrConnectWithoutUserInput | PianningEmailCreateOrConnectWithoutUserInput[]
    createMany?: PianningEmailCreateManyUserInputEnvelope
    connect?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PianningEmailUpdateManyWithoutUserNestedInput = {
    create?: XOR<PianningEmailCreateWithoutUserInput, PianningEmailUncheckedCreateWithoutUserInput> | PianningEmailCreateWithoutUserInput[] | PianningEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PianningEmailCreateOrConnectWithoutUserInput | PianningEmailCreateOrConnectWithoutUserInput[]
    upsert?: PianningEmailUpsertWithWhereUniqueWithoutUserInput | PianningEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PianningEmailCreateManyUserInputEnvelope
    set?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    disconnect?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    delete?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    connect?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    update?: PianningEmailUpdateWithWhereUniqueWithoutUserInput | PianningEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PianningEmailUpdateManyWithWhereWithoutUserInput | PianningEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PianningEmailScalarWhereInput | PianningEmailScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PianningEmailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PianningEmailCreateWithoutUserInput, PianningEmailUncheckedCreateWithoutUserInput> | PianningEmailCreateWithoutUserInput[] | PianningEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PianningEmailCreateOrConnectWithoutUserInput | PianningEmailCreateOrConnectWithoutUserInput[]
    upsert?: PianningEmailUpsertWithWhereUniqueWithoutUserInput | PianningEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PianningEmailCreateManyUserInputEnvelope
    set?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    disconnect?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    delete?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    connect?: PianningEmailWhereUniqueInput | PianningEmailWhereUniqueInput[]
    update?: PianningEmailUpdateWithWhereUniqueWithoutUserInput | PianningEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PianningEmailUpdateManyWithWhereWithoutUserInput | PianningEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PianningEmailScalarWhereInput | PianningEmailScalarWhereInput[]
  }

  export type OperazioneCreateNestedManyWithoutClienteInput = {
    create?: XOR<OperazioneCreateWithoutClienteInput, OperazioneUncheckedCreateWithoutClienteInput> | OperazioneCreateWithoutClienteInput[] | OperazioneUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OperazioneCreateOrConnectWithoutClienteInput | OperazioneCreateOrConnectWithoutClienteInput[]
    createMany?: OperazioneCreateManyClienteInputEnvelope
    connect?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
  }

  export type ClienteProdottoCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteProdottoCreateWithoutClienteInput, ClienteProdottoUncheckedCreateWithoutClienteInput> | ClienteProdottoCreateWithoutClienteInput[] | ClienteProdottoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteProdottoCreateOrConnectWithoutClienteInput | ClienteProdottoCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteProdottoCreateManyClienteInputEnvelope
    connect?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
  }

  export type ClienteContattoCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteContattoCreateWithoutClienteInput, ClienteContattoUncheckedCreateWithoutClienteInput> | ClienteContattoCreateWithoutClienteInput[] | ClienteContattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContattoCreateOrConnectWithoutClienteInput | ClienteContattoCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteContattoCreateManyClienteInputEnvelope
    connect?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
  }

  export type ClienteContrattoCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteContrattoCreateWithoutClienteInput, ClienteContrattoUncheckedCreateWithoutClienteInput> | ClienteContrattoCreateWithoutClienteInput[] | ClienteContrattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContrattoCreateOrConnectWithoutClienteInput | ClienteContrattoCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteContrattoCreateManyClienteInputEnvelope
    connect?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
  }

  export type ClienteNotaCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteNotaCreateWithoutClienteInput, ClienteNotaUncheckedCreateWithoutClienteInput> | ClienteNotaCreateWithoutClienteInput[] | ClienteNotaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteNotaCreateOrConnectWithoutClienteInput | ClienteNotaCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteNotaCreateManyClienteInputEnvelope
    connect?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
  }

  export type OperazioneUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<OperazioneCreateWithoutClienteInput, OperazioneUncheckedCreateWithoutClienteInput> | OperazioneCreateWithoutClienteInput[] | OperazioneUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OperazioneCreateOrConnectWithoutClienteInput | OperazioneCreateOrConnectWithoutClienteInput[]
    createMany?: OperazioneCreateManyClienteInputEnvelope
    connect?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
  }

  export type ClienteProdottoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteProdottoCreateWithoutClienteInput, ClienteProdottoUncheckedCreateWithoutClienteInput> | ClienteProdottoCreateWithoutClienteInput[] | ClienteProdottoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteProdottoCreateOrConnectWithoutClienteInput | ClienteProdottoCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteProdottoCreateManyClienteInputEnvelope
    connect?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
  }

  export type ClienteContattoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteContattoCreateWithoutClienteInput, ClienteContattoUncheckedCreateWithoutClienteInput> | ClienteContattoCreateWithoutClienteInput[] | ClienteContattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContattoCreateOrConnectWithoutClienteInput | ClienteContattoCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteContattoCreateManyClienteInputEnvelope
    connect?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
  }

  export type ClienteContrattoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteContrattoCreateWithoutClienteInput, ClienteContrattoUncheckedCreateWithoutClienteInput> | ClienteContrattoCreateWithoutClienteInput[] | ClienteContrattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContrattoCreateOrConnectWithoutClienteInput | ClienteContrattoCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteContrattoCreateManyClienteInputEnvelope
    connect?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
  }

  export type ClienteNotaUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ClienteNotaCreateWithoutClienteInput, ClienteNotaUncheckedCreateWithoutClienteInput> | ClienteNotaCreateWithoutClienteInput[] | ClienteNotaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteNotaCreateOrConnectWithoutClienteInput | ClienteNotaCreateOrConnectWithoutClienteInput[]
    createMany?: ClienteNotaCreateManyClienteInputEnvelope
    connect?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OperazioneUpdateManyWithoutClienteNestedInput = {
    create?: XOR<OperazioneCreateWithoutClienteInput, OperazioneUncheckedCreateWithoutClienteInput> | OperazioneCreateWithoutClienteInput[] | OperazioneUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OperazioneCreateOrConnectWithoutClienteInput | OperazioneCreateOrConnectWithoutClienteInput[]
    upsert?: OperazioneUpsertWithWhereUniqueWithoutClienteInput | OperazioneUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: OperazioneCreateManyClienteInputEnvelope
    set?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    disconnect?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    delete?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    connect?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    update?: OperazioneUpdateWithWhereUniqueWithoutClienteInput | OperazioneUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: OperazioneUpdateManyWithWhereWithoutClienteInput | OperazioneUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: OperazioneScalarWhereInput | OperazioneScalarWhereInput[]
  }

  export type ClienteProdottoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteProdottoCreateWithoutClienteInput, ClienteProdottoUncheckedCreateWithoutClienteInput> | ClienteProdottoCreateWithoutClienteInput[] | ClienteProdottoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteProdottoCreateOrConnectWithoutClienteInput | ClienteProdottoCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteProdottoUpsertWithWhereUniqueWithoutClienteInput | ClienteProdottoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteProdottoCreateManyClienteInputEnvelope
    set?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    disconnect?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    delete?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    connect?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    update?: ClienteProdottoUpdateWithWhereUniqueWithoutClienteInput | ClienteProdottoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteProdottoUpdateManyWithWhereWithoutClienteInput | ClienteProdottoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteProdottoScalarWhereInput | ClienteProdottoScalarWhereInput[]
  }

  export type ClienteContattoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteContattoCreateWithoutClienteInput, ClienteContattoUncheckedCreateWithoutClienteInput> | ClienteContattoCreateWithoutClienteInput[] | ClienteContattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContattoCreateOrConnectWithoutClienteInput | ClienteContattoCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteContattoUpsertWithWhereUniqueWithoutClienteInput | ClienteContattoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteContattoCreateManyClienteInputEnvelope
    set?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    disconnect?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    delete?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    connect?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    update?: ClienteContattoUpdateWithWhereUniqueWithoutClienteInput | ClienteContattoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteContattoUpdateManyWithWhereWithoutClienteInput | ClienteContattoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteContattoScalarWhereInput | ClienteContattoScalarWhereInput[]
  }

  export type ClienteContrattoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteContrattoCreateWithoutClienteInput, ClienteContrattoUncheckedCreateWithoutClienteInput> | ClienteContrattoCreateWithoutClienteInput[] | ClienteContrattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContrattoCreateOrConnectWithoutClienteInput | ClienteContrattoCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteContrattoUpsertWithWhereUniqueWithoutClienteInput | ClienteContrattoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteContrattoCreateManyClienteInputEnvelope
    set?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    disconnect?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    delete?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    connect?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    update?: ClienteContrattoUpdateWithWhereUniqueWithoutClienteInput | ClienteContrattoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteContrattoUpdateManyWithWhereWithoutClienteInput | ClienteContrattoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteContrattoScalarWhereInput | ClienteContrattoScalarWhereInput[]
  }

  export type ClienteNotaUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteNotaCreateWithoutClienteInput, ClienteNotaUncheckedCreateWithoutClienteInput> | ClienteNotaCreateWithoutClienteInput[] | ClienteNotaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteNotaCreateOrConnectWithoutClienteInput | ClienteNotaCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteNotaUpsertWithWhereUniqueWithoutClienteInput | ClienteNotaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteNotaCreateManyClienteInputEnvelope
    set?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    disconnect?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    delete?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    connect?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    update?: ClienteNotaUpdateWithWhereUniqueWithoutClienteInput | ClienteNotaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteNotaUpdateManyWithWhereWithoutClienteInput | ClienteNotaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteNotaScalarWhereInput | ClienteNotaScalarWhereInput[]
  }

  export type OperazioneUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<OperazioneCreateWithoutClienteInput, OperazioneUncheckedCreateWithoutClienteInput> | OperazioneCreateWithoutClienteInput[] | OperazioneUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OperazioneCreateOrConnectWithoutClienteInput | OperazioneCreateOrConnectWithoutClienteInput[]
    upsert?: OperazioneUpsertWithWhereUniqueWithoutClienteInput | OperazioneUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: OperazioneCreateManyClienteInputEnvelope
    set?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    disconnect?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    delete?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    connect?: OperazioneWhereUniqueInput | OperazioneWhereUniqueInput[]
    update?: OperazioneUpdateWithWhereUniqueWithoutClienteInput | OperazioneUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: OperazioneUpdateManyWithWhereWithoutClienteInput | OperazioneUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: OperazioneScalarWhereInput | OperazioneScalarWhereInput[]
  }

  export type ClienteProdottoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteProdottoCreateWithoutClienteInput, ClienteProdottoUncheckedCreateWithoutClienteInput> | ClienteProdottoCreateWithoutClienteInput[] | ClienteProdottoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteProdottoCreateOrConnectWithoutClienteInput | ClienteProdottoCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteProdottoUpsertWithWhereUniqueWithoutClienteInput | ClienteProdottoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteProdottoCreateManyClienteInputEnvelope
    set?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    disconnect?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    delete?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    connect?: ClienteProdottoWhereUniqueInput | ClienteProdottoWhereUniqueInput[]
    update?: ClienteProdottoUpdateWithWhereUniqueWithoutClienteInput | ClienteProdottoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteProdottoUpdateManyWithWhereWithoutClienteInput | ClienteProdottoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteProdottoScalarWhereInput | ClienteProdottoScalarWhereInput[]
  }

  export type ClienteContattoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteContattoCreateWithoutClienteInput, ClienteContattoUncheckedCreateWithoutClienteInput> | ClienteContattoCreateWithoutClienteInput[] | ClienteContattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContattoCreateOrConnectWithoutClienteInput | ClienteContattoCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteContattoUpsertWithWhereUniqueWithoutClienteInput | ClienteContattoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteContattoCreateManyClienteInputEnvelope
    set?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    disconnect?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    delete?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    connect?: ClienteContattoWhereUniqueInput | ClienteContattoWhereUniqueInput[]
    update?: ClienteContattoUpdateWithWhereUniqueWithoutClienteInput | ClienteContattoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteContattoUpdateManyWithWhereWithoutClienteInput | ClienteContattoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteContattoScalarWhereInput | ClienteContattoScalarWhereInput[]
  }

  export type ClienteContrattoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteContrattoCreateWithoutClienteInput, ClienteContrattoUncheckedCreateWithoutClienteInput> | ClienteContrattoCreateWithoutClienteInput[] | ClienteContrattoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteContrattoCreateOrConnectWithoutClienteInput | ClienteContrattoCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteContrattoUpsertWithWhereUniqueWithoutClienteInput | ClienteContrattoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteContrattoCreateManyClienteInputEnvelope
    set?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    disconnect?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    delete?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    connect?: ClienteContrattoWhereUniqueInput | ClienteContrattoWhereUniqueInput[]
    update?: ClienteContrattoUpdateWithWhereUniqueWithoutClienteInput | ClienteContrattoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteContrattoUpdateManyWithWhereWithoutClienteInput | ClienteContrattoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteContrattoScalarWhereInput | ClienteContrattoScalarWhereInput[]
  }

  export type ClienteNotaUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ClienteNotaCreateWithoutClienteInput, ClienteNotaUncheckedCreateWithoutClienteInput> | ClienteNotaCreateWithoutClienteInput[] | ClienteNotaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ClienteNotaCreateOrConnectWithoutClienteInput | ClienteNotaCreateOrConnectWithoutClienteInput[]
    upsert?: ClienteNotaUpsertWithWhereUniqueWithoutClienteInput | ClienteNotaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ClienteNotaCreateManyClienteInputEnvelope
    set?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    disconnect?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    delete?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    connect?: ClienteNotaWhereUniqueInput | ClienteNotaWhereUniqueInput[]
    update?: ClienteNotaUpdateWithWhereUniqueWithoutClienteInput | ClienteNotaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ClienteNotaUpdateManyWithWhereWithoutClienteInput | ClienteNotaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ClienteNotaScalarWhereInput | ClienteNotaScalarWhereInput[]
  }

  export type ClienteCreateNestedOneWithoutContattiInput = {
    create?: XOR<ClienteCreateWithoutContattiInput, ClienteUncheckedCreateWithoutContattiInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutContattiInput
    connect?: ClienteWhereUniqueInput
  }

  export type ClienteUpdateOneRequiredWithoutContattiNestedInput = {
    create?: XOR<ClienteCreateWithoutContattiInput, ClienteUncheckedCreateWithoutContattiInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutContattiInput
    upsert?: ClienteUpsertWithoutContattiInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutContattiInput, ClienteUpdateWithoutContattiInput>, ClienteUncheckedUpdateWithoutContattiInput>
  }

  export type ClienteCreateNestedOneWithoutContrattiInput = {
    create?: XOR<ClienteCreateWithoutContrattiInput, ClienteUncheckedCreateWithoutContrattiInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutContrattiInput
    connect?: ClienteWhereUniqueInput
  }

  export type ClienteUpdateOneRequiredWithoutContrattiNestedInput = {
    create?: XOR<ClienteCreateWithoutContrattiInput, ClienteUncheckedCreateWithoutContrattiInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutContrattiInput
    upsert?: ClienteUpsertWithoutContrattiInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutContrattiInput, ClienteUpdateWithoutContrattiInput>, ClienteUncheckedUpdateWithoutContrattiInput>
  }

  export type ClienteCreateNestedOneWithoutNoteInput = {
    create?: XOR<ClienteCreateWithoutNoteInput, ClienteUncheckedCreateWithoutNoteInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutNoteInput
    connect?: ClienteWhereUniqueInput
  }

  export type ClienteUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<ClienteCreateWithoutNoteInput, ClienteUncheckedCreateWithoutNoteInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutNoteInput
    upsert?: ClienteUpsertWithoutNoteInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutNoteInput, ClienteUpdateWithoutNoteInput>, ClienteUncheckedUpdateWithoutNoteInput>
  }

  export type ClienteCreateNestedOneWithoutProdottiInput = {
    create?: XOR<ClienteCreateWithoutProdottiInput, ClienteUncheckedCreateWithoutProdottiInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutProdottiInput
    connect?: ClienteWhereUniqueInput
  }

  export type ClienteUpdateOneRequiredWithoutProdottiNestedInput = {
    create?: XOR<ClienteCreateWithoutProdottiInput, ClienteUncheckedCreateWithoutProdottiInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutProdottiInput
    upsert?: ClienteUpsertWithoutProdottiInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutProdottiInput, ClienteUpdateWithoutProdottiInput>, ClienteUncheckedUpdateWithoutProdottiInput>
  }

  export type ClienteCreateNestedOneWithoutOperazioniInput = {
    create?: XOR<ClienteCreateWithoutOperazioniInput, ClienteUncheckedCreateWithoutOperazioniInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutOperazioniInput
    connect?: ClienteWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClienteUpdateOneWithoutOperazioniNestedInput = {
    create?: XOR<ClienteCreateWithoutOperazioniInput, ClienteUncheckedCreateWithoutOperazioniInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutOperazioniInput
    upsert?: ClienteUpsertWithoutOperazioniInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutOperazioniInput, ClienteUpdateWithoutOperazioniInput>, ClienteUncheckedUpdateWithoutOperazioniInput>
  }

  export type ProdottoVoceCreateNestedManyWithoutProdottoInput = {
    create?: XOR<ProdottoVoceCreateWithoutProdottoInput, ProdottoVoceUncheckedCreateWithoutProdottoInput> | ProdottoVoceCreateWithoutProdottoInput[] | ProdottoVoceUncheckedCreateWithoutProdottoInput[]
    connectOrCreate?: ProdottoVoceCreateOrConnectWithoutProdottoInput | ProdottoVoceCreateOrConnectWithoutProdottoInput[]
    createMany?: ProdottoVoceCreateManyProdottoInputEnvelope
    connect?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
  }

  export type ProdottoVoceUncheckedCreateNestedManyWithoutProdottoInput = {
    create?: XOR<ProdottoVoceCreateWithoutProdottoInput, ProdottoVoceUncheckedCreateWithoutProdottoInput> | ProdottoVoceCreateWithoutProdottoInput[] | ProdottoVoceUncheckedCreateWithoutProdottoInput[]
    connectOrCreate?: ProdottoVoceCreateOrConnectWithoutProdottoInput | ProdottoVoceCreateOrConnectWithoutProdottoInput[]
    createMany?: ProdottoVoceCreateManyProdottoInputEnvelope
    connect?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
  }

  export type ProdottoVoceUpdateManyWithoutProdottoNestedInput = {
    create?: XOR<ProdottoVoceCreateWithoutProdottoInput, ProdottoVoceUncheckedCreateWithoutProdottoInput> | ProdottoVoceCreateWithoutProdottoInput[] | ProdottoVoceUncheckedCreateWithoutProdottoInput[]
    connectOrCreate?: ProdottoVoceCreateOrConnectWithoutProdottoInput | ProdottoVoceCreateOrConnectWithoutProdottoInput[]
    upsert?: ProdottoVoceUpsertWithWhereUniqueWithoutProdottoInput | ProdottoVoceUpsertWithWhereUniqueWithoutProdottoInput[]
    createMany?: ProdottoVoceCreateManyProdottoInputEnvelope
    set?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    disconnect?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    delete?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    connect?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    update?: ProdottoVoceUpdateWithWhereUniqueWithoutProdottoInput | ProdottoVoceUpdateWithWhereUniqueWithoutProdottoInput[]
    updateMany?: ProdottoVoceUpdateManyWithWhereWithoutProdottoInput | ProdottoVoceUpdateManyWithWhereWithoutProdottoInput[]
    deleteMany?: ProdottoVoceScalarWhereInput | ProdottoVoceScalarWhereInput[]
  }

  export type ProdottoVoceUncheckedUpdateManyWithoutProdottoNestedInput = {
    create?: XOR<ProdottoVoceCreateWithoutProdottoInput, ProdottoVoceUncheckedCreateWithoutProdottoInput> | ProdottoVoceCreateWithoutProdottoInput[] | ProdottoVoceUncheckedCreateWithoutProdottoInput[]
    connectOrCreate?: ProdottoVoceCreateOrConnectWithoutProdottoInput | ProdottoVoceCreateOrConnectWithoutProdottoInput[]
    upsert?: ProdottoVoceUpsertWithWhereUniqueWithoutProdottoInput | ProdottoVoceUpsertWithWhereUniqueWithoutProdottoInput[]
    createMany?: ProdottoVoceCreateManyProdottoInputEnvelope
    set?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    disconnect?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    delete?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    connect?: ProdottoVoceWhereUniqueInput | ProdottoVoceWhereUniqueInput[]
    update?: ProdottoVoceUpdateWithWhereUniqueWithoutProdottoInput | ProdottoVoceUpdateWithWhereUniqueWithoutProdottoInput[]
    updateMany?: ProdottoVoceUpdateManyWithWhereWithoutProdottoInput | ProdottoVoceUpdateManyWithWhereWithoutProdottoInput[]
    deleteMany?: ProdottoVoceScalarWhereInput | ProdottoVoceScalarWhereInput[]
  }

  export type ProdottoCreateNestedOneWithoutVociInput = {
    create?: XOR<ProdottoCreateWithoutVociInput, ProdottoUncheckedCreateWithoutVociInput>
    connectOrCreate?: ProdottoCreateOrConnectWithoutVociInput
    connect?: ProdottoWhereUniqueInput
  }

  export type ProdottoUpdateOneWithoutVociNestedInput = {
    create?: XOR<ProdottoCreateWithoutVociInput, ProdottoUncheckedCreateWithoutVociInput>
    connectOrCreate?: ProdottoCreateOrConnectWithoutVociInput
    upsert?: ProdottoUpsertWithoutVociInput
    disconnect?: ProdottoWhereInput | boolean
    delete?: ProdottoWhereInput | boolean
    connect?: ProdottoWhereUniqueInput
    update?: XOR<XOR<ProdottoUpdateToOneWithWhereWithoutVociInput, ProdottoUpdateWithoutVociInput>, ProdottoUncheckedUpdateWithoutVociInput>
  }

  export type UserCreateNestedOneWithoutPianningEmailInput = {
    create?: XOR<UserCreateWithoutPianningEmailInput, UserUncheckedCreateWithoutPianningEmailInput>
    connectOrCreate?: UserCreateOrConnectWithoutPianningEmailInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPianningEmailNestedInput = {
    create?: XOR<UserCreateWithoutPianningEmailInput, UserUncheckedCreateWithoutPianningEmailInput>
    connectOrCreate?: UserCreateOrConnectWithoutPianningEmailInput
    upsert?: UserUpsertWithoutPianningEmailInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPianningEmailInput, UserUpdateWithoutPianningEmailInput>, UserUncheckedUpdateWithoutPianningEmailInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PianningEmailCreateWithoutUserInput = {

  }

  export type PianningEmailUncheckedCreateWithoutUserInput = {
    id?: number
  }

  export type PianningEmailCreateOrConnectWithoutUserInput = {
    where: PianningEmailWhereUniqueInput
    create: XOR<PianningEmailCreateWithoutUserInput, PianningEmailUncheckedCreateWithoutUserInput>
  }

  export type PianningEmailCreateManyUserInputEnvelope = {
    data: PianningEmailCreateManyUserInput | PianningEmailCreateManyUserInput[]
  }

  export type PianningEmailUpsertWithWhereUniqueWithoutUserInput = {
    where: PianningEmailWhereUniqueInput
    update: XOR<PianningEmailUpdateWithoutUserInput, PianningEmailUncheckedUpdateWithoutUserInput>
    create: XOR<PianningEmailCreateWithoutUserInput, PianningEmailUncheckedCreateWithoutUserInput>
  }

  export type PianningEmailUpdateWithWhereUniqueWithoutUserInput = {
    where: PianningEmailWhereUniqueInput
    data: XOR<PianningEmailUpdateWithoutUserInput, PianningEmailUncheckedUpdateWithoutUserInput>
  }

  export type PianningEmailUpdateManyWithWhereWithoutUserInput = {
    where: PianningEmailScalarWhereInput
    data: XOR<PianningEmailUpdateManyMutationInput, PianningEmailUncheckedUpdateManyWithoutUserInput>
  }

  export type PianningEmailScalarWhereInput = {
    AND?: PianningEmailScalarWhereInput | PianningEmailScalarWhereInput[]
    OR?: PianningEmailScalarWhereInput[]
    NOT?: PianningEmailScalarWhereInput | PianningEmailScalarWhereInput[]
    id?: IntFilter<"PianningEmail"> | number
    idlogin?: IntNullableFilter<"PianningEmail"> | number | null
  }

  export type OperazioneCreateWithoutClienteInput = {
    datacreazione?: Date | string | null
    tipo?: string | null
    codice?: string | null
    anno?: number | null
    idazienda?: number | null
    idintervento?: number | null
    operatore?: string | null
    idprodotto?: number | null
    dataesecuzione?: Date | string | null
    orainizio?: number | null
    orafine?: number | null
    totaleore?: number | null
    osservazioni?: string | null
    codicecliente?: string | null
    stato?: number | null
    eliminato?: string | null
    idprodottocliente?: number | null
    faseoperazione?: number | null
  }

  export type OperazioneUncheckedCreateWithoutClienteInput = {
    id?: number
    datacreazione?: Date | string | null
    tipo?: string | null
    codice?: string | null
    anno?: number | null
    idazienda?: number | null
    idintervento?: number | null
    operatore?: string | null
    idprodotto?: number | null
    dataesecuzione?: Date | string | null
    orainizio?: number | null
    orafine?: number | null
    totaleore?: number | null
    osservazioni?: string | null
    codicecliente?: string | null
    stato?: number | null
    eliminato?: string | null
    idprodottocliente?: number | null
    faseoperazione?: number | null
  }

  export type OperazioneCreateOrConnectWithoutClienteInput = {
    where: OperazioneWhereUniqueInput
    create: XOR<OperazioneCreateWithoutClienteInput, OperazioneUncheckedCreateWithoutClienteInput>
  }

  export type OperazioneCreateManyClienteInputEnvelope = {
    data: OperazioneCreateManyClienteInput | OperazioneCreateManyClienteInput[]
  }

  export type ClienteProdottoCreateWithoutClienteInput = {
    idprodotto?: number | null
  }

  export type ClienteProdottoUncheckedCreateWithoutClienteInput = {
    id?: number
    idprodotto?: number | null
  }

  export type ClienteProdottoCreateOrConnectWithoutClienteInput = {
    where: ClienteProdottoWhereUniqueInput
    create: XOR<ClienteProdottoCreateWithoutClienteInput, ClienteProdottoUncheckedCreateWithoutClienteInput>
  }

  export type ClienteProdottoCreateManyClienteInputEnvelope = {
    data: ClienteProdottoCreateManyClienteInput | ClienteProdottoCreateManyClienteInput[]
  }

  export type ClienteContattoCreateWithoutClienteInput = {

  }

  export type ClienteContattoUncheckedCreateWithoutClienteInput = {
    id?: number
  }

  export type ClienteContattoCreateOrConnectWithoutClienteInput = {
    where: ClienteContattoWhereUniqueInput
    create: XOR<ClienteContattoCreateWithoutClienteInput, ClienteContattoUncheckedCreateWithoutClienteInput>
  }

  export type ClienteContattoCreateManyClienteInputEnvelope = {
    data: ClienteContattoCreateManyClienteInput | ClienteContattoCreateManyClienteInput[]
  }

  export type ClienteContrattoCreateWithoutClienteInput = {

  }

  export type ClienteContrattoUncheckedCreateWithoutClienteInput = {
    id?: number
  }

  export type ClienteContrattoCreateOrConnectWithoutClienteInput = {
    where: ClienteContrattoWhereUniqueInput
    create: XOR<ClienteContrattoCreateWithoutClienteInput, ClienteContrattoUncheckedCreateWithoutClienteInput>
  }

  export type ClienteContrattoCreateManyClienteInputEnvelope = {
    data: ClienteContrattoCreateManyClienteInput | ClienteContrattoCreateManyClienteInput[]
  }

  export type ClienteNotaCreateWithoutClienteInput = {

  }

  export type ClienteNotaUncheckedCreateWithoutClienteInput = {
    id?: number
  }

  export type ClienteNotaCreateOrConnectWithoutClienteInput = {
    where: ClienteNotaWhereUniqueInput
    create: XOR<ClienteNotaCreateWithoutClienteInput, ClienteNotaUncheckedCreateWithoutClienteInput>
  }

  export type ClienteNotaCreateManyClienteInputEnvelope = {
    data: ClienteNotaCreateManyClienteInput | ClienteNotaCreateManyClienteInput[]
  }

  export type OperazioneUpsertWithWhereUniqueWithoutClienteInput = {
    where: OperazioneWhereUniqueInput
    update: XOR<OperazioneUpdateWithoutClienteInput, OperazioneUncheckedUpdateWithoutClienteInput>
    create: XOR<OperazioneCreateWithoutClienteInput, OperazioneUncheckedCreateWithoutClienteInput>
  }

  export type OperazioneUpdateWithWhereUniqueWithoutClienteInput = {
    where: OperazioneWhereUniqueInput
    data: XOR<OperazioneUpdateWithoutClienteInput, OperazioneUncheckedUpdateWithoutClienteInput>
  }

  export type OperazioneUpdateManyWithWhereWithoutClienteInput = {
    where: OperazioneScalarWhereInput
    data: XOR<OperazioneUpdateManyMutationInput, OperazioneUncheckedUpdateManyWithoutClienteInput>
  }

  export type OperazioneScalarWhereInput = {
    AND?: OperazioneScalarWhereInput | OperazioneScalarWhereInput[]
    OR?: OperazioneScalarWhereInput[]
    NOT?: OperazioneScalarWhereInput | OperazioneScalarWhereInput[]
    id?: IntFilter<"Operazione"> | number
    datacreazione?: DateTimeNullableFilter<"Operazione"> | Date | string | null
    tipo?: StringNullableFilter<"Operazione"> | string | null
    codice?: StringNullableFilter<"Operazione"> | string | null
    anno?: IntNullableFilter<"Operazione"> | number | null
    idazienda?: IntNullableFilter<"Operazione"> | number | null
    idcliente?: IntNullableFilter<"Operazione"> | number | null
    idintervento?: IntNullableFilter<"Operazione"> | number | null
    operatore?: StringNullableFilter<"Operazione"> | string | null
    idprodotto?: IntNullableFilter<"Operazione"> | number | null
    dataesecuzione?: DateTimeNullableFilter<"Operazione"> | Date | string | null
    orainizio?: IntNullableFilter<"Operazione"> | number | null
    orafine?: IntNullableFilter<"Operazione"> | number | null
    totaleore?: IntNullableFilter<"Operazione"> | number | null
    osservazioni?: StringNullableFilter<"Operazione"> | string | null
    codicecliente?: StringNullableFilter<"Operazione"> | string | null
    stato?: IntNullableFilter<"Operazione"> | number | null
    eliminato?: StringNullableFilter<"Operazione"> | string | null
    idprodottocliente?: IntNullableFilter<"Operazione"> | number | null
    faseoperazione?: IntNullableFilter<"Operazione"> | number | null
  }

  export type ClienteProdottoUpsertWithWhereUniqueWithoutClienteInput = {
    where: ClienteProdottoWhereUniqueInput
    update: XOR<ClienteProdottoUpdateWithoutClienteInput, ClienteProdottoUncheckedUpdateWithoutClienteInput>
    create: XOR<ClienteProdottoCreateWithoutClienteInput, ClienteProdottoUncheckedCreateWithoutClienteInput>
  }

  export type ClienteProdottoUpdateWithWhereUniqueWithoutClienteInput = {
    where: ClienteProdottoWhereUniqueInput
    data: XOR<ClienteProdottoUpdateWithoutClienteInput, ClienteProdottoUncheckedUpdateWithoutClienteInput>
  }

  export type ClienteProdottoUpdateManyWithWhereWithoutClienteInput = {
    where: ClienteProdottoScalarWhereInput
    data: XOR<ClienteProdottoUpdateManyMutationInput, ClienteProdottoUncheckedUpdateManyWithoutClienteInput>
  }

  export type ClienteProdottoScalarWhereInput = {
    AND?: ClienteProdottoScalarWhereInput | ClienteProdottoScalarWhereInput[]
    OR?: ClienteProdottoScalarWhereInput[]
    NOT?: ClienteProdottoScalarWhereInput | ClienteProdottoScalarWhereInput[]
    id?: IntFilter<"ClienteProdotto"> | number
    idcliente?: IntFilter<"ClienteProdotto"> | number
    idprodotto?: IntNullableFilter<"ClienteProdotto"> | number | null
  }

  export type ClienteContattoUpsertWithWhereUniqueWithoutClienteInput = {
    where: ClienteContattoWhereUniqueInput
    update: XOR<ClienteContattoUpdateWithoutClienteInput, ClienteContattoUncheckedUpdateWithoutClienteInput>
    create: XOR<ClienteContattoCreateWithoutClienteInput, ClienteContattoUncheckedCreateWithoutClienteInput>
  }

  export type ClienteContattoUpdateWithWhereUniqueWithoutClienteInput = {
    where: ClienteContattoWhereUniqueInput
    data: XOR<ClienteContattoUpdateWithoutClienteInput, ClienteContattoUncheckedUpdateWithoutClienteInput>
  }

  export type ClienteContattoUpdateManyWithWhereWithoutClienteInput = {
    where: ClienteContattoScalarWhereInput
    data: XOR<ClienteContattoUpdateManyMutationInput, ClienteContattoUncheckedUpdateManyWithoutClienteInput>
  }

  export type ClienteContattoScalarWhereInput = {
    AND?: ClienteContattoScalarWhereInput | ClienteContattoScalarWhereInput[]
    OR?: ClienteContattoScalarWhereInput[]
    NOT?: ClienteContattoScalarWhereInput | ClienteContattoScalarWhereInput[]
    id?: IntFilter<"ClienteContatto"> | number
    idcliente?: IntFilter<"ClienteContatto"> | number
  }

  export type ClienteContrattoUpsertWithWhereUniqueWithoutClienteInput = {
    where: ClienteContrattoWhereUniqueInput
    update: XOR<ClienteContrattoUpdateWithoutClienteInput, ClienteContrattoUncheckedUpdateWithoutClienteInput>
    create: XOR<ClienteContrattoCreateWithoutClienteInput, ClienteContrattoUncheckedCreateWithoutClienteInput>
  }

  export type ClienteContrattoUpdateWithWhereUniqueWithoutClienteInput = {
    where: ClienteContrattoWhereUniqueInput
    data: XOR<ClienteContrattoUpdateWithoutClienteInput, ClienteContrattoUncheckedUpdateWithoutClienteInput>
  }

  export type ClienteContrattoUpdateManyWithWhereWithoutClienteInput = {
    where: ClienteContrattoScalarWhereInput
    data: XOR<ClienteContrattoUpdateManyMutationInput, ClienteContrattoUncheckedUpdateManyWithoutClienteInput>
  }

  export type ClienteContrattoScalarWhereInput = {
    AND?: ClienteContrattoScalarWhereInput | ClienteContrattoScalarWhereInput[]
    OR?: ClienteContrattoScalarWhereInput[]
    NOT?: ClienteContrattoScalarWhereInput | ClienteContrattoScalarWhereInput[]
    id?: IntFilter<"ClienteContratto"> | number
    idcliente?: IntFilter<"ClienteContratto"> | number
  }

  export type ClienteNotaUpsertWithWhereUniqueWithoutClienteInput = {
    where: ClienteNotaWhereUniqueInput
    update: XOR<ClienteNotaUpdateWithoutClienteInput, ClienteNotaUncheckedUpdateWithoutClienteInput>
    create: XOR<ClienteNotaCreateWithoutClienteInput, ClienteNotaUncheckedCreateWithoutClienteInput>
  }

  export type ClienteNotaUpdateWithWhereUniqueWithoutClienteInput = {
    where: ClienteNotaWhereUniqueInput
    data: XOR<ClienteNotaUpdateWithoutClienteInput, ClienteNotaUncheckedUpdateWithoutClienteInput>
  }

  export type ClienteNotaUpdateManyWithWhereWithoutClienteInput = {
    where: ClienteNotaScalarWhereInput
    data: XOR<ClienteNotaUpdateManyMutationInput, ClienteNotaUncheckedUpdateManyWithoutClienteInput>
  }

  export type ClienteNotaScalarWhereInput = {
    AND?: ClienteNotaScalarWhereInput | ClienteNotaScalarWhereInput[]
    OR?: ClienteNotaScalarWhereInput[]
    NOT?: ClienteNotaScalarWhereInput | ClienteNotaScalarWhereInput[]
    id?: IntFilter<"ClienteNota"> | number
    idcliente?: IntFilter<"ClienteNota"> | number
  }

  export type ClienteCreateWithoutContattiInput = {
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoCreateNestedManyWithoutClienteInput
    note?: ClienteNotaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutContattiInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneUncheckedCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoUncheckedCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoUncheckedCreateNestedManyWithoutClienteInput
    note?: ClienteNotaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutContattiInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutContattiInput, ClienteUncheckedCreateWithoutContattiInput>
  }

  export type ClienteUpsertWithoutContattiInput = {
    update: XOR<ClienteUpdateWithoutContattiInput, ClienteUncheckedUpdateWithoutContattiInput>
    create: XOR<ClienteCreateWithoutContattiInput, ClienteUncheckedCreateWithoutContattiInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutContattiInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutContattiInput, ClienteUncheckedUpdateWithoutContattiInput>
  }

  export type ClienteUpdateWithoutContattiInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutContattiInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUncheckedUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUncheckedUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUncheckedUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateWithoutContrattiInput = {
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoCreateNestedManyWithoutClienteInput
    note?: ClienteNotaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutContrattiInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneUncheckedCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoUncheckedCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoUncheckedCreateNestedManyWithoutClienteInput
    note?: ClienteNotaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutContrattiInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutContrattiInput, ClienteUncheckedCreateWithoutContrattiInput>
  }

  export type ClienteUpsertWithoutContrattiInput = {
    update: XOR<ClienteUpdateWithoutContrattiInput, ClienteUncheckedUpdateWithoutContrattiInput>
    create: XOR<ClienteCreateWithoutContrattiInput, ClienteUncheckedCreateWithoutContrattiInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutContrattiInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutContrattiInput, ClienteUncheckedUpdateWithoutContrattiInput>
  }

  export type ClienteUpdateWithoutContrattiInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutContrattiInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUncheckedUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUncheckedUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUncheckedUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateWithoutNoteInput = {
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutNoteInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneUncheckedCreateNestedManyWithoutClienteInput
    prodotti?: ClienteProdottoUncheckedCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoUncheckedCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutNoteInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutNoteInput, ClienteUncheckedCreateWithoutNoteInput>
  }

  export type ClienteUpsertWithoutNoteInput = {
    update: XOR<ClienteUpdateWithoutNoteInput, ClienteUncheckedUpdateWithoutNoteInput>
    create: XOR<ClienteCreateWithoutNoteInput, ClienteUncheckedCreateWithoutNoteInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutNoteInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutNoteInput, ClienteUncheckedUpdateWithoutNoteInput>
  }

  export type ClienteUpdateWithoutNoteInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUncheckedUpdateManyWithoutClienteNestedInput
    prodotti?: ClienteProdottoUncheckedUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUncheckedUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateWithoutProdottiInput = {
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoCreateNestedManyWithoutClienteInput
    note?: ClienteNotaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutProdottiInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
    operazioni?: OperazioneUncheckedCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoUncheckedCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoUncheckedCreateNestedManyWithoutClienteInput
    note?: ClienteNotaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutProdottiInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutProdottiInput, ClienteUncheckedCreateWithoutProdottiInput>
  }

  export type ClienteUpsertWithoutProdottiInput = {
    update: XOR<ClienteUpdateWithoutProdottiInput, ClienteUncheckedUpdateWithoutProdottiInput>
    create: XOR<ClienteCreateWithoutProdottiInput, ClienteUncheckedCreateWithoutProdottiInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutProdottiInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutProdottiInput, ClienteUncheckedUpdateWithoutProdottiInput>
  }

  export type ClienteUpdateWithoutProdottiInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutProdottiInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    operazioni?: OperazioneUncheckedUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUncheckedUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUncheckedUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateWithoutOperazioniInput = {
    codicecliente?: string | null
    idazienda?: number | null
    prodotti?: ClienteProdottoCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoCreateNestedManyWithoutClienteInput
    note?: ClienteNotaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutOperazioniInput = {
    id?: number
    codicecliente?: string | null
    idazienda?: number | null
    prodotti?: ClienteProdottoUncheckedCreateNestedManyWithoutClienteInput
    contatti?: ClienteContattoUncheckedCreateNestedManyWithoutClienteInput
    contratti?: ClienteContrattoUncheckedCreateNestedManyWithoutClienteInput
    note?: ClienteNotaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutOperazioniInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutOperazioniInput, ClienteUncheckedCreateWithoutOperazioniInput>
  }

  export type ClienteUpsertWithoutOperazioniInput = {
    update: XOR<ClienteUpdateWithoutOperazioniInput, ClienteUncheckedUpdateWithoutOperazioniInput>
    create: XOR<ClienteCreateWithoutOperazioniInput, ClienteUncheckedCreateWithoutOperazioniInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutOperazioniInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutOperazioniInput, ClienteUncheckedUpdateWithoutOperazioniInput>
  }

  export type ClienteUpdateWithoutOperazioniInput = {
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    prodotti?: ClienteProdottoUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutOperazioniInput = {
    id?: IntFieldUpdateOperationsInput | number
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    prodotti?: ClienteProdottoUncheckedUpdateManyWithoutClienteNestedInput
    contatti?: ClienteContattoUncheckedUpdateManyWithoutClienteNestedInput
    contratti?: ClienteContrattoUncheckedUpdateManyWithoutClienteNestedInput
    note?: ClienteNotaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ProdottoVoceCreateWithoutProdottoInput = {

  }

  export type ProdottoVoceUncheckedCreateWithoutProdottoInput = {
    id?: number
  }

  export type ProdottoVoceCreateOrConnectWithoutProdottoInput = {
    where: ProdottoVoceWhereUniqueInput
    create: XOR<ProdottoVoceCreateWithoutProdottoInput, ProdottoVoceUncheckedCreateWithoutProdottoInput>
  }

  export type ProdottoVoceCreateManyProdottoInputEnvelope = {
    data: ProdottoVoceCreateManyProdottoInput | ProdottoVoceCreateManyProdottoInput[]
  }

  export type ProdottoVoceUpsertWithWhereUniqueWithoutProdottoInput = {
    where: ProdottoVoceWhereUniqueInput
    update: XOR<ProdottoVoceUpdateWithoutProdottoInput, ProdottoVoceUncheckedUpdateWithoutProdottoInput>
    create: XOR<ProdottoVoceCreateWithoutProdottoInput, ProdottoVoceUncheckedCreateWithoutProdottoInput>
  }

  export type ProdottoVoceUpdateWithWhereUniqueWithoutProdottoInput = {
    where: ProdottoVoceWhereUniqueInput
    data: XOR<ProdottoVoceUpdateWithoutProdottoInput, ProdottoVoceUncheckedUpdateWithoutProdottoInput>
  }

  export type ProdottoVoceUpdateManyWithWhereWithoutProdottoInput = {
    where: ProdottoVoceScalarWhereInput
    data: XOR<ProdottoVoceUpdateManyMutationInput, ProdottoVoceUncheckedUpdateManyWithoutProdottoInput>
  }

  export type ProdottoVoceScalarWhereInput = {
    AND?: ProdottoVoceScalarWhereInput | ProdottoVoceScalarWhereInput[]
    OR?: ProdottoVoceScalarWhereInput[]
    NOT?: ProdottoVoceScalarWhereInput | ProdottoVoceScalarWhereInput[]
    id?: IntFilter<"ProdottoVoce"> | number
    idprodotto?: IntNullableFilter<"ProdottoVoce"> | number | null
  }

  export type ProdottoCreateWithoutVociInput = {
    nome?: string | null
  }

  export type ProdottoUncheckedCreateWithoutVociInput = {
    id?: number
    nome?: string | null
  }

  export type ProdottoCreateOrConnectWithoutVociInput = {
    where: ProdottoWhereUniqueInput
    create: XOR<ProdottoCreateWithoutVociInput, ProdottoUncheckedCreateWithoutVociInput>
  }

  export type ProdottoUpsertWithoutVociInput = {
    update: XOR<ProdottoUpdateWithoutVociInput, ProdottoUncheckedUpdateWithoutVociInput>
    create: XOR<ProdottoCreateWithoutVociInput, ProdottoUncheckedCreateWithoutVociInput>
    where?: ProdottoWhereInput
  }

  export type ProdottoUpdateToOneWithWhereWithoutVociInput = {
    where?: ProdottoWhereInput
    data: XOR<ProdottoUpdateWithoutVociInput, ProdottoUncheckedUpdateWithoutVociInput>
  }

  export type ProdottoUpdateWithoutVociInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProdottoUncheckedUpdateWithoutVociInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutPianningEmailInput = {
    nome?: string | null
    cognome?: string | null
    email: string
    password: string
    societa?: string | null
    tecnicocod?: string | null
    attivo?: string
    typeutente?: string
    colore?: string | null
  }

  export type UserUncheckedCreateWithoutPianningEmailInput = {
    idLogin?: number
    nome?: string | null
    cognome?: string | null
    email: string
    password: string
    societa?: string | null
    tecnicocod?: string | null
    attivo?: string
    typeutente?: string
    colore?: string | null
  }

  export type UserCreateOrConnectWithoutPianningEmailInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPianningEmailInput, UserUncheckedCreateWithoutPianningEmailInput>
  }

  export type UserUpsertWithoutPianningEmailInput = {
    update: XOR<UserUpdateWithoutPianningEmailInput, UserUncheckedUpdateWithoutPianningEmailInput>
    create: XOR<UserCreateWithoutPianningEmailInput, UserUncheckedCreateWithoutPianningEmailInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPianningEmailInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPianningEmailInput, UserUncheckedUpdateWithoutPianningEmailInput>
  }

  export type UserUpdateWithoutPianningEmailInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    cognome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    societa?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicocod?: NullableStringFieldUpdateOperationsInput | string | null
    attivo?: StringFieldUpdateOperationsInput | string
    typeutente?: StringFieldUpdateOperationsInput | string
    colore?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateWithoutPianningEmailInput = {
    idLogin?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    cognome?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    societa?: NullableStringFieldUpdateOperationsInput | string | null
    tecnicocod?: NullableStringFieldUpdateOperationsInput | string | null
    attivo?: StringFieldUpdateOperationsInput | string
    typeutente?: StringFieldUpdateOperationsInput | string
    colore?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PianningEmailCreateManyUserInput = {
    id?: number
  }

  export type PianningEmailUpdateWithoutUserInput = {

  }

  export type PianningEmailUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PianningEmailUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type OperazioneCreateManyClienteInput = {
    id?: number
    datacreazione?: Date | string | null
    tipo?: string | null
    codice?: string | null
    anno?: number | null
    idazienda?: number | null
    idintervento?: number | null
    operatore?: string | null
    idprodotto?: number | null
    dataesecuzione?: Date | string | null
    orainizio?: number | null
    orafine?: number | null
    totaleore?: number | null
    osservazioni?: string | null
    codicecliente?: string | null
    stato?: number | null
    eliminato?: string | null
    idprodottocliente?: number | null
    faseoperazione?: number | null
  }

  export type ClienteProdottoCreateManyClienteInput = {
    id?: number
    idprodotto?: number | null
  }

  export type ClienteContattoCreateManyClienteInput = {
    id?: number
  }

  export type ClienteContrattoCreateManyClienteInput = {
    id?: number
  }

  export type ClienteNotaCreateManyClienteInput = {
    id?: number
  }

  export type OperazioneUpdateWithoutClienteInput = {
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OperazioneUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    datacreazione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    codice?: NullableStringFieldUpdateOperationsInput | string | null
    anno?: NullableIntFieldUpdateOperationsInput | number | null
    idazienda?: NullableIntFieldUpdateOperationsInput | number | null
    idintervento?: NullableIntFieldUpdateOperationsInput | number | null
    operatore?: NullableStringFieldUpdateOperationsInput | string | null
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
    dataesecuzione?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orainizio?: NullableIntFieldUpdateOperationsInput | number | null
    orafine?: NullableIntFieldUpdateOperationsInput | number | null
    totaleore?: NullableIntFieldUpdateOperationsInput | number | null
    osservazioni?: NullableStringFieldUpdateOperationsInput | string | null
    codicecliente?: NullableStringFieldUpdateOperationsInput | string | null
    stato?: NullableIntFieldUpdateOperationsInput | number | null
    eliminato?: NullableStringFieldUpdateOperationsInput | string | null
    idprodottocliente?: NullableIntFieldUpdateOperationsInput | number | null
    faseoperazione?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteProdottoUpdateWithoutClienteInput = {
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteProdottoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteProdottoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    idprodotto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClienteContattoUpdateWithoutClienteInput = {

  }

  export type ClienteContattoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteContattoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteContrattoUpdateWithoutClienteInput = {

  }

  export type ClienteContrattoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteContrattoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteNotaUpdateWithoutClienteInput = {

  }

  export type ClienteNotaUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ClienteNotaUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ProdottoVoceCreateManyProdottoInput = {
    id?: number
  }

  export type ProdottoVoceUpdateWithoutProdottoInput = {

  }

  export type ProdottoVoceUncheckedUpdateWithoutProdottoInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ProdottoVoceUncheckedUpdateManyWithoutProdottoInput = {
    id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}